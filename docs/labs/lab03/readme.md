Convergence Tests
=====================================
This week we are going to continue looking at isolated molecules. Specifically, we will be focusing on determining how well converged our results are. This is a necessary step to have any confidence in your results, and to make sure the result is meaningful. This should always be done before running calculations on new systems.

Before starting, if you can't remember how to do something from the command line, you can always refer back to [Lab 1](../lab01/readme.md).

-------------------------------------------------------------------------------------------



## Plane Waves and Pseudopotentials

As will be discussed in lectures, pseudopotentials are used in DFT calculations to approximate the potential of the core region. The core is made up of tightly bound electrons close to the nucleus. In this region, the electrons are in a strong coulomb potential generated by the nucleus. This creates a strong oscillation in the electronic wavefucntions in the core region. If one wanted to express the electronic wavefunctions in a plane-wave basis, this rapid oscillation of the electronic wavefucntion would require a significant number of plane waves to describe. To reduce the number of plane-waves needed in the expansion of the Kohn-Sham wavefunctions, and thus reduce the computational load significantly, we approximate the core region. This is essentially 'freezing' the core electrons. The self-consistent calculations are therefore only done on the valence electrons.

The motivation for this is that most of the interesting chemistry we want to study is dictated by the valence electorns, and thus approximating the core is reasonable. A pseudopotential will therefore replace the exact core potnetial with an approximate potential that mimics the effects of the core electrons on the valence electrons, but is also a smooth, slowly varing potential. Diagramatically this looks like the following:

<figure markdown="span">
  ![Pseudopotential](assets/pseudopotential.png){ width="400" }
</figure>

Pseudopotentials are created from DFT calculations of single atoms (so-called 'all electron' calculations). In these calculations, a certain exchange-correlation functional will have been chosen e.g. local density approximation (lda), pbe, etc. Thus, within the pseudopotential itself an approximation has been made to generate it.

The header of pseudopotential files contain valuable information about how the pseudopotential was generated, such as what states are included, and what approximations are used for exchange and correlation.

To start this lab, copy the `/opt/MSE404-MM/docs/labs/lab03` to your `MSE404` directory.

!!! example "Task 1 - Pseudopotential File"

    Navigate to the `01_carbon_monoxide/01_convergence_threshold` directory. Here you will see an input file `CO.in` and two psedupotnetial files. Open the pseudopotential file for oxygen using the `less` command.

    - What level of approximation are we using e.g. Local Density Approximation (LDA), PBE, etc..? Hint: This is usually stored at the top of pseudopotential files.

        ??? success "Answer"
            LDA. This is found at the top of the pseudopotential file:

            ```
            Info:   O LDA 2s2 2p4 RRKJ3 US
            ```

    - What were the 'core' and 'valence' states used to generate the pseudopotential file??

        ??? success "Answer"
            The states listed in the PP file are the valence states, and thus these are:
            ```
            nl pn  l   occ               Rcut            Rcut US             E pseuo
            2S  0  0  2.00      0.00000000000      0.00000000000      0.00000000000
            2P  0  1  2.00      0.00000000000      0.00000000000      0.00000000000
            ```
            The core states are therefore 1S.
    - What is the valence charge on the oxygen after the core has been approximated?

        ??? success "Answer"
            The valence charge is 4. Found by identifying the line `4.00000000000 Z valence` in the information below:
            ```
            <PP_HEADER>
            0                      Version Number
            C                      Element
            NC                     Norm - Conserving pseudopotential
            F                      Nonlinear Core Correction
            SLA PZ NOGX NOGC PZ    Exchange-Correlation functional
            4.00000000000          Z valence
            0.00000000000          Total energy
            0.0000000  0.0000000   Suggested cutoff for wfc and rho
            0                      Max angular momentum component
            269                    Number of points in mesh
            2    1                 Number of Wavefunctions, Number of Projectors
            Wavefunctions          nl  l   occ
                                   2S  0  2.00
                                   2P  1  2.00
            </PP_HEADER>
            ```


## Total Energy Convergence

Let's look at a brief view of an example of the CO input file stored in `01_carbon_monoxide/01_convergence_threshold`.

!!! tip annotate "Tip: In-code annotations"
    Click (1) to see notes on the input tags.

1. This is an annotation

```bash
&CONTROL
   calculation      = 'scf'
   disk_io          = 'none' #(1)!
   pseudo_dir       = '.' #(2)!
/

&SYSTEM
   ibrav            = 1 #(3)!
   A                = 30 #(4)!
   nat              = 2
   ntyp             = 2
   ecutwfc          = 20
/

&ELECTRONS
   mixing_beta      = 0.7
   diagonalization  = 'david'
   conv_thr = 1e-4 #(5)!
/

&IONS
/

&CELL
/

ATOMIC_SPECIES
O 15.999 O.pz-rrkjus.UPF #(6)!
C 12.011 C.pz-vbc.UPF 

K_POINTS gamma

ATOMIC_POSITIONS angstrom
O 15.0000000000 15.0000000000 16.1503400000
C 15.0000000000 15.0000000000 15.0000000000
```

1. This specifies that we don't want any of the charge density or wavefunction information saved in a file. We specify this just to save disk space :-).
2. Specifies that the pseudopotentials to use are in the current directory.
3. ibrav=1 is the bravais lattice type 'simple cubic'.
4. The lattice parameter for the bravais lattice.
5. This is the convergence threshold. Successive scf iterations will have their total energy compared to one another. When this difference is less than this convergence threshold, we deem the total energy to be converged.
6. The structure of this line is <element name> <element atomic mass> <name of pseudopotential>.


## Plane-wave energy cut-off

Regardless of the type of system you're looking at, you'll need to check how
well converged your result is (whatever it is your calculating) with respect
to the plane-wave energy cut-off. This governs how many plane-waves are
used in the expansion of the Kohn-Sham states (and thus how many are being calculated).

Let's again look at our CO2 input file:

```python
 &CONTROL
   pseudo_dir = '../../pseudo'
 /

 &SYSTEM
   ibrav = 1
   A = 10.0
   nat = 3
   ntyp = 2
   ecutwfc = 18.0 #(1)!
 /

 &ELECTRONS
 /

ATOMIC_SPECIES
 C  12.011  C.pz-vbc.UPF
 O  15.9999  O.pz-rrkjus.UPF

ATOMIC_POSITIONS angstrom
 C  0.0000  0.0000  0.0000
 O  0.0000  0.0000  1.1615
 O  0.0000  0.0000 -1.1615

K_POINTS gamma
```

1. Plane-wave energy cutoff (Ry)

Note that:

- Different systems converge differently. You souldn't expect diamond and silicon to be converged to the same accuracy with the same energy cutoff despite having the same structure and same number of valence electrons.

- Different pseudopotentials for the same atomic species will also converge differently. Often pseudopotential files will suggest an energy cutoff as mentioned previously.

- Different calculated parameters will converge differently. 
	- If we want to calculate the lattice parameter of a material, don't expect it to be converged to the same accuracy as another parameter e.g. the bulk modulus.

!!! warning
    You should be particularly careful when calculating parameters that depend on volume, as the number of plane-waves for a given energy cut-off is directly proportional to the volume so this can introduce an additional variation. We'll see more about this later.

An example demonstrating the total energy convergence with respect to energy cutoff is shown in the `02_ecut/01_carbon_dioxide` directory.
We have already set up a series of input files which are all identical except we systematically increase ***only*** the value of `ecutwfc`.

Examining [CO2_25.in](02_ecut/01_carbon_dioxide/CO2_25.in) we see some new parameters that should be explained.

```python
 &CONTROL
    pseudo_dir = '../../../pseudo' #(1)!
    disk_io = 'none' #(2)!
 /

 &SYSTEM
   ibrav = 1
   A = 10.0
   nat = 3
   ntyp = 2
   ecutwfc = 25.0 #(3)!
 /

 &ELECTRONS
    conv_thr = 1.0E-6 #(4)!
 /

ATOMIC_SPECIES
 C  12.011  C.pz-vbc.UPF
 O  15.9999  O.pz-rrkjus.UPF

ATOMIC_POSITIONS angstrom
 C  0.0000  0.0000  0.0000
 O  0.0000  0.0000  1.1615
 O  0.0000  0.0000 -1.1615

K_POINTS gamma
```

1. Central pseudopotential direcotry.
2. This supresses the generation of the wavefunction file and the folder with the charge density. At this point, we don't need to worry about these and it saves disk space :).
3. Plane-wave cutoff of 25 Ry.
4. This variable controls when the self consistency cycle finishes. When the `estimated energy error < conv_thr` the self consistency cycle (scf) stops. You should be aware of this variable, as there is little point in trying to converge to greater accuracy than we are converging self-consistently.

!!! tip annotate "Tip: Running Quantum Espressso"
    Make sure to have loaded the quantum espresso module and its dependencies using the command:

    `module load quantum-espresso`

Now we want to run `pw.x` for each of these input files. It would be very tedious to do this manually, especially if we had more input files. This is where ***bash scripting*** comes in handy. We won't go too much into bash scripting, but if you are interested you are encouraged to spend some time understanding the bash scripts provided. Let's examine the simple script below:

```bash
#!/bin/bash

# Run pw.x for each input file sequentially
for i in {10..40..5}; #(1)!
do
	pw.x < CO2_$i.in &> CO2_$i.out #(2)!
done
```

1. For loop going from i=10 to i=40 in steps of 5.
2. Runs the command `pw.x < CO2_$i.in > CO2_$i.out` from i=10 to i=40.

We shouldn't need to do much to these scripts, apart from changing the loop index. However, feel free to play around with them as you get better with the linux command line!

To run the bash file, we use the command `./run.sh`. After some time, the output files should be in your directory.


!!! example "Task 2 - Running Convergence Tests"

    Run the bash file using the command `./run.sh`. After some time, examine the output files in your directory.

    - Check the output file `CO2_10.out`. What is the converged total energy?

        ??? success "Answer"
            `!    total energy              =     -71.18353288 Ry`

    - Check the output file `CO2_20.out`. What is the converged total energy? Is this lower than `CO2_10.out`?

        ??? success "Answer"
            `!    total energy              =     -74.57951430 Ry`.
            This is lower than the total energy in `CO2_10.out`.

As you should see, the total energy decreases as we increase the plane-wave energy cutoff `ecutwfc`.
We could go through each of these input files and look for the final energy. However, this would be tedious and time consuming. We have provided another bash script `run_with_data_collect.sh` that collects the results for you and deposits them into a file called data.txt.

A quick look at the bash file:

```bash
#!/bin/bash

# Run pw.x for each input file sequentially
for i in {10..40..5};
do
        pw.x < CO2_$i.in &> CO2_$i.out
done

# Loop through files
for i in {10..40..5}; do
    # Extract 'ecutwfc' value from input molecule files
    ecutwfc_value=$(grep 'ecutwfc' CO2_$i.in | awk '{print $3}' | tr -d ', =') #(1)!

    # Extract 'Total Energy' value from input molecule files
    final_energy_value=$(grep '!' CO2_$i.out | awk '{print $5}') # Total energy (Ry) #(2)!

    # Multiply 'final_energy_value' by 13.6
    final_energy_value=$(echo "$final_energy_value * 13.6" | bc) # Converting final energy to eV

    # Append values to output file.
    echo "$ecutwfc_value $final_energy_value" >> data.txt
done

```

1. This line uses `awk`. Awk is a programming language that is designed for processing text-based data. We don't use most of its functionalities here. All we are using it for is printing out a column of the output of the grep command. Additionally, it uses tr -d which is a method of removing puncuation to keep the script from breaking if punctuation is included where it shouldn't be. 
2. The line with the converged total energy on starts with a '!', allowing for easy access using `grep`.


!!! example "Task 3 - Running Convergence Tests"

    Run the next bash file using the command `./run_with_data_collect.sh`. After some time the bash file will have run. Examine the file data.txt.
    
    - What is the structure of the data.txt file?

        ??? success "Answer"
            The first column is ecutwfc (Ry) and the second column is Total Energy (eV)

Through this course you will need to do many convergence tests. You have been provided with scripts that generate the input files for you, as well as helping to plot your results. In the direcory for methane, `02_ecut/02_methane`, we will go through how to use these scripts.

The first script we will use is named `file_build.py`. This is a python file that will generate all of our input files. Let's examine it:

```python
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
#                           This is a python file that will generate multiple input files for a convergence test.                            #
#                                                                                                                                            #
#                   How to use: Copy and paste the text from your input file to common_content_template as shown below.                      #
#                               Make sure you are putting a space both sides of = sign when pasting.                                         #
#                                                                                                                                            #
#                                                   How to run: python3 file_build.py                                                        #
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################


# Directory where you want to create the files
output_directory = "./"

# Number of files to create
num_files = 10 #(1)!

# Common content template with a placeholder for the number
common_content_template = """

""" #(2)!

# Loop to create the files
for i in range(1, num_files + 1):
    # Define the content for each file with the number replaced
    calc = round(5+5*i) #(3)!
    content = common_content_template.format(calc)

    # Generate the file name
    file_name = f"{output_directory}/scf.mol.{str(i).zfill(3)}.in" #(4)!

    # Open and write to the file directly
    with open(file_name, 'w') as file:
        file.write(content)
```

1. Number of files you want to create. This can control the maximum cutoff that you are testing.
2. A blank template. Here you will paste the contents of your desired input file, but with `ecutwfc = {}`. Make sure to leave a space either side of the = sign here. If this is unclear, check the file file_builder_model.py.
3. Incrementing the cutoff from 10 Ry to the desired amount. Can also alter this for larger spacings.
4. Output files will be named scf.mol.001.in, scf.mol.002.in etc. 

To run this file you will need to edit it and paste the input file that you want to generate multiple instances of. In our case, that is the information stored in `CH4_base.in`. The only thing we need to replace is `ecutwfc = xxxx` with `ecutwfc = {}`. If you are struggling with this, take a look at the file file_build_model.py for how the file should look. After this issue the command:

```bash 
python3 file_build.py
```

You should now have many input files generated. Examine them to make sure everything has been generated correctly.

Next, examine the `run.sh` file:

```bash
#!/bin/bash

# Run scf calculations.
for i in {001..010}; #(1)!
do
    pw.x < scf.mol.$i.in > scf.mol.$i.out #(2)!
done

# Loop through files
for i in {001..010}; do #(3)!
    # Extract 'ecutwfc' value from input molecule files
    ecutwfc_value=$(grep 'ecutwfc' scf.mol.$i.in | awk '{print $3}' | tr -d ', =')

    # Extract 'Total Energy' value from input molecule files
    final_energy_value=$(grep '!' scf.mol.$i.out | awk '{print $5}')

    # Multiply 'final_energy_value' by 13.6
    final_energy_value=$(echo "$final_energy_value * 13.6" | bc)

    echo "$ecutwfc_value $final_energy_value" >> data.txt
done
```

1. Looping from 001 to 010 in steps of 001.
2. Runs pw.x for the files scf.mol.001.in, scf.mol.002.in etc.
3. Looping again from 001 to 010 in steps of 001.

!!! example "Task 4 - Running Convergence Tests With Scripts"

    In `file_build.py` change `num_files` to  20. In `run.sh` change the for loop to go from 001 to 020. Generate the input files as described above. Run the bash file as before, using the command `./run.sh`. After some time the bash file will have run. Examine the file `data.txt`.
    
    - At what plane-wave cutoff is the total energy converged to within 0.1 eV of your most accurate run?

        ??? success "Result"
            ecutwfc = 75 Ry.

            $E_{T}^{\text{best}} = -218.233323168 \,\text{eV}$

            $E_{T}^{75} = -218.15564649599997 \,\text{eV}$

            $E_{T}^{\text{diff}} = -0.07767667200002393 \,\text{eV}$

Again, this is quite tedious to find by hand. You have been provided with another script `convergence_processing.py` which analyses the results stored in data.txt and shows where the calculation has converged to within a specified tolerance.
Let's take a quick look at this script:

```python
import numpy as np
import matplotlib.pyplot as plt
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
#                               This script checks for converged results. Change the convergence parameter if needed.                        #
#                                                                                                                                            #
#                                               How to run: python3 convergence_processing.py                                                #
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################

def main():
    filename = "data.txt" #(1)!

    edata = np.loadtxt(filename, delimiter=' ') #(2)!
    ecut, etot = edata[:, 0], edata[:, 1]

    convergence_parameter = 0.01 #in eV #(3)!
    print(f"Convergence defined as within {convergence_parameter} meV of the most accurate result")
    flag = 0 # Flag for arrow

    print("ecut (Ry)", " ", "∆_last (meV)")
    print("-----------------------------------------------")
    for row in edata:
        diff = abs(abs(row[1])-abs(etot[-1]))*1000
        if (diff  <= convergence_parameter*1000 and flag==0):
            print(row[0],"  ", diff, "      <-------------")
            flag = 1
        else:
            print(row[0],"  ", diff)

    for i in range(0, len(ecut)):
        if abs(etot[i] - etot[-1]) <= convergence_parameter:
            value = ecut[i]
            print("")
            print(f"Accuracy of {convergence_parameter*1000} meV")
            print(f"Convergence at ecutwfc = {value} Ry")
            break
        else:
            continue
	...
```

1. Name of file that we have our data stored in.
2. Loading in the contents of the file.
3. Defining our convergence threshold. This value is in eV. Here, we define convergence as within 10 meV of our most accurate calculation.

!!! example "Task 5 - Running Convergence Tests With Scripts"

    Alter the convergence threshold in `convergence_processing.py` to be 0.1 eV and run the convergence script with the command:
    `python3 convergence_processing.py`

    - What is output on your terminal? What plane-wave cutoff gives us a result converged to within 0.1 eV of the most accurate calculation?

        ??? success "Result"
            ecutwfc = 75 Ry.
            <figure markdown="span">
            ![Diamond primitive cell](assets/methane_convergence_results.png){ width="500" }
            </figure>


#### System Size Considerations
Actually, we typically converge the total energy ***per atom*** (meV/atom). This is due to the scaling of the total energy with system size (number of atoms). 

If we have more atoms in our system, the magnitude of the total energy will naturally be larger i.e. the total energy scales with system size. However, the total energy per atom is a normalised quantity, providing a measure of the total energy that is independent of system size, and thus can be compared between systems to make sure you are converged to the same accuracy.

!!! Important "General Scripts"
    The scripts you have been provided in `02_ecut/02_methane` are quite general. You can use them through the course. There are more like these in the `/opt/MSE404-MM/docs/labs/useful_scripts` directory.

## Plotting

### Python

Most of the plotting in this course can be done with Python. Scripts will be provided for you, but you are encouraged to play around with them to fit your needs if you want to test things out.

You will have noticed that at the end of the `convergence_processing.py` there is more python code. This uses matplotlib to plot the results stored in data.txt to visualise the convergence as ecutwfc is increased.
Later on in the course you will have python scripts to plot band structures and density of states.

For now, we will have a brief overview of the final few lines of `convergence_processing.py`.

```python
import numpy as np
import matplotlib.pyplot as plt
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################
#                               This script checks for converged results. Change the convergence parameter if needed.                        #
#                                                                                                                                            #
#                                               How to run: python3 convergence_processing.py                                                #
##############################################################################################################################################
##############################################################################################################################################
##############################################################################################################################################

def main():
    filename = "data.txt"

    edata = np.loadtxt(filename, delimiter=' ')
    ecut, etot = edata[:, 0], edata[:, 1]

    convergence_parameter = 0.1 #in eV
    print(f"Convergence defined as within {convergence_parameter} meV/atom of the most accurate result")
    flag = 0 # Flag for arrow

    print("ecut (Ry)", " ", "∆_last (meV/atom)")
    print("-----------------------------------------------")
    for row in edata:
        diff = abs(abs(row[1])-abs(etot[-1]))*1000
        if (diff  <= convergence_parameter*1000 and flag==0):
            print(row[0],"  ", diff, "      <-------------")
            flag = 1
        else:
            print(row[0],"  ", diff)

    for i in range(0, len(ecut)):
        if abs(etot[i] - etot[-1]) <= convergence_parameter:
            value = ecut[i]
            print("")
            print(f"Accuracy of {convergence_parameter*1000} meV")
            print(f"Convergence at ecutwfc = {value} Ry")
            break
        else:
            continue

    plt.figure(figsize=(8, 6)) #(1)!
    plt.scatter(ecut , etot, color='black', marker='o') #(2)!

    plt.ylabel("Total Energy (eV)")
    plt.xlabel("Energy Cutoff (Ry)")
    plt.title("Convergence Testing")
    plt.show() #(3)!

if __name__ == "__main__":
    main()
```

1. Initialising the size of our figure. Changing these will change the aspect ratio of the plot.
2. Scatter plot of ecut vs etot.
3. After giving python all of the plotting information, we tell it to plot.

!!! example "Task 6 - Convergence Plot"

    Uncomment the final few lines of the `convergence_processing.py` and run it again.

    - What do you expect the plot to look like?

    ??? success "Result"
        <figure markdown="span">
        ![ecutwfc_plot](assets/ecutwfc-conv-plot.png){ width="500" }
        </figure>


!!! example "Task 7 - Convergence of CO2 vs Methane"

    We have now done a convergence test using the scripts `file_builder.py` and `convergence_processing.py` for methane. Copy `convergence_processing.py` and `file_build.py` to `02_ecut/01/carbon_dioxide`. Redo the convergence for CO2 using the convergence scripts as we did above using the script `run_02.sh`. Before running anything, make sure to remove the `data.txt` that is already in this directory from our previous calculation.

    - Which molecule has the lower plane-wave cutoff?

    ??? success "Answer"
        After running `convergence_processing.py` we can see that:

        $E_{\text{cut}}^{\text{CO2}} = 65 \,\text{Ry}$

        $E_{\text{cut}}^{\text{Methane}} = 75 \,\text{Ry}$

        CO2 Has the lower plane-wave energy cutoff.

    - What do the convergence plots look like?

    ??? success "Result"
        <figure markdown="span">
        ![ecutwfc_plot](assets/ecutwfc-conv-plot-CO2.png){ width="500" }
        </figure>
        <figure markdown="span">
        ![ecutwfc_plot](assets/ecutwfc-conv-plot-Methane.png){ width="500" }
        </figure>

    - Is this a fair comparison?

    ??? success "Answer"
        No. If we want to compare the two we should have convegred the total energy per atom.



## Exchange & Correlation Functional

How we approximate the exchange and correlation between elections is a key part of DFT. The functional that we use determines how we approximate these many-body interactions.

By default, Quantum Espresso reads what exchange correlation functional to use from the header of the pseudopotential file, as we saw earlier in Task 1.
It is possible to override this by using the `input_dft` variable in the &system section.

!!! Warning "Mixing Approximations"
    It is generally not a good idea to mix approximations. It is best to use the same approximation for the exchange correlation functional as was used to construct the pseudopotential.

As you might expect, the exchange correlation functional chosen can have a big impact on a number of parameters. When we change the exchange correlation functional, we are changing the level of theory our calculations are running at.

??? note "Levels of approximation"
    - Lowest level of approximation is the local density approximation (LDA)
    - Next highest level of approximation is the generalised gradient approximation (GGA)
    - More complicated functionals like 'meta-GGA', 'hybrid' etc.

    This is usually depicted in 'Jacob's ladder' of approximations, where the higher on the ladder you are, the more accurate the more accurate the description of exchange and correlation between the electrons are.
    <figure markdown="span">
    ![Jacobs-ladder](assets/Jacobs-ladder.png){ width="500" }
    </figure>

In `03_argon` we are going to investigate the change in the binding energy as we vary the bond length between an argon dimer using two different levels of theory.

!!! example "Task 8 - Argon Dimer"
    Examine and run the scripts `file_builder.py` and `run.sh` in `03_argon/01_lda`.

    - What level theory is this at?

    ??? success "Answer"
        This is at the local density approximation (lda) level.

    - What are these script doing?

    ??? success "Answer"
        The script is generating multiple input files of varying bond length for the argon dimer and running a total energy calculation on them. The end of `run.sh` is collecting the relevant data for us and outputting it into a file called data.txt.
    
    Now examine and run the script `analysis.py`.

    - What is this script doing?

    ??? success "Answer"
        The script is looking through data.txt and finding the lowest energy. This is the 'optimal' distance between the two argon atoms.

    - At what distance does the argon dimer have the lowest energy?

    ??? success "Result"
        a = 3.4 Å gives the minimum energy of -1172.70049957 eV
        <figure markdown="span">
        ![lda-dimer](assets/lda-dimer.png){ width="500" }
        </figure>

    Do the same for `03_argon/02_pbe`. This is at the GGA level, specifically using the pbe functional.

    - At what distance does the argon dimer have the lowest energy?

    ??? success "Result"
        a = 4.0 Å gives the minimum energy of -1173.066229 eV

        However, the minimum is not very well defined.
        <figure markdown="span">
        ![pbe-dimer](assets/pbe-dimer.png){ width="500" }
        </figure>
    
    This is a known problem in DFT. LDA tends to 'overbind' and PBE tends to 'underbind'. In dimer situations like this Argon dimer, one may think van der Waals interactions are something important to consider. In fact, in this case it is very important. Van der Waals can be taken into account in different ways - an additional term added to the total energy or directly through the exchange-correlation potential.

    Navigate to `03_vdw`.

    - Run `file_build.py`. Examine the input files. You will see a tag `vdw_corr = 'grimme-d3'`. This means that we are going to include van der Waals corrections (via a total energy correction term).

    - At what distance does the argon dimer have the lowest energy?

    ??? success "Result"
        a = 3.8 Å gives the minimum energy of -1173.07559029 eV

        <figure markdown="span">
        ![pbe-dimer](assets/pbe-dimer-vdw.png){ width="500" }
        </figure>



## More Convergence Parameters

In this lab we have been dealing with isolated molecules. Quantum Espresso is a plane-wave DFT code, and thus deals with periodic unit cells. To model 'isolated' atoms, we make the unit cell very large compared to the size of the isolated molecule, effectively reducing any interaction with neighbouring periodic images. 
However, this is a parameter we should converge. A larger unit cell (volume) increases the computational cost, as the number of plane waves sales with the unit cell volume, so we don't want the unit cell too large. We should also have converged the total enegry versus the unit cell size.

Additionally, if we are dealing with crystals which are periodic, then we need to sample the Briouillin zone with 'k points'. This will be covered in [Lab 4](../lab04/readme.md). The number of k points used to sample the Briouillin zone should also be converged when dealing with periodic crystals.

------------------------------------------------------------------------------------

Summary
-------

In this lab we looked at defining pseudopotentials, checking the convergence of the total energy with respect to the plane-wave energy cutoff, and the effect of exchange and correlation functional.

- Convergence of any parameter is done by systematically varying the corresponding calculation parameter and looking at how the result changes.

We saw how we can use python and bash scripts to automate this process.

- We can use python scripts to generate multiple input files with systematically varied parameters.
- We can use a bash `for` loop to perform a calculation for a number of
  input files.
- We can use `grep` or `awk` to parse results or parameters from our
  output files.
- We can quickly generate a plot of a data file with pythons matplotlib.

------------------------------------------------------------------------------
