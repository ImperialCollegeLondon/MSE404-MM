{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modelling Materials with Density Functional Theory","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is the lab material for the Imperial College London, Department of Materials course \"MATE70020: Modelling Materials with Density Functional Theory\".</p> <p>This course is intended to introduce students to the modelling of materials with density-functional theory (DFT). In the labs we will use the free, open-source DFT code Quantum Espresso, but while the format of the input files may change in other DFT codes, the general principles will be the same. The labs will also briefly introduce student to the use of the Linux OS and how it enables the effective use of computational resources, as well as showing students some simple scripting, analysis, and visualization tools.</p>"},{"location":"#structure-of-the-labs","title":"Structure of the Labs","text":"<p>The labs are organised as follows:</p> <ul> <li>Lab 1: Getting started in Linux</li> <li>Lab 2: Quantum Espresso Input and Output</li> <li>Lab 3: Converging your Calculations</li> <li>Lab 4: Crystals and the Electronic Band Structure</li> <li>Lab 5: Metals and the Density of States</li> <li>Lab 6: Spin Polarization and Magnetic Systems</li> <li>Lab 7: Structural Optimisation</li> <li>Lab 8: Vibrational Normal Modes and Phonons</li> <li>Lab 9: Finite Temperature Properties</li> </ul>"},{"location":"#how-to-use-this-material","title":"How to Use this Material","text":"<p>The latest version of the course is available online at https://imperialcollegelondon.github.io/MSE404-MM/. The text source files named <code>readme.md</code> in the various directories use markdown. You can download the whole repository and view them in a terminal, or read them at the Github site https://imperialcollegelondon.github.io/MSE404-MM/.</p> <p>Each lab is designed to be self-contained. The webpage will show the general direction and explain the concepts, while the input files and scripts are stored in directories located along side the <code>readme.md</code> file, labeled by their apparences in the text. </p> <p>There will be code blocks like the one below in the text <pre><code>echo \"Hello World\"\n</code></pre> which are meant to be run in the terminal. And you can click the   icon on the right to copy the code to your clipboard.</p> <p>There will also be inline annotations () like the one  below:</p> <pre><code>program hello\n    print *, \"Hello World\" !(1)\nend program hello\n</code></pre> <ol> <li>Print the string \"Hello World\" to the terminal.</li> </ol> <p>You can click on the annotation to see the explanation.</p> <p>There will also be admonitions like the one below:</p> <p>Coder's Tip [important]</p> <p>Don'f forget to add comments to your code to explain what you are doing!</p> Coder's Tip [side-note] <p>Don't forget to sleep and eat! (well, this is important too!)</p> <p>where important/optional information is given. Also, the Tasks will also be marked as admonitions like the one below:</p> <p>Taks 1 - Read me</p> <p>Read this <code>readme.md</code> file.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Original materials provided by \u00c9amonn Murray (https://gitlab.com/eamonnmurray/MaterialsModelling)</li> <li>Contributors: Sim\u00e3o Jo\u00e3o, Christopher Cheung, Jordan Edwards, Chengcheng Xiao, Indrajit Maity, Valerio Vitale, Laura Ratcliff and\u00a0Johannes\u00a0Lischner.</li> <li>Webpage refreshed by Chengcheng Xiao, 2024.</li> </ul>"},{"location":"labs/extras/labs/charged_system/readme/","title":"Charged system and excited states","text":"<p>Reminder Don't forget to copy the <code>lab09</code> folder from <code>/opt/Courses/MSE404/lab09</code> to your home directory.</p> <p>In this lab we're going to see how properties of charged systems can be obtained with DFT, and how to improve the description of excited states (remember DFT is formally a theory that allows us to compute ground state and excited states properties by knowing the ground state density only!).</p>"},{"location":"labs/extras/labs/charged_system/readme/#ionization-potential-and-electron-affinity","title":"Ionization potential and electron affinity","text":"<p>As a first step, we will look at how to compute ionization energies and electron affinities in molecules, specifically carbon monoxide (CO). To do this, we will employ the \\(\\Delta\\)SCF method, i.e. we will perform SCF calculations for the neutral molecule (with \\(N\\) electrons) and the charged molecule (\\(N\\pm 1\\) electrons) at the geometry of the neutral molecule and compute the difference in the total energies (\\(E_{N} \\pm E_{N+1}\\)). In doing so, we are neglecting the effect of geometry relaxation in the charged system, and therfore the difference in nuclear-nuclear repulsion energies, that would be different in two different geometries. However, photoemission is a fast process and therefore the neglect of relaxations in the charged state is often justified when comparing to  experiments.</p> <p>Due to the long-range nature of the Coulomb interaction, electrostatic sums on an infinite lattice, or equivalently,  in a system subject to periodic boundary conditions (PBC), are not always absolutely convergent and in fact  the sum is divergent if the system is charged, which makes the above-mentioned energy differences ill-defined.  When using PBC, one can simulate an isolated molecule using a supercell with enough vacuum space. However, the energy calculated for a finite  supercell differs from that of an infinite supercell, because of the spurious interactions  of the charged system and its periodic images (as we have seen already this is also true for  neutral system with no permanent dipole, but in this case the electrostatic sum is absolutely  convergent and one can get away with a relatively small supercell size).</p> <p>In DFT code with PBC, charged systems are usually addressed by introducing a compensating  uniform jellium background, such that the total charge of the supercell is zero. This is of course an approximation  and it's only justified in the \\(L\\rightarrow\\infty\\) limit, where \\(L\\) is the linear dimension  of the supercell. Hence, one way to study charged systems within DFT is to compute the total  energy for increasing values of the supercell size and extrapolating from these the  value at \\(L\\rightarrow\\infty\\). </p> <p>More refined methods have been developed to treat charged systems within PBC and small supercells, such as the Makov-Payne method and Martyna-Tuckerman method,  which we will also use in this lab. The Makov-Payne method applies a cell size-dependent correction to the total energy based on an asymptotic analysis of the total energy of charged system with respect to the supercell size. This allows to get a faster convergence with respect to the supercell size. The Martyna-Tuckerman method, on the other hand, introduces a cut-off in real space beyond which interactions are set to zero. As a rule of thumb, the supercell  should be more than twice as large as the size of the molecule for this to be a good approximation.</p> <p>In Quantum ESPRESSO you can enable the calculation of charged systems by setting <code>tot_charge = +1</code>, if one electron is removed, or <code>tot_charge = -1</code>, if one electron is added, and so on, in the <code>SYSTEM</code> section of the input file. When having an odd number of electrons (e.g. an unpaired electron) we also need to perform a spin-polarised calculation, since we now have a different number of electrons in the two spin-channels. This can be done by setting <code>nspin=2</code>. Finally, we need to specify the occupation of the Kohn-Sham states. In molecules, with non-dengerate HOMO-LUMO, we want that each KS state is either fully occupied or empty. This can be achieved by setting <code>occupations=fixed</code>.</p> <p>The molecular orbitals diagram for the CO molecule can be found at this website </p>"},{"location":"labs/extras/labs/charged_system/readme/#task","title":"Task","text":"<p>Compute the ionization energy of carbon monoxide. You can find input files and annotated scripts in the <code>01_carbon_monoxide</code> folder.</p> <ul> <li>Inspect the <code>CO_neutral.in</code> (neutral) and <code>CO_charged_p1.in</code> (positively charged, one electron removed) template files</li> <li>Use the <code>run_cell.sh</code> bash script to run SCF calculations for increasingly large cell sizes.    The script generates a text file <code>&lt;template_name&gt;_etot_v_box.dat</code> with two columns: first column is the linear    dimension of the cubic cell in angstroms and second column is total energy in Rydberg.</li> <li>The script can be used both for the neutral and the charged system. You will have to modify the <code>template</code>    variable in the script accordingly. Run the script for both neutral and charged system.</li> <li>Check it is converged for all cell sizes. </li> <li>After running the script for the neutral and charged molecule, create a text file with two columns, with first    column being the linear dimension of the cell in angstroms and second column being the difference    between total energies of charged and neutral molecule in Rydberg.</li> <li>Use the <code>deltaE_v_box.gnu</code> gnuplot file to do a linear fit (\\(f(x) = a + bx\\)) of \\(E_{N-1}-E_{N}\\) vs \\(1/L\\). Modify the    script such that it reads the file you have generated in the previous point. In the script you will have to substitute   <code>FILENAME</code> with the name of your file.   Run the script by typing <code>gnuplot deltaE_v_box.gnu</code>.    This should generate a plot with and  you should get the resulting \\(a\\) and \\(b\\) parameters as well as the standard    error from the fitting displayed in the terminal <pre><code>Final set of parameters            Asymptotic Standard Error\n=======================            ==========================\na               = 14.19            +/- 0.01085      (0.07643%)\nb               = -22.8611         +/- 0.1496       (0.6543%)\n\ncorrelation matrix of the fit parameters:\n                a      b      \na               1.000 \nb              -0.972  1.000\n</code></pre></li> <li>Extract the value for \\(L\\rightarrow\\infty\\), i.e. \\(1/L=0\\). The experimental value is \\(14.01\\) eV. How does it compare with   the DFT result?</li> </ul>"},{"location":"labs/extras/labs/charged_system/readme/#task_1","title":"Task","text":"<p>Compute the electron affinity of carbon monoxide.  - Re-do the same steps of previous task replacing <code>CO_charged_p1.in</code> with <code>CO_charged_m1.in</code>.  - For the calculation of the electron affinity we have changed the occupations from <code>fixed</code> to <code>smearing</code>.  From the diagram of molecular orbitals of CO, can you explain why? - The experimental value is \\(1.326\\) eV. How does this compare with the DFT result?</p>"},{"location":"labs/extras/labs/charged_system/readme/#task_2","title":"Task","text":"<p>Compute the electron affinity and ionization energy using the Makov-Payne method and Martyna-Tuckerman method to treat  the charged system at a relatively small cell size. In <code>02_carbon_monoxide</code> folder copy the input files of the  charged systems and set the supercell size to 16 Angstroms. The cartesian coordinates for the C and O atoms are <pre><code> C  8.000 8.000 7.436\n O  8.000 8.000 8.564\n</code></pre> To use these methods, we need to add <code>assume_isolated='mp'</code> for Makov-Payne and <code>assume_isolated='mt'</code> for Martyna-Tuckerman in the <code>SYSTEM</code> section.</p> <p>Run <code>pw.x</code> with these input files and compare the ionization energy and electron affinity with that of  an infinite supercell from the extrapolation. </p>"},{"location":"labs/extras/labs/charged_system/readme/#excited-states-and-band-gap-problem-titanium-dioxide-rutile","title":"Excited states and band-gap problem - Titanium dioxide (Rutile)","text":"<p>It is well known that in insulators and semiconductors the fundamental band gap is underestimated by DFT with local (LDA) and semilocal (GGA) exchange-correlation (XC) functionals. This can be related to local and semilocal XC functionals being unable to remove spurious self-interactions arising from the Hartree term. For instance, if  we consider a simple one-electron system like the hydrogen atom, one can easily see that the Hartree energy \\(E_{H}[n] = \\frac{1}{2} \\int \\frac{n(\\mathbf{r})n(\\mathbf{r}')}{|\\mathbf{r}-\\mathbf{r'}|} d^3r d^3r'\\) implies an unphysical self-interaction of the electron with itself. This contribution should be compensated by the XC term, but an exact cancellation is not possible with local and semilocal functionals. This means that a percentage of this spurious contribution remains and pushes up the energies of the occupied states. At the same time, unoccupied states do not contribute to the total density and therefore no self-interaction term arises from them. As a net result, the gap between occupied and unoccupied states is reduced.</p> <p>To ameliorate this problem several so-called hybrid XC functionals have been proposed. These are non-local XC functionals based on the electron density and Kohn-Sham orbitals as well, i.e. \\(E_{XC}^{hyb} [n(\\mathbf{r}),{\\phi_{KS}(\\mathbf{r})}]\\). The main idea, is to add to the (semi)local XC functionals a percentage of the exact exchange term, which is a functional of the KS orbitals. In fact, from Hartree-Fock  theory it is well known that there is a perfect cancellation between the Hartree and the Exchange terms for the self-interaction.</p> <p>In this part we are going to compute the band structure of titanium dioxide (rutile phase) with a semilocal XC functional (PBE) and  we will see how using the <code>B3LYP</code> hybrid XC functional improves the band gap compared to the experimental value. You are not going to explicitely run a DFT calculation with a hybrid functional as this is quite computationally demanding, particularly with a plane-wave basis set (can you think of why?)</p> <p>The B3LYP energy functional is a very popular hybrid functional and it is obtained by: \\(E_{XC}^{B3LYP} = (1-a)E_{X}^{LSDA} + a E_{X}^{HF} + b \\Delta E_{X}^{B88} + (1-c)E_{C}^{LSDA} + c E_{C}^{LYP}\\), where the subscrpits \\(X\\) and \\(C\\) mean exchange and correlation, respectively. The superscripts, on the other hand, identify the different functional forms, for instance \\(HF\\) means Hartree-Fock, \\(LSDA\\) means local spin-density approximation, \\(B88\\) Becke88 functional and \\(LYP\\) the Lee-Young-Parr functional. The three parameters in B3LYP have the following values \\(a=0.2\\), \\(b=0.72\\) and \\(c=0.81\\). Finally \\(\\Delta E\\) means a gradient correction to the functional. You can see that in B3LYP one introduces a fraction (0.2) of the Hartree-Fock exchange, which is a non-local functional.</p> <p>The rutile phase of TiO2 is a direct wide-gap semiconductor, with an experimental bandgap of \\(3.3\\) eV. The unit cell is tetragonal with  <code>a=4.58</code> Ang and <code>c=2.95</code> Ang and contains six atoms, two Ti atoms and four O atoms. You can visualise the structure using <code>xcrysden</code> as usual.</p>"},{"location":"labs/extras/labs/charged_system/readme/#task_3","title":"Task","text":"<ul> <li>Let's first calculate the rutile band structure with a semilocal XC functional (PBE). In <code>03_rutile</code> folder you will find an input file <code>01_rutile_scf.in</code> for a SCF calculation and two pseudopotential files <code>Ti.pbe-sp-van_ak.UPF</code> and <code>O.pbe-van_ak.UPF</code>. Copy these two files into your <code>pseudo</code> folder and run <code>pw.x</code> to obtain the ground state density.</li> <li>Next, let's compute the band structure on a high-symmetry path by running a non-scf calculation. You will have to use the <code>01_rutile_nscf.in</code> input file.</li> <li>Finally, let's plot the bands with <code>bands.x</code> as you have done in Lab 4. You will have to use <code>01_rutile_bands.in</code> and plot the result with <code>gnuplot</code>. At which high-symmetry point is the direct band gap found?</li> <li>Go back to the output of the non-scf calculation and compute the band gap from the lowest unoccupied state and highest occupied states at \\(\\Gamma\\). You should get a band gap of \\(1.9\\) eV, which is \\(~1/3\\) smaller than the experimental value.</li> <li>Now look at the output file <code>02_rutile_scf.in</code>, which has been obtained with the B3LYP XC functional. At the end of the file you can check the  difference between the lowest unoccupied state and the highest occupied state. This calculation is not fully converged but you can see that the band gap is now much closer to the experimental value.</li> </ul>"},{"location":"labs/extras/labs/charged_system/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we've looked at how to treat charged molecules with DFT and periodic   boundary conditions. We have also looked at how ionization energies and electron   affinities can be computed with \\(\\Delta\\)SCF.</li> <li>We've also looked at how more refined methods can help with the convergence   of the total energy with respect to the cell size for charged molecules, e.g.   the Makov-Payne method and Martyna-Tuckerman method.</li> <li>In the second part we have looked at hybrid exchange-correlation functionals and   how these can improve the description of excited states and ameliorate the    band-bap problem in insulators and semiconductors.</li> </ul>"},{"location":"labs/extras/labs/high_symmetry_points/readme/","title":"Extra: High Symmetry Points","text":"<p>High symmetry points</p> <p>If you have a particular structure and you want to find out which are the important k-points, then this website is a useful tool.</p> <p>Finding appropriate high symmetry points and their labels for a band structure plot is beyond the scope of this course, but generally you need to find the Brillouin zone for the system you're interested in, along with the names of the high symmetry points, and how these should be represented in terms of your reciprocal lattice vectors.</p> <p>These can often be looked up in a table for a given structure, while keeping in mind that even for the same structure you may come across papers where some zone boundary high symmetry points will be labelled differently. You can access these tables online at e.g. the Library of Crystallographic Prototypes by typing the name of the mineral into the search box. This will give you the space group number, which you could then use with e.g. the Bilbao Crystallographic Server to find the reciprocal space coordinates of the high symmetry points and their labels. Another good reference is TU Graz which has nice interactive visualizations of the most common types along with their labels.</p> <p>For the diamond lattice example, we might do this as follows:</p> <ul> <li>The diamond lattice is FCC. We can find find the space group number from   http://aflow.org/CrystalDatabase/A_cF8_227_a.html and see that it is   number 227.</li> <li>We can enter this number at http://www.cryst.ehu.es/cryst/get_kvec.html   and find several high symmetry points. Often, you'll want to pick the same   path that was chosen in some previous work to ensure you can reproduce it   correctly. In   <code>02_C_diamond_nscf.in</code>   we have set up an input file for the path <code>\u0393-K-X-\u0393'-L-X-W-L</code> where <code>\u0393'</code>   indicates the gamma point in a different Brillouin zone. Note - these   labels don't exactly match points given in the table. Many points have   a number of equivalent positions on the Brillouin zone surface, and often   different conventions can be used for different materials with the same   structure.</li> </ul>"},{"location":"labs/extras/labs/hydrogen_atom/readme/","title":"Additional Material: The Hydrogen Atom and Electron Spin","text":"<p>As an example of a system where spin is important, let's look again at hydrogen. In the molecule we have two hydrogen atoms bonded together, and two electrons in total, and we can do this with a standard calculation.</p> <p>But if we instead want to find the energy of an isolated H atom accurately it's a little more tricky. A hydrogen atom has one electron, which means if we treat it with doubly-degenerate bands, we would have a single half occupied band. To calculate it like this we can treat it as a metal, and use some small smearing, so that we allow partial occupation of bands. This is equivalent to assuming that we have half an electron in each spin state. If we however restrict it to being in one spin state or another, we may find a slightly different energy (coming primarily from differences in how the DFT exchange term is calculated in each case, with the latter being more physical).</p> <p>The directory <code>01_H1_metal</code> has an input file for a single H atom using a small smearing, while the directory <code>01_H1_spin</code> has the same calculation, but with no smearing, and we have used the input variables <code>nspin</code> and <code>tot_magnetization</code> to enable a spin polarized calculation.</p> <ul> <li>Run the input files in these two folders.</li> <li>Compare the total energy obtained in each case. In which case is the   energy lower?</li> <li>Compare the energies of the lowest energy calculated bands.<ul> <li>Enabling smearing for the \"metal\" calculation will automatically add   extra bands, but only the lowest energy band will be occupied in this   calculation.</li> <li>In the spin polarized calculation if you check the output you will see   two sections for the band energies. One listing the energies of the   \"spin up\" bands, and the other listing \"spin down\" bands. Since we   have said we want 1 spin up electron in the calculation, the spin up   band will be occupied and should be lower in energy than the   unoccupied spin down band.</li> </ul> </li> <li>Slightly above the band energies in the output of the spin polarized   calculation, you'll see that quantum espresso also outputs the magnetic   moment associated with each atom in the system. And slightly below the final   total energy output, it will list the total magnetization of the system in   Bohr magnetons per cell. The  measured value for hydrogen is 1. How close   are you here?</li> </ul>"},{"location":"labs/extras/labs/tddft/readme/","title":"Additional Material: Optical Properties and Time-Dependent Density Functional Theory","text":"<p>Among the most useful class of properties to be able to predict for a molecule or crystal are its optical properties. These can be used to find the frequencies of optical radiation that will be absorbed or emitted, based on its electronic structure. This can be used to find, for example, what colour a dye molecule will have in a solvent.</p> <p>There are several ways these properties could be calculated starting from density functional theory. The method we'll look at in this lab is time-dependent density functional theory (TDDFT). A TDDFT code could be used to calculate the evolution of the electrons under the effect of the oscillating electric field associated with the presence of a photon. This would be a fairly intensive calculation, and would need to be repeated at many different energies to build up the full optical spectrum.</p> <p>The set of codes that comes with the quantum espresso package, turboTDDFT, actually use time-dependent density functional perturbation theory (TDDFPT) to calculate optical spectra of molecules. This calculates the response of the system to the oscillating electric field associated with an incoming photon using perturbation theory (polarizability), in a similar way to how DFPT finds the response of the system to perturbations of the atomic positions. It then uses this to find the susceptibility as a function of photon energy. The code also uses an approach known as the Liouville-Lanczos method which allows it to calculate the full optical spectrum for a wide energy range, at a very moderate cost.</p> <p>Typically if you want to understand what energy of photon will be absorbed, you might expect you would need to know the difference between the energy of the occupied and empty states: when a photon is absorbed it excites an electron from an occupied state to an empty state higher in energy by an amount equal to the photon energy. The turboTDDFT codes use a clever approach to avoid the need for including a large number of additional empty states in the calculation. This involves instead using the projection operator on to the occupied states. Details of this are given in a paper outlining the methods used in the turboTDDFT code. This is distributed with the quantum espresso package. You can find it on the mt-student server in <code>/opt/share/quantum-espresso/doc-6.3/turboTDDFT-CPC.pdf</code>. There are also slides on the quantum espresso website outlining the approach and making a comparison to the more basic TDDFT method at https://www.quantum-espresso.org/resources/tutorials/shanghai-2013/TDDFT_Talk_Gebauer.handouts.pdf</p> <p>Despite the various advantages offered by the approaches used in this code, this will still be the most intensive calculation you'll have done so far. However it is much faster than would be the case if we needed to manually look at many photon energies and including many empty states in our DFT calculation.</p> <p>You should also keep in mind that this approach is for fixed nuclear positions and does not include the effect of interatomic vibrations which may also couple to an incoming photon, either directly if the energy range is similar, or indirectly if, for example, a photon creates an excited electron and vibration simultaneously. Generally by looking in a particular energy range, the dominant effects will be from one mechanism or another. For example, the homo-lumo gap in methane is around 10 eV in LDA-DFT, while the highest energy atomic vibrations are around 0.4 eV. This means that if we're looking at the effect of photons in the 10-50 eV range (vacuum UV to extreme UV), the effect of the atomic vibrations will be minor. But we don't immediately have the spectrum across all energy ranges.</p> <p>As with some of the other more advanced calculations we looked at, we'll be doing this calculation in several stages:</p> <ol> <li>A self consistent calculation of the molecule is performed. We can do this    in the same way as previously. No special inputs are needed.</li> <li>We'll use the <code>turbo_lanczos.x</code> code which does the TDDFPT calculation    using the aforementioned Liouville-Lanczos method. This is the first, and    more computationally intensive step in calculating the polarizability. It    calculates the components of a tridiagonal matrix that will be used in a    subsequent code, for each optical polarization direction.</li> <li>We'll use the <code>turbo_spectrum.x</code> code to take the tridiagonal matrix    generated in the previous step, generate the polarizability and from it    find both the susceptibility tensor and the oscillator strength as a    function of photon energy.<ul> <li>The susceptibility tensor relates the electric field to the induced    electric polarization</li> <li>the oscillator strength gives the probability of absorption or emission    of photons.</li> </ul> </li> </ol>"},{"location":"labs/extras/labs/tddft/readme/#optical-spectrum-of-methane","title":"Optical Spectrum of Methane","text":"<p>The directory <code>CH4</code> contains a set of example inputs to perform this calculation for a methane molecule.</p> <ul> <li>Start by examining the <code>pw.x</code> input file   <code>01_CH4_scf.in</code>. You'll see that we have set this up as   usual. We have specified both the <code>prefix = CH4</code> and <code>outdir = './out'</code> as   this calculation generates many intermediate files, so it will be easier to   keep them all together. We have also set the positions such that the C atom   is at the centre of the cell. This will make some subsequent visualization a   little easier.</li> <li>Run <code>pw.x</code> with this input file and examine the output to ensure it worked   as expected.</li> <li>Next take a look at the <code>turbo_lanczos.x</code> input file   <code>02_CH4_tl.in</code>. This is fairly short. As usual, we have   accepted the default values for most of the input parameters. You can see   the full list of inputs in the <code>INPUT_LANCZOS.txt</code> file in the quantum   espresso documentation directory. We have specified two sections in the   input file:<ul> <li><code>LR_INPUT</code> where we set the <code>prefix</code> and <code>outdir</code> to match the scf   calculation, and</li> <li><code>LR_CONTROL</code> where we set<ul> <li><code>itermax = 400</code> which tells it how many elements of the Lanczos   chain to calculate (elements of the tridiagonal matrix). While in   principle more elements will give us a more accurate result, the   subsequent code can extrapolate these to a very high number. Usually   on the order of 500 to 1000 is sufficient to calculate explicitly,   though we'll look at how this converges later. It is connected to   how well the spectral features can be resolved in your calculation.</li> <li><code>ipol = 4</code> which tells it to calculate the response in all 3   directions: x, y and z.</li> </ul> </li> </ul> </li> <li>Run <code>turbo_lanczos.x</code> with this input file. It will likely take somewhere   around five minutes on the mt-student server. If you follow the output as it   is generated, you will see it calculating each of the 400 requested   iterations in turn for each of the three polarization directions.</li> <li>Finally take a look at the <code>turbo_spectrum.x</code> input file   <code>03_CH4_ts.in</code>. We need to set a few more things here.   As before, you can see a full description of all the input parameters that   can be used with this code in <code>INPUT_SPECTRUM.txt</code> in the quantum espresso   documentation directory. It has a single section: <code>LR_INPUT</code>. Again we set   the prefix and outdir to match the previous calculations. Then we have:<ul> <li><code>itermax0</code> which needs to match the number of iterations calculated   explicitly by <code>turbo_lanczos.x</code>.</li> <li><code>itermax</code> which says how many iterations in total to calculate. Those   not explicitly calculated are generated using an extrapolation scheme.</li> <li><code>extrapolation</code> sets the approach used in the extrapolation.</li> <li><code>espil</code> sets a broadening to use (in Ry). Very small wiggles will appear   in the output spectrum if this is too small, and if it is too large it   may obscure important features.</li> <li><code>units</code> sets the output units. We use <code>1</code> here we means the output   energies are in eV (rather than Ry by default).</li> <li><code>start</code>, <code>end</code> and <code>increment</code> specify the range of energies to output   and the spacing between them (in the units specified by the <code>units</code>   input).</li> <li><code>ipol</code> specifies the polarization direction. We set this to <code>4</code> again   for all three cartesian directions.</li> </ul> </li> <li>Run <code>turbo_spectrum.x</code> with this input file. This is quite a quick   calculation, and should finish in 10 to 20 seconds. The output file mainly   contains the stages of the calculation.</li> <li>The main output is instead in the file <code>CH4.plot_chi.dat</code> which will be   generated. This lists each energy value and its corresponding susceptibility   tensor and oscillator strength.</li> </ul> <p>Take a look at the file <code>CH4.plot_chi.dat</code> now. You'll see the file is not really amenable for plotting.</p> <ul> <li>First we can extract the oscillator strength with the following awk command:</li> </ul> <p><pre><code>awk '/S\\(E\\)=/{print $2, $3}' CH4.plot_chi.dat &gt; ostrength.dat\n</code></pre> This will print the second and third character on every line containing the text <code>S(E)=</code> (we need to use a <code>\\</code> to escape the parentheses). This extracts the oscillator strength as a function of energy (in eV since we set <code>units = 1</code> in the <code>turbo_spectrum.x</code> input file).</p> <ul> <li>Plot the file containing the oscillator strength as a function of energy in   gnuplot so you can see where the peaks in absorption are.</li> </ul> <p>It's also interesting to look at the susceptibility. As the system is isotropic, the polarizability, and hence susceptibility in each of the three Cartesian directions is the same. This means looking at the <code>_11</code> component alone is sufficient. This is a complex number, and we should look at both the real and imaginary parts.</p> <ul> <li>Parse the energy, the real and the imaginary part of the susceptibility   (from the 11 component of chi in the <code>plot_chi.dat</code> file) and plot both the   real and imaginary parts together in gnuplot.<ul> <li>If you parse this to a file with three columns: x, y1, y2, you can plot   them together in gnuplot as   <code>plot \"file\" with lines, \"file\" using 1:3 with lines</code>.</li> <li>You can plot several plots together by separating them with commas, and   you can use the keyword <code>using</code> to specify the columns to plot (it is   <code>1:2</code> by default).</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/tddft/readme/#charge-density-response","title":"Charge Density Response","text":"<p>It can also be interesting to examine how the charge density actually varies in response to a photon at a given energy (and hence frequency) and polarization. In particular it's useful to look at the response to photons at the energy where the highest peak in the oscillator strength is.</p> <p>This can be done using an additional flag and input section in a <code>turbo_lanczos.x</code> calculation, following a previous <code>turbo_lanczos.x</code> calculation for all polarization directions.</p> <p>Take a look at the input file <code>04_CH4_tl.in</code>. In this file we have set the <code>LR_CONTROL</code> section inputs:</p> <ul> <li><code>itermax = 400</code> which matches what we had previously.</li> <li><code>charge_response = 1</code> which turns on the calculation of the charge response.</li> <li><code>ipol = 1</code> which set the polarization of the calculated charge response to   be along the x-direction.</li> </ul> <p>Then we have added an addition section <code>LR_POST</code>, which is needed whenever <code>charge_response</code> is set to 1. Here we have set the following:</p> <ul> <li><code>omeg = 1.08</code> which set's the energy of the photon for which we want to   calculate the response. This is in Ry, and corresponds to 14.7 eV which is   roughly where the peak of the oscillator strength is for this level of   (under)convergence.</li> <li><code>epsil = 0.02</code> this is an energy broadening to use when calculating the   response (in Ry).</li> <li><code>w_T_npol = 3</code> which says that we calculated the response to all three   polarization directions in our previous calculation.</li> <li><code>plot_type = 3</code> which selects the output file to be in the gaussian cube   format. This can be opened with xcrysden.<ul> <li>Note: it seems there may a bug with this output for the version compiled   on the mt-student server such that for particular choices of energy   cut-off, box-size and output format, the output file is cut off before   the end and can't be plot. For the values chosen here, it should work   hopefully work correctly.</li> </ul> </li> </ul> <p>Run <code>turbo_lanczos.x</code> with this input file. It'll take a couple of minutes to finish. Once completed you'll see either a pair of files named <code>CH4-absorbtive-pol1.cube</code> and <code>CH4-dispersive-pol1.cube</code> have been created, or a single file named <code>CH4-summed-rho-pol1.cube</code>. The former are generated where the code determines the energy <code>omeg</code> (including the broadening <code>epsil</code>) you are calculating at corresponds to a resonance where there is a peak in the spectrum, and the latter is output otherwise. In our case we should be within the broadening of a resonance peak and so two files should be output.</p> <p>Open <code>xcrysden</code>, which we used to look at crystal and molecular structures in the extra section at the end of lab 2, (don't forget to load the module). Use this to open one of the generated files by navigating through File -&gt; Open Structure -&gt; Gaussian98 Cube File, and selecting the file. You can look at the regions where the charge density is increased and decreased in response to the oscillating electric field of the photon by going to Tools -&gt; Data Grid, click OK. Then select an appropriate Isovalue in the menu that appears, tick the <code>Render +/- isovalue</code> box, and click <code>Submit</code>. To find a good isovalue you can repeat this process with different values within the listed maximum and minimum on the grid till you see something interesting; the menu will stay visible after you click submit.</p>"},{"location":"labs/extras/labs/tddft/readme/#convergence","title":"Convergence","text":"<p>The calculated spectrum is quite sensitive to both the box size, the plane-wave energy cut off, and the number of elements of the Lanczos chain explicitly calculated, as set by the <code>itermax</code> variable in the <code>turbo_lanczos.x</code> input file. (And subsequently used as <code>itermax0</code> in the <code>turbo_spectrum.x</code> input file). These are all somewhat somewhat underconverged in the input file given to you earlier so that the calculation would complete in a reasonable time. And are somewhat connected to each other: e.g. the spectrum may be converged at a higher value of <code>itermax</code> for a higher value of <code>ecutwfc</code> so that testing convergence can be time consuming.</p> <p>Underconverging your spectra can lead to the appearance of spurious peaks and shoulders and to changes in the locations of different peaks. So you will always need to explicitly check the convergence of your spectra with respect to these parameters.</p> <p>As it would take quite a few heavy calculations to for you to test this, the oscillator strengths for methane for various box sizes, energy cut-offs and values of <code>itermax</code> have been pre-calculated in the <code>CH4_convergence</code> directory. For the various files here, in the filename the box dimension in Angstrom is indicated by the number following <code>A</code>, the plane-wave energy cut-off in Ry is indicated by the number following <code>e</code>, and the value of itermax is indicated by the number following <code>i</code>. Try plotting and comparing combinations of these in gnuplot to see how the spectrum changes as these parameters are changed.</p> <p>Note: if you are testing the convergence with respect to <code>itermax</code>, you can generate output from <code>turbo_spectrum.x</code> where <code>itermax0</code> is any value up to the value chosen for <code>itermax</code> in the <code>turbo_lanczos.x</code> calculation. So for example, if you have calculated a spectrum with <code>itermax = 500</code> in <code>turbo_lanczos.x</code>, you can quickly generate output for say 400 by setting <code>itermax0 = 400</code> in <code>turbo_spectrum.x</code>, rather than doing a full recalculation with a lower value of <code>itermax</code> in <code>turbo_lanczos.x</code> which would be far more time consuming.</p>"},{"location":"labs/extras/labs/tddft/readme/#summary","title":"Summary","text":"<p>In this lab you have seen how to use the turboTDDFT codes for performing and analysing TDDFT from the quantum espresso package to</p> <ul> <li>calculate the optical spectrum of a molecule by<ul> <li>Performing a self-consistent DFT calculation with <code>pw.x</code>.</li> <li>using the <code>turbo_lanczos.x</code> code to perform a TDDFPT calculation as   the first step in calculating the polarizability.</li> <li>using the <code>turbo_spectrum.x</code> code to generate the polarizability and   find both the susceptibility tensor and oscillator strength as a   function of photon energy.</li> </ul> </li> <li>You have also used <code>turbo_spectrum.x</code> to calculate the charge density   response of a molecule and visualised it with <code>xcrysden</code>.</li> </ul>"},{"location":"labs/extras/labs/tddft/readme/#extra-li2","title":"Extra - Li2","text":"<p>If you want to practice this type of calculation a bit more, the directory <code>Li2</code> contains a pseudopotential for lithium. You can use this to do the following set of calculations:</p> <ul> <li>Find the optimal bond length for an Li2 molecule by relaxing the atomic   positions as shown in previous labs.</li> <li>Calculate the oscillator strength as a function of energy.</li> <li>You will likely need to play around with the values of the energy range to   use in the <code>turbo_spectrum.x</code> calculation to find the best values to   show the main peaks.</li> </ul>"},{"location":"labs/extras/labs/tetrahedron_method/readme/","title":"Additional Material: The Tetrahedron Method for Densities of States","text":"<p>You saw in lab 4 how to calculate densities of states using broadening, in this section we look at how to use the tetrahedron method.</p>"},{"location":"labs/extras/labs/tetrahedron_method/readme/#density-of-states-using-the-tetrahedron-method","title":"Density of states using the tetrahedron method","text":"<p>To use the tetrahedron method this within quantum espresso, you must use the tetrahedron occupation scheme for the DFT calculation, and then don't set any <code>degauss</code> value in the <code>dos.x</code> input file. This is outlined in the <code>INPUT_DOS.txt</code> help file.</p> <p>An example where we have modified the diamond input files from lab 4 to calculate the density of states using tetrahedron integration is given in the <code>01_diamond_tet</code> directory. </p> <p>If you run the same three steps for calculating densities of states using broadening again here, you'll once again produce a <code>pwscf.dos</code> file. If you  check the output file from the <code>dos.x</code> calculation you'll also see the note <code>Tetrahedra used</code>, whereas the previous output notes details of the broadening.</p> <p>Additionally if you look at the header of the <code>pwscf.dos</code> file you'll see a different value for the Fermi energy than we obtained in the previous calculation. This would mainly come from a small underestimation that happens in the tetrahedron method. You can also see this in the integrated DOS in comparison to the broadening case. For this reason a separate calculation of the Fermi energy may often be useful. Note, you'll get more well defined features and a smoother curve systematically as you increase the k-point sampling density. The calculation will take a lot longer; if you use e.g. a 60x60x60 grid in the nscf calculation it takes about 15 mins run in serial, and the DOS calculation takes about 20 minutes, though this may be worth it if producing an image for a paper or report. We've tried to keep run time for example calculations provided down to a couple of minutes or less.</p>"},{"location":"labs/extras/labs/tetrahedron_method/readme/#task","title":"Task","text":"<ul> <li>Plot the density of states and compare it that obtained using Gaussian   broadening in lab 4.</li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/","title":"Additional Material: Calculating Useful Properties from Total Energies","text":"<p>Once you can calculate a converged total energy for a given structure, you already know enough to calculate many useful materials properties.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#what-can-we-do-with-total-energies","title":"What can we do with total energies?","text":"<p>The DFT total energy on its own is not a very useful number, but changes and differences in the total energy with respect to some input parameter can be used to calculate many materials properties.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#predicting-volume","title":"Predicting volume","text":"<p>If we calculate the total energy of say diamond as a function of volume, the volume at which the total energy is minimized will be the theoretically predicted volume.</p> <p>Let's do this in the directory <code>01_diamond_volume</code>. We could set up a series of calculations manually, where we generate a set of input files each with a slightly different value of the input lattice length. Then we would run each of these calculations, and finally gather the total energy vs cell volume in a data file. Or, we could write a script that would do all this for us.</p> <p>We already have a template file set up as <code>C_diamond_base.in</code>. Take a look at this now. It's set up such that the value of the <code>A</code> variable will be replaced in the automatically generated input files. Note, we're using a fairly high energy cut-off here also. In principle once the calculation is set up, we will need to explicitly test the convergence of the predicted volume versus energy cut-off.</p> <p>The script will need to be slightly more complex than previously, as we'd managed to get by with just producing integer values in our scripts previously. Now we'll need to produce floating point values for <code>A</code> to get the resolution we would like. To do this, we can use the <code>bc</code> command to perform the calculation of the lattice length for a given input file.</p> <p>Also Quantum Espresso outputs the unit cell volume (in Bohr cubed) so we can read this rather than calculating it ourselves.</p> <p>This gives us the following script:</p> <pre><code>#!/bin/bash\n\ntemplate=\"C_diamond_base.in\"\nrepstr=\"xxxx\"\n\n# The \"for\" construction we've used previously only handles integers.\n# So we set an initial value for A and its delta value as variables.\na1=3.40\nda=0.02\n\nfor i in {00..10..1}\ndo\n  inp=\"C_diamond_${i}.in\"\n  # bc is a calculator that can calculate expressions in the shell. We\n  # pass it our calculation with echo and save the result as a variable.\n  a=$(echo \"$a1 + $i * $da\" | bc)\n  sed \"s/$repstr/$a/\" $template &gt; $inp\n  pw.x &lt; $inp &amp;&gt; ${inp%.*}.out\ndone\n\nawk '/unit-cell volume/{vol=$4}\n     /^!.*total/{print vol, $5}' *out &gt; etot_v_vol.dat\n</code></pre> <p>Save this script in the calculation directory and use it to obtain a file with the total energy versus volume of carbon diamond.</p> <p>Let's generate a plot of this with <code>gnuplot</code> and make sure it looks sensible. A simple <code>gnuplot</code> script <code>etot_v_vol.gpl</code> is already in the calculation directory. The contents are as follows:</p> <p><pre><code>set title \"Carbon Diamond, ecutwfc=60 Ry\"\nset xlabel \"Unit Cell Volume (Bohr^3)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_vol.png\"\nplot \"etot_v_vol.dat\"\n</code></pre> This sets a title and axes labels, sets the output type to png, and sets and output filename, then plots the data as we've seen before. All these commands could be entered directly in gnuplot, but it can be easier to save them as a script if you want to come back in the future and make minor modifications. If your run this script with <code>gnuplot etot_v_vol.gpl</code> you'll see a png file of the plot has been produced in the directory. You can quickly view this with <code>display etot_v_vol.png</code>.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task","title":"Task","text":"<ul> <li>What is the calculated volume with the lowest total energy?</li> <li>What lattice length does this correspond to?</li> <li>Modify the script to calculate 21 points from A=3.40 to A=3.60 inclusive.</li> <li>Repeat this last calculation for energy cut-offs of 40 Ry and 80 Ry. Note,   you should set a different filename for the data file each time or rename   the previous data file before running this so you can compare them all   directly..</li> <li>Plot all the data for all three energy cut-offs together in gnuplot. Note   you can plot several data files in gnuplot by separating them with a comma -   e.g. <code>plot \"data1.dat\", \"data2.dat\"</code>. Save the output as a png file.</li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/#bulk-modulus-of-diamond","title":"Bulk Modulus of diamond","text":"<p>You may have realised that we could use the results of our previous calculations to predict the bulk modulus of diamond. The bulk modulus is proportional to the second derivative of the energy with respect to volume at the equilibrium volume. Say we approximate our crystal as a harmonic solid, then we could fit a harmonic expression to it to obtain a value for the bulk modulus, K in <code>gnuplot</code>. We can do that, and plot the fit together with our data with the following <code>gnuplot</code> script.:</p> <pre><code># Define a function for a simple harmonic equation of state\nE(x) = E0 + K*(x - V0)**2/(2*V0)\n# It's better to give initial guesses for a good fit. You can make a good\n# guess at E0 and V0 from the data plot you generated earlier.\nE0=-22.782\nV0=74\n\n# The actual fit command. The parameters and errors will be output to your\n# terminal and to the file 'fit.log'.\nfit E(x) \"etot_v_vol.dat\" via E0, V0, K\n\n# Let's also produce a plot of the fit along with our data. We can use the\n# same settings as before.\nset title \"Carbon Diamond, ecutwfc=60 Ry\"\nset xlabel \"Unit Cell Volume (Bohr^3)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_vol_fit.png\"\n\n# The fit parameters are set a their optimized values at the end of the fit\n# command above, so we can simply plot E(x).\nplot \"etot_v_vol.dat\", E(x)\n</code></pre> <p>Looking at the fit parameters, we can see that we obtain a value for K and the equilibrium volume V0 directly. The value of V0 will be in whatever units were used for input volumes, so Bohr^3 in our case. The value of K will be in units of Energy/Volume. If we want to compare to the experimental value we'll need to convert to a more standard unit. 1 Ry is 2.179872325E-18 J, and 1 Bohr^3 is (5.2917721067E-11)^3 m^3. If you don't want to be copy and pasting numbers to a spreadsheet or similar, another useful way to do calculations in the terminal is using python. Type <code>python</code> to start an interactive session. Type whatever expressions you want, and type <code>ctrl+d</code> or <code>quit()</code> to exit python once you're done.</p> <pre><code>python\n&gt;&gt;&gt; K * 2.179872325E-18 / (5.2917721067E-11)**3 # Enter your K value here.\n&gt;&gt;&gt; _ * 1e-9 # Convert the last result ('_') to GPa\n</code></pre> <p>The usual measured value for the bulk modulus of diamond is around 540 GPa. How close to this are we?</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task_1","title":"Task","text":"<ul> <li>Convert the fit error to GPa also so we have an estimate of our accuracy.</li> <li>Repeat the above fit for the data produced with different energy cut-off   earlier. How do the values and errors compare?</li> <li>A more advanced expression for the equation of state in a solid is the   Birch Murnaghan Equation of   State.   See if you can fit this expression to your data. The E(V) expression could   be written in gnuplot as   <pre><code>  E(x) = E0 + 9.0/16.0*V0*K*( Kp*((V0/x)**(2.0/3.0) - 1)**3 + ((V0/x)**(2.0/3.0) - 1)**2 * (6.0 - 4.0*(V0/x)**(2.0/3.0)))\n</code></pre><ul> <li>Note the expression also depends on the parameter Kp so you'll need   to add this to the list of fit parameters in the gnuplot <code>fit</code> command.</li> <li>How does the error in the fit value of <code>K</code> change with this new fit?</li> <li>Generate a plot showing both fits for your most well converged set of   data along with the data points.</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/#h2-bond-length","title":"H2 Bond Length","text":"<p>For simple molecules we can calculate the total energy versus bond length in the same way. This calculation is set up in the directory <code>02_H2_bond</code>. Again, we're going to use a short script to modify a single value in a template input file and run a series of calculations. Take a look at the template input file first. We're not using any new inputs here. We've placed one atom at the origin, and the second will be moved along the x-axis.</p> <p>We'll make a few modifications to the script this time though so that we parse the data from the output files as they are generated and use the bond-length value from the script. Save the following to a script in the calculation directory:</p> <pre><code>#!/bin/bash\n\ntemplate=\"H2_base.in\"\nrepstr=\"xxxx\"\n\n# Again we set an initial value for the x-coordinate of on H-atom and a delta\n# value as variables.\nhx1=0.700\ndhx=0.005\n\n# Empty the file, since we'll be appending to it in the calculation loop.\n&gt; etot_v_bl.dat\n\nfor i in {00..40..1}\ndo\n  inp=\"H2_${i}.in\"\n  # We save the output filename to a variable also.\n  out=\"${inp%.*}.out\"\n\n  # Again we use bc to get the atomic position for each input.\n  hx=$(echo \"$hx1 + $i * $dhx\" | bc)\n  sed \"s/$repstr/$hx/\" $template &gt; $inp\n  pw.x &lt; $inp &amp;&gt; $out\n\n  # awk is inside the loop this time, and we are appending to the data file\n  # after each calculation completes.\n  awk -v bl=$hx '/^!.*total/{print bl, $5}' $out &gt;&gt; etot_v_bl.dat\ndone\n</code></pre> <p>Take a look at the data file. What bond length minimizes the energy?</p> <p>Plot this data in <code>gnuplot</code>. You may want to copy and modify the script we used earlier for diamond.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#h2-vibration-frequency","title":"H2 Vibration Frequency","text":"<p>As you may have realised, we can use what we already calculated here to find the H2 vibration frequency. If we assume the variation in energy with bond length is approximately quadratic (how good an assumption do you think this is?) we can fit a function to the data in <code>gnuplot</code> and find the vibrational frequency.</p> <p>We can modify the gnuplot script we used earlier to fit and plot this function with our data as follows:</p> <pre><code>E(x) = E0 + k*(x-x0)**2\nfit E(x) \"etot_v_bl.dat\" via E0, x0, k\n\nset title \"Hydrogen Molecule\"\nset xlabel \"Bond Length (Angstrom)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_bl_fit.png\"\n\nplot \"etot_v_bl.dat\", E(x)\n</code></pre> <p>Use this script to make a png plot and inspect it. How good a fit do you think we have?</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task_2","title":"Task","text":"<ul> <li>Modify the calculation script to calculate 40 values over a range of   0.1 Angstrom near the minimum. Also repeat the fit.<ul> <li>How does the fit compare to the previous one?</li> </ul> </li> <li>The fit has produced a value for an effective spring-constant k for the   H2 vibration. k is in units of Rydberg per Angstrom^2. Find the frequency   of vibration of the molecule in THz. Note, since we calculated k by fixing   one atom and moving the other, you will need to use the reduced mass of   the pair of atoms.<ul> <li>What would the frequency be for a molecule made of two deuterium atoms?</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/","title":"Additional Material: Examining the Charge Density and Wavefunction","text":"<p>In this lab we'll look at various ways of visualizing the output from your DFT calculations. To do this we'll be using several additional codes from the Quantum Espresso package.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#the-charge-density","title":"The Charge Density","text":"<p>To start with we'll try to visualise the charge density we have calculated for a methane molecule. Take a look at the directory <code>01_chargedensity/01_methane</code>. This is contains an input file for methane exactly as we've seen before. Note, we've set <code>disk_io = 'low'</code> which is the default value for an scf calculation (i.e. we could have omitted this and get the same output), as we want to keep the charge density file for analysis.</p> <ul> <li>Run <code>pw.x</code> with this input file now, and check the output to make sure it   all worked as expected. You should have both a <code>pwscf.save</code> directory   containing the charge density file and other output, and a <code>pwscf.wfc</code>   wavefunction file.</li> </ul> <p>Now we want to post-process this output into something we can visualise more easily. To do that we'll be using the <code>pp.x</code> code from the Quantum Espresso suite. This code can read the output files produced by <code>pw.x</code>, extract whatever quantity you're interested in and generate output compatible with various visualisation programs. There is a help file similar to the <code>pw.x</code> available in the Quantum Espresso documentation folder called <code>INPUT_PP.txt</code>.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#3d-visualization-with-xcrysden","title":"3D visualization with XCrySDen","text":"<p>There is a <code>pp.x</code> input file for methane called <code>CH4_pp.in</code>, that contains the following:</p> <pre><code> &amp;INPUTPP\n    filplot = 'methane_charge'\n    plot_num = 0\n /\n\n &amp;PLOT\n    filepp(1) = 'methane_charge'\n    iflag = 3\n    output_format = 5\n    fileout = 'CH4.rho.xsf'\n /\n</code></pre> <p>As you can see, the file format is quite similar to that used by <code>pw.x</code>. It contains two sections:</p> <ul> <li><code>INPUTPP</code> which has inputs controlling what data will be extracted from the   <code>pw.x</code> output.<ul> <li>If we had chosen non-default directories and names for the output files,   we would need to se them here.</li> <li><code>filplot</code> specifies a filename that will be used to save the extracted   data.</li> <li><code>plot_num</code> takes an integer option that specifies what quantity will be   extracted. 0 gives us the electronic density. There are many options   here, such as potentials and local density of states. See the help   file <code>INPUT_PP.txt</code> for details, including info on additional variables   that apply depending on this option.</li> </ul> </li> <li><code>PLOT</code> has inputs controlling how the extracted data will be output for    visualisation.</li> <li><code>filepp(1)</code> gives the name of the first file to read (it's possible to      read several files and combine them in various ways, such as to      generate charge density difference plots).</li> <li><code>iflag</code> gives the dimensionality of the output. We choose 3 here for a      3D plot.</li> <li><code>output_format</code> gives the type of format you want to have output, usually      this is determined by what application you'll be using to visualise the      data. It should also be compatible with the value of <code>iflag</code>. We've      selected 5 which will give us output compatible with <code>xcrysden</code>.</li> <li><code>fileout</code> specifies the name of the plot file. <code>xsf</code> is a default      <code>xcrysden</code> extension.</li> </ul> <p>We can run <code>pp.x</code> in the same way as <code>pw.x</code>:</p> <pre><code>pp.x &lt; CH4_pp.in &amp;&gt; CH4_pp.out\n</code></pre> <p>You'll see both a <code>methane_charge</code> and a <code>CH4.rho.xsf</code> file have been generated in the calculation directory. The charge file is in a binary format so we can't tell much about it. The <code>.xsf</code> file is in a text format so we can examine it (and modify it if we want) in a text editor. Take a look and you'll see the file simply defines the crystal lattice and basis, then has a section with the datagrid as a mesh of points.</p> <p>Launch <code>xcrysden</code> (recall you'll need to load the xcrysden module first with <code>module load xcrysden</code>), and load the file <code>CH4.rho.xsf</code>. You'll see a big cube, which has the carbon at each corner and whichever bound hydrogen falls within the cube nearby. This isn't ideal, but let's carry on for the moment. There's no sign of the charge density yet. To enable this, go to \"Tools\" -&gt; \"Data Grid\". You can click \"OK\" on the menu that appears, and then you'll see a menu that controls the data grid plot appearance. Try entering say \"0.1\" for the \"Isovalue\" and click \"Submit\". If you zoom into a carbon you'll see the cloud of charge around it. Unfortunately, since we have the carbon at the origin, this plot is a little hard to see.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task","title":"Task","text":"<ul> <li>In a new directory <code>01_methane_shift</code>, shift the molecule such that the carbon atom is at the centre of the box in the <code>pw.x</code> input file.</li> <li>Run the <code>pw.x</code> and <code>pp.x</code> calculations as before.</li> <li>Visualise the output in <code>xcrysden</code>.<ul> <li>Disable the display of the crystal cell.</li> <li>Plot the data grid at an Isovalue of 0.27. You should also enable transparency, and increase the degree of the tricubic cpline to 2 or 3.</li> <li>Under \"Modify\" reduce the Ball Factor to reduce their size.</li> </ul> </li> <li>When you're happy with how it looks, save an image by first checking the   \"File\" -&gt; \"Print Setup\" menu. It's usually worth enabling anti-aliasing   here. Then go to \"File\" -&gt; \"Print\" and save the output as a png image.</li> <li>Why is there no density around the carbon atom?</li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/#2d-visualization-with-gnuplot","title":"2D visualization with GnuPlot","text":"<p>The other way to look at this would be as a 2D contour plot, or heat map. We can get 2D output suitable for gnuplot by setting the input for <code>pp.x</code> as in <code>CH4_pp_gp.in</code>: <pre><code> &amp;INPUTPP\n /\n\n &amp;PLOT\n    filepp(1) = 'methane_charge'\n    iflag = 2\n    output_format = 7\n    fileout = 'CH4.rho.gpl'\n    e1(1) = 0.4, e1(2) = 0.0, e1(3) = 0.0\n    e2(1) = 0.0, e2(2) = 0.0, e2(3) = 0.4\n    x0(1) = -0.2, x0(2) = 0.0, x0(3) = -0.2\n    nx = 100, ny = 100\n /\n</code></pre> This input file looks a little more involved than previously.</p> <ul> <li>We've left the <code>INPUTPP</code> section blank as we can simply re-use the   <code>methane_charge</code> file we created when we were generating output for   xcrysden earlier.</li> <li>We've updated <code>iflag</code> and <code>output_format</code> to select 2D output and gnuplot   format, and changed the output filename so we'll be able to understand what   this file was for in future.</li> <li>Now since we've selected 2D output, this means we need to define some   region to plot.<ul> <li>The <code>e1</code> and <code>e2</code> variables are vectors defining a plane   in units of the lattice constant.</li> <li><code>x0</code> defines the origin of the plane, again in units of the lattice   constant,</li> <li><code>nx</code> and <code>ny</code> are how many points to output in the grid.</li> <li>We've selected an xz plane which contains the carbon and two hydrogens.   Note, we've shifted the origin slightly so that the carbon will be in   the centre of the output. You'd need to adjust this to work for the   shifted structure in the task above.</li> </ul> </li> </ul> <p>Now when we run this with <code>pp.x</code> we (hopefully) get our <code>CH4.rho.gpl</code> data file as requested. You can take a look at this file, and you'll see it's a text list of numbers with <code>x, y, f(x, y)</code>. So you could use this in any plotting program or some other software or code for analysis easily.</p> <p>To plot in gnuplot you can set labels and do a heatmap style plot with the following gnuplot commands:</p> <pre><code>set title \"CH4 Charge Density in y=0 plane\"\nset xlabel \"x Position (Bohr)\"\nset ylabel \"z Position (Bohr)\"\nset cblabel \"Charge Density\"\nplot \"CH4.rho.gpl\" with image\n</code></pre> <p>Note, the x and y coordinates are output in Bohr atomic units as we've set in the plot here.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#visualizing-the-wavefunction","title":"Visualizing the Wavefunction","text":"<p>We can also try to visualise the wavefunction we have calculated for a methane molecule. Take a look at the directory <code>02_wavefunction/01_methane</code>. This is contains an input file for methane exactly as we've seen before. Note, we've set <code>disk_io = 'low'</code> which is the default value for scf calculations (i.e. we could have omitted this and get the same output), as we want to keep the wavefunction output file for analysis.</p> <ul> <li>Run <code>pw.x</code> with this input file now, and check the output to make sure it   all worked as expected. You should have both a <code>pwscf.save</code> directory   containing the charge density file and other output, and a <code>pwscf.wfc</code>   wavefunction file.</li> </ul> <p>Now we want to post-process this output into something we can visualise more easily. To do that we'll be using the <code>pp.x</code> code from the Quantum Espresso suite. This code can read the output files produced by <code>pw.x</code>, extract whatever quantity you're interested in and generate output compatible with various visualisation programs. There is a help file similar to the <code>pw.x</code> available in the Quantum Espresso documentation folder called <code>INPUT_PP.txt</code>.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#3d-visualization-with-xcrysden_1","title":"3D visualization with XCrySDen","text":"<p>There is a <code>pp.x</code> input file for methane called <code>CH4_pp.in</code>, that contains the following:</p> <pre><code> &amp;INPUTPP\n    filplot = 'CH4_wfn'\n    plot_num = 7\n    kpoint(1) = 1\n    kband(1) = 1\n    kband(4) = 4\n /\n\n &amp;PLOT\n    iflag = 3\n    output_format = 5\n    fileout = '.xsf'\n /\n</code></pre> <p>As you can see, the file format is quite similar to that used by <code>pw.x</code>. It contains two sections:</p> <ul> <li><code>INPUTPP</code> has inputs controlling what data will be extracted from the   <code>pw.x</code> output.<ul> <li>If we had chosen non-default directories and names for the output files,   we would need to set them here.</li> <li><code>filplot</code> as before specifies a filename that will be used to save the   extracted data.</li> <li><code>plot_num</code> takes an integer option that specifies what quantity will be   extracted. 7 gives us the wavefunction. There are many options here,   such as potentials and local density of states. See the help file   <code>INPUT_PP.txt</code> for details, including info on additional variables that   apply depending on this option.</li> </ul> </li> <li><code>kpoint(1)</code> is used to set the k-point index of the wavefunction we want      to output. There is only the gamma point in our calculation, so we can      set this to 1. For periodic materials where we have a grid of k-points we      could also specify <code>kpoint(2)</code> and generate output for a range of      k-points.</li> <li><code>kband(1)</code> and <code>kband(2)</code> are the lower and upper limits of the bands      that we want to output the wavefunction for.</li> <li><code>PLOT</code> has inputs controlling how the extracted data will be output for   visualisation.</li> <li><code>iflag</code> gives the dimensionality of the output. We choose 3 here for a 3D      plot.</li> <li><code>output_format</code> gives the type of format you want to have output, usually      this is determined by what application you'll be using to visualise the      data. It should also be compatible with the value of <code>iflag</code>. We've      selected 5 which will give us output compatible with <code>xcrysden</code>.</li> <li><code>fileout</code> usually specifies the name of the plot file, however for      wavefunction output where several files are generated, the text in      <code>fileout</code> is appended to the name of each file. <code>xsf</code> is a default      <code>xcrysden</code> extension, so we can add this here.</li> </ul> <p>We can run <code>pp.x</code> in the same way as <code>pw.x</code>:</p> <pre><code>pp.x &lt; CH4_pp.in &amp;&gt; CH4_pp.out\n</code></pre> <p>You'll see many files have been generated beginning with <code>CH4_wfn</code> followed by a k-point and band index. Each has a corresponding <code>.xsf</code> file. The <code>.xsf</code> files which we'll be using for visualization are in a text format so we can examine them (and modify them if we want) in a text editor. Take a look and you'll see the files simply defines the crystal lattice and basis, then have a section with the datagrid as a mesh of points.</p> <p>Launch <code>xcrysden</code> (recall you'll need to load the xcrysden module first with <code>module load xcrysden</code>), and load the file <code>CH4_wfn_K001_B001.xsf</code>. You'll see a big cube, which has the carbon at each corner and whichever bound hydrogen falls within the cube nearby. This isn't ideal, but let's carry on for the moment. There's no sign of a wavefunction yet. To enable this, go to \"Tools\" -&gt; \"Data Grid\". (Make sure you're x2go window and your xcrysdent window are big enough to see this). You can click \"OK\" on the menu that appears, and then you'll see a menu that controls the data grid plot appearance. Try entering say \"0.02\" for the \"Isovalue\" and click \"Submit\". If you zoom into a carbon you'll see the wavefunction around it. Unfortunately, since we have the carbon at the origin, this plot is a little hard to see.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task_1","title":"Task","text":"<ul> <li>In a new directory <code>01_methane_shift</code>, shift the molecule such that the carbon atom is at the centre of the box in the <code>pw.x</code> input file.</li> <li>Run the <code>pw.x</code> and <code>pp.x</code> calculations as before.</li> <li>Visualise the output in <code>xcrysden</code> for the wavefunctions associated with   each of the four bands.<ul> <li>Disable the display of the crystal cell.</li> <li>Try plotting the data grid at different isovalues. Each wavefunction   will have a different range of values that might show interesting   features. You can also try enabling transparency, and increasing the degree of the tricubic cpline to 2 or 3.</li> <li>Under \"Modify\" try reducing the \"Ball Factor\" to reduce the visual size   of the ions.</li> </ul> </li> <li>When you're happy with how it looks, save an image by first checking the   \"File\" -&gt; \"Print Setup\" menu. (You'll need to leave the data grid menu   open). It's usually worth enabling anti-aliasing here. Then go to \"File\" -&gt;   \"Print\" and save the output as a png image.</li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/#projected-density-of-states","title":"Projected Density of States","text":"<p>Following from the electronic density of states, it can be very useful in understanding a material to visualize how the density of states can be decomposed into the various states belonging to each atom in the system. To do this we can use the <code>projwfc.x</code> tool from the Quantum Espresso package. This is used in a similar way to the <code>dos.x</code> tool, although it is not possible to use tetrahedra to integrate the DOS, so a broadening must be used.</p> <p>A set of example input files for diamond are given in the directory <code>03_projecteddos/01_diamond</code>. This set of inputs follows exactly the same progression as previously, except now for the third step we have an input file for <code>projwfc.x</code> rather than for <code>dos.x</code>. In this file we have a single <code>PROJWFC</code> section, but we have actually retained the same inputs we used previously in the DOS calculation. As usual, you can get full details of the various inputs that are available in the help file <code>INPUT_PROJWFC.txt</code>.</p> <p>Now run these three calculations as before. Again a short script has been provided which does this explicitly. Once they have completed you'll see we again have generated a <code>pwscf.dos</code> file as before. You can try to plot this if you like, and you'll see it's identical to the density of states we obtained with the equivalent <code>dos.x</code> calculation. However, we also have a number of other files that have been generated, all with names beginning with <code>pwscf.pdos_</code> by default. Try looking at <code>pwscf.pdos_tot</code> first. You'll see this is a three column file, with energy, density of states, and the total of the various decomposed projected density of states. In principle column 2 and 3 should be the same (and column 2 will reproduce the already calculated density of states), but in practice it can be difficult to assign conduction band states accurately so there may be some small disagreement there.</p> <p>The additional files will the projected density of states for each atom in the unit cell and each orbital type (s, p, d etc) present. If you look, for example at the file <code>pwscf.pdos_atm#1(C)_wfc#1(s)</code>, you'll see we have three columns: energy, a column labelled <code>ldos</code> and a column labelled <code>pdos</code>. For s-orbitals we only have one value of the magnetic quantum number ml, so there is only one pdos column, and the ldos and pdos columns are equivalent. If you look at the file <code>pwscf.pdos_atm#1(C)_wfc#2(p)</code> you'll see we now have 5 columns: energy, ldos, and 3 pdos columns. ldos gives the sum of the three pdos columns, and each pdos column is for a different value of ml (3 for a p-orbital).</p> <p>In our case, the corresponding files for each of the C atoms in the cell should be equivalent as the two atoms in the cell are equivalent. For one of the atoms, try plotting the projected density of states of the s-orbital and one of the p-orbitals (e.g. try plotting the 3rd column in each file) together. Are the states near the top of the valence band more s-like or p-like?</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task_2","title":"Task","text":"<ul> <li>Calculate and plot, in whichever way you think best shows the important   features and differences, the projected density of states for both silicon   and aluminium.</li> <li>How do these compare to each other, and the example diamond calculation?</li> </ul>"},{"location":"labs/extras/misc/gnuplot/readme/","title":"Plotting with Gnuplot","text":"<p>Gnuplot is a command-line driven open-source plotting utility, with many features such as fitting, and 3D plotting available. You can install it on ubuntu systems by typing <code>sudo apt install gnuplot</code>. The homepage is gnuplot.sourceforge.net, and a detailed manual for the latest release is also available. Gnuplot is also readily scriptable. This allows you, for example, to incorporate it into a bash script to automatically produce a file containing a plot of your results after your calculation has finished.</p> <p>To open gnuplot, simply type <code>gnuplot</code> in a terminal. You will see some information regarding the version of gnuplot that has started, and finally a gnuplot prompt: <code>gnuplot&gt;</code>. You can enter various commands here to generate and save plots.</p> <p>For example: - <code>plot sin(x)</code>     - This will plot the sin function. The x values will range from -10 to +10       by default and the y range will be automatically chosen to be -1 to 1. - <code>plot cos(x), x + 0.1*x**2</code>     - This will plot the cosine function in addition to the function       y=x-0.1*x^2 . - <code>plot \"plot/example.dat\"</code>     - Plots the values listed in the example file <code>plot/example.dat</code>. - <code>set title \"My Results\"</code>     - This sets a title for the plot. - <code>set xrange [-1:1]</code>     - Sets the range of the x-axis in the plot. <code>yrange</code> can be set similarly. - <code>set xlabel \"Position (pm)\"</code>     - Sets the label for the x-axis in the plot. <code>ylabel</code> can be set similarly. - <code>replot</code>     - After changing the plot by e.g. adding a title, it is necessary to redraw       the output plot. The <code>replot</code> command repeats the last plot command.</p>"},{"location":"labs/extras/misc/gnuplot/readme/#outputing-to-a-file","title":"Outputing to a file","text":"<p>To output a plot to for example a pdf file, you need to set the gnuplot \"terminal\" appropriately (the terminal setting determines the type of output generated by gnuplot), set an output filename, and redraw the plot. Typically many different terminals are available which allow ouput to e.g. postscript, png, gif formats.</p> <p>For example, to save a default plot of a sin function to a pdf:</p> <ol> <li><code>set terminal pdf</code></li> <li><code>set output \"sin_plot.pdf\"</code></li> <li><code>plot sin(x)</code></li> </ol>"},{"location":"labs/extras/misc/gnuplot/readme/#fitting","title":"Fitting","text":"<p>We can also define and fit functions within gnuplot. For example, to fit a quadratic to the example data in <code>plot/example.dat</code> we can do the following (here I assume gnuplot has been started from within the <code>plot</code> directory):</p> <ul> <li><code>f(x)=a+b*x+c*x**2</code><ul> <li>This defines the function in terms of a set of parameters.</li> </ul> </li> <li><code>fit f(x) \"example.dat\" via a,b,c</code><ul> <li>This will do a least squares fit, and output the final parameter values   along with standard errors.</li> </ul> </li> <li>Note if no initial values for the parameters are specified, gnuplot will   start each at 1. You can specify initial values before running the <code>fit</code>   command as e.g. <code>a=-1;b=-1;c=0.5</code>. It is particularly important to give good   initial guesses when fitting non-polynomial functions.</li> <li><code>plot \"example.dat\", f(x)</code><ul> <li>This will generate a plot of the data points together with the fit curve.   You can also use this to try to find good initial guesses for parameters   manually when fitting more complex functions.</li> </ul> </li> <li>A summary of the fit results is automatically saved in the file <code>fit.log</code>.</li> </ul>"},{"location":"labs/extras/misc/gnuplot/readme/#scripting","title":"Scripting","text":"<p>One can create scripts as a list of gnuplot commands entered in the same way as would be done manually. Then <code>gnuplot scriptname</code> will execute the script and exit. An example script to perform a quadratic to the data in <code>example.dat</code> and generate a pdf plot of the data compared with the fit is given in <code>plot/example.gpl</code>:</p> <pre><code>f(x)=a+b*x+c*x**2\na=-1;b=-1;c=0.5;\nfit f(x) \"example.dat\" via a,b,c\nset title \"Example Gnuplot Plot\"\nset xlabel \"Position (Bohr)\"\nset ylabel \"Energy (Hartree)\"\nset term pdf\nset output \"example-gp.pdf\"\nplot \"example.dat\" with lines title \"Results\", f(x) title \"Quadratic fit\"\n</code></pre> <p>Try entering the <code>plot</code> directory and running this as <code>gnuplot example.gpl</code>. You will see information on the fit output directly to the terminal, and the files <code>fit.log</code> and <code>example-gp.pdf</code> will be generated. You can view the pdf with the <code>evince</code> document viewer application that is installed by default on ubuntu systems: <code>evince example.pdf</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/","title":"More Useful Linux Commands","text":"<p>While we cover the basic file and navigation commands in Lab 1, There are many more commands that are available as standard on a Linux system that can make your life much easier. In this file we briefly go through some of the more commonly used ones and list a few useful options or potential use cases for each. We'll revisit many of these during the course as they'll help us automate some aspects of running and extracting data from our calculations.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#some-additional-useful-file-commands","title":"Some additional useful file commands","text":"<p>As you are all on the same system and file space is not unlimited, it is good to be aware of how much space you're using. Large calculations can often take more disk space than you might have expected, so it's important to be able to track down large files that are no longer needed if space becomes an issue. The first few commands here can help you with this, beyond using <code>ls -lh</code> to see how big files are.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#df","title":"df","text":"<p><code>df</code> is used to report file system disk space usage for all mounted partitions. This is a useful way to check how much space is free on the disks and partitions used to store files by the system. It also tells you which disks are are real local disks: these are the ones with labels like \"/dev/sda2\" under the filesystem heading, while disks mounted across the network will be labelled with the server address in this field. The \"tmpfs\" label indicates a temporary filesystem, usually this is stored in RAM while the system is running, but can be used through a directory in the file hierarchy.</p> <p>You might notice a remote server directory is mounted to <code>~/homedir</code>. This your windows home directory. You can copy files and folders there if you would like to make the available on your Imperial windows account.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options","title":"Useful Options","text":"<ul> <li><code>df -h</code> will list usage numbers in a human-readable format, i.e. instead of   10240, it would say \"10M\".</li> <li><code>df -T</code> will list the filesystem type e.g. ext3/ext4 for disks using a   typical Linux filestructure, and nfs or cifs for disks mounted remotely over   the network. It is useful to be able to identify filesystems that are   mounted over the network since these are usually slower to use than local   disks if your calculation produces many files. In these cases, if your home   directory is on a remote filesystem you should run your calculation using a   local disk and copy the results to your home directory once it is completed.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#du","title":"du","text":"<p><code>du</code> is used to estimate file space usage. Typing <code>du filename</code> will tell you how big <code>filename</code> is (usually in kB by default). <code>du dirname</code> will tell you how big all the files in directory <code>dirname</code> and its subdirectories are, with a total at the end.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_1","title":"Useful Options","text":"<ul> <li><code>du -s</code> will only print the total size used for the argument. This is   typically used to find how much space a given directory is using.</li> <li><code>du -h</code> will print sizes in human-readable format.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#quota","title":"quota","text":"<p><code>quota</code> is used to check disk usage and limits. Many shared Linux systems, such as HPC systems, and the server you are using for this course, will impose a limit on the disk space used by any individual users. The <code>quota</code> command will tell you what those limits are and how much you have used.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_2","title":"Useful Options","text":"<ul> <li><code>quota -s</code> will show limits and usage in a human-readable format, i.e.   instead of 3145180 it would say 3072M.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#head-and-tail","title":"head and tail","text":"<p><code>head</code> outputs the first few lines of a file to the terminal, while <code>tail</code> outputs the last few lines of a file to the terminal.</p> <ul> <li><code>head filename</code> outputs the first 10 lines of <code>filename</code>.</li> <li><code>head -5 filename</code> outputs the first 5 lines of <code>filename</code>.</li> <li><code>tail filename</code> outputs the last 10 lines of <code>filename</code>.</li> <li><code>tail -5 filename</code> outputs the last 5 lines of <code>filename</code>.</li> <li><code>tail -f filename</code> starts tail in \"follow\" mode, where tail will repeatedly   check for new data written to the file, and output them to the terminal.   This is useful for following the output from a running calculation for   example.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#chmod","title":"chmod","text":""},{"location":"labs/extras/misc/linuxcommands/readme/#permissions","title":"Permissions","text":"<p>If you take a look at the output of <code>ls -l</code> you'll see the first column has a mix of letters (usually d, r, w, x, and hyphens).</p> <ul> <li>The first character in this column indicates the file: <code>d</code> for directories,   and <code>-</code> for regular files.</li> <li>The following nine characters indicate the permissions. These are in sets of   three where each set indicates the permission for a set of users.<ul> <li>The first set of three characters are the permissions for the user that   owns the file (listed in the third column).</li> <li>The second set of three characters are the permissions of other members   of the group that own the file (listed in the fourth column).<ul> <li>The default on many Linux systems is to create a group of the same     name as the username, that contains only that user.</li> <li>It's also possible for users to be added to several groups     by the system administrator. This is useful on shared systems     where a certain set of users want to share access to some set of     files, but without giving access to everyone.</li> <li>You can see what groups you are in by typing <code>groups</code> in the     terminal.</li> </ul> </li> <li>The third set of three characters are the permissions for all other   users.</li> </ul> </li> <li>Within each set of three characters:<ul> <li>The first character is \"r\" if users in that set have permission to read   the file and \"-\" otherwise.</li> <li>The second character is \"w\" if users in that set have permission to write   to the file and \"-\" otherwise.</li> <li>The third character is \"x\" if users in that set have permission to   exectute to the file, i.e. run it as a program.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#chmod-command","title":"chmod command","text":"<p><code>chmod</code> can be used to change file permissions. This command can be invoked in two different ways:</p> <p>One can change the permission for a given set of users granularly: - <code>chmod u+x filename</code> grants the user who owns the file execute permission.   This is one of the main things you will be using <code>chmod</code> for as when you   create a script in a text editor it will not be executable by default. - <code>chmod g+rw filename</code> grants group members read and write permission. - <code>chmod o-r filename</code> revokes other users read permission. - <code>chmod a+x filename</code> grants all users execute permission.</p> <p>One can use a set of three numbers to set the full list of permissions at once. What each number corresponds to is listed in following table:</p> # Permission rwx 7 read, write and execute rwx 6 read and write rw- 5 read and execute r-x 4 read only r-- 3 write and execute -wx 2 write only -w- 1 execute only --x 0 none --- <ul> <li>To set the permissions of a directory so only the owner can access it in any   way you could use <code>chmod 700 directoryname</code>.</li> <li>To set a script you have created so that others can use and execute it you   could use <code>chmod 755 scriptname</code>.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#wc","title":"wc","text":"<p><code>wc filename</code> will output the newline, word and byte counts for <code>filename</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_3","title":"Useful Options","text":"<ul> <li><code>-l</code> to output the number of lines in the file.</li> <li><code>-w</code> to output the word count for the file.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#grep","title":"grep","text":"<p><code>grep</code> will print lines from a file or stdin which match a given pattern.</p> <ul> <li><code>grep searchtext filename</code> will output all lines in <code>filename</code> which contain   the text <code>searchtext</code>.</li> <li><code>history | grep less</code> will output all lines in the command history containing   <code>less</code>. This is useful for those times when you entered a complex command   some time ago that you want to repeat it.</li> </ul> <p>While <code>searchtext</code> in the first example above could be a particular word you want to find an exact match of, <code>grep</code> will also interpret this as a regular expression by default. This is somewhat similar to the wildcards you can use in the terminal, but has a slightly different syntax and allows for much more complex patterns.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#regular-expressions","title":"Regular Expressions","text":"<p>This is a very deep topic, so we'll only cover a few of the more simple examples. <code>man grep</code> has significantly more detail. The most useful symbols are probably:</p> <ul> <li><code>.</code> matches any single character.</li> <li><code>*</code> the preceding item will be matched zero or more times.</li> <li>These are quite useful when combined to form <code>.*</code>, which acts in the same way   as the terminal wildcard expression <code>*</code>.</li> <li>Note: to match the actual <code>.</code> or <code>*</code> symbols, you can escape them as <code>\\.</code> and   <code>\\*</code>.</li> </ul> <p>For example <code>grep \"doc.*\\.pdf\" dirfiles.dat</code> will output all lines containing strings that begin with <code>doc</code> and end with <code>.pdf</code>.</p> <p>Note regular expressions can also be used in <code>less</code> (and hence <code>man</code>) when searching for text with <code>/</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_4","title":"Useful Options","text":"<ul> <li><code>grep -3 searchtext filename</code> will additionally output 3 lines before and   after any lines containing <code>searchtext</code>. Any number of lines can be used   here.</li> <li><code>grep -v searchtext filename</code> will output all lines except those containing   <code>searchtext</code>.</li> <li><code>grep -r searchtext</code> will recursively search all files and folders starting   from the current directory.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#cut","title":"cut","text":"<p><code>cut</code> prints selected parts from each line a file. Mostly this is used with the <code>-f</code> option which tells it to print only certain fields, and the <code>-d</code> option which allows you to set the delimiter for fields (TAB is the default). It is often useful to pipe (<code>|</code>) the output of <code>grep</code> into <code>cut</code> to parse data from an output file.</p> <p>For example, <code>cut -d ' ' -f 1 filename</code> will print the first word (separated by spaces) on each line of <code>filename</code>, and <code>cut -d ',' -f '3-5' data.csv</code> would print the 3rd, 4th and 5th columns of a csv data file.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_5","title":"Useful Options","text":"<ul> <li><code>-s</code> tells <code>cut</code> not to output lines which do not contain delimiters. This is   useful for example if you have empty lines in the file you are parsing that   you want to suppress.</li> <li><code>--complement</code> will output the complement of the selected fields. For   example, if we had a 5 column csv data file, <code>cut -d ',' -f '2-4'   --complement</code> would output the 1st and 5th columns.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#awk","title":"awk","text":"<p><code>awk</code> is a pattern scanning and processing language. It is typically used to parse files in a similar manner to using <code>grep</code> combined with <code>cut</code>. <code>awk</code> is very powerful but we will only cover some very basic operations.</p> <ul> <li><code>awk '/regexp/{print}' filename</code> will output all lines in <code>filename</code>   containing <code>regexp</code>. As with <code>grep</code>, regular expressions can be used in   <code>regexp</code>.</li> <li><code>awk '/regexp/{print $1\" \"$3}' filename</code> will output the first and third   words in all lines containing <code>regexp</code>. Note by default <code>awk</code> uses spaces as   the field delimiter.</li> <li><code>awk 'BEGIN{i=0} /regexp/{i=i+1} END{print i}' filename</code> will output the   number of lines in <code>filename</code> containing <code>regexp</code>.</li> <li><code>awk '/searchtext/{printf \"%f %f\\n\",$2-13.0,$4*10.0}' filename</code> will output   for each line containing <code>searchtext</code>, the second field with 13.0 subtracted,   and the fourth field times 10.</li> </ul> <p>Hopefully these examples give you an idea of what is possible with <code>awk</code>. More details and examples can be found with <code>man awk</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_6","title":"Useful Options","text":"<ul> <li><code>-F</code> allows you to set the field separator. For example <code>awk -F','</code> would be   useful for parsing a csv file.</li> <li><code>-f program-file</code> tells <code>awk</code> to run the commands listed in <code>program-file</code>.   This is useful if you have a complicated script so you don't need to type it   all in directly to the terminal.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#sed","title":"sed","text":"<p><code>sed</code> stands for stream editor. It allows you to perform basic text transformations on a file (or from stdin). <code>sed</code> is very powerful and we will only cover some very simple examples.</p> <ul> <li><code>sed 's/regexp/replacement/' filename &gt; newfile</code> will replace the first match   of <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>. Here the first <code>s</code>   stands for substitute, and is probably the most useful sed command. Note that   <code>sed</code> outputs to stdout by default, so you should redirect this to a new   file to save. Do not try to redirect output to the same file you are   reading, as <code>&gt;</code> will blank the file before <code>sed</code> can read anything from it.<ul> <li><code>sed 's/^...//' filename &gt; newfile</code> will remove the first three   characters from every line of <code>filename</code>. Note <code>^</code> is used to match the   beginning of a line.</li> </ul> </li> <li><code>sed 's/regexp/replacement/g' filename &gt; newfile</code> will replace every match   of <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>.<ul> <li><code>sed 's/,/\\t/g' data.csv &gt; data.dat</code> would replace all commas with tabs   (<code>\\t</code> is a tab) in <code>data.csv</code> and save it in <code>data.dat</code>.</li> </ul> </li> <li>The <code>-i</code> flag can be used to modify a file in-place.   <code>sed -i 's/regexp/replacement/g' filename</code> will replace every match of   <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>. <code>filename</code> itself   will be modified. You can also specify a suffix here such that a backup   will be created using that suffix: e.g.   <code>sed -i.bak 's/regexp/replacement/g' filename</code> will do the replacement in-place   but first backup the original file to <code>filename.bak</code>.</li> </ul> <p>See <code>man sed</code> for more information.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#tr","title":"tr","text":"<p><code>tr</code> is used to translate or delete characters. It always reads from stdin, and outputs to stdout. This means that to use it with a file, we need to redirect the file to stdin using <code>&lt;</code>.</p> <ul> <li><code>tr 1 2 &lt; test.dat</code> would output the contents of <code>test.dat</code> with all the 1s   replaced by 2s.</li> <li><code>tr abc ABC &lt; test.txt</code> would output the contents of <code>test.txt</code> with any 'a'   replaced by 'A', 'b' by 'B' and 'c' by 'C'.</li> </ul> <p>It also accepts some special input such as</p> <ul> <li><code>[:space:]</code> to match whitespace (both single and continuous).</li> <li><code>[:punct:]</code> to match punctuation</li> <li><code>[:lower:]</code> to match lower case letters</li> <li><code>[:upper:]</code> to match upper case letters</li> </ul> <p>For example:</p> <ul> <li><code>tr [:lower:] [:upper:] &lt; test.txt &gt; test_upper.txt</code> would to create a new   version <code>test.txt</code> converted to uppercase.</li> <li><code>tr [:space:] '\\n' &lt; test.txt</code> would convert all spaces to newlines.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_7","title":"Useful options","text":"<ul> <li><code>-d</code> deletes matching characters. For example, to output a file with all   punctuation removed we could do <code>tr -d [:punct:] &lt; test.txt</code></li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#find","title":"find","text":"<p><code>find</code> is used to search for files in a directory hierarchy. Most commonly this is used with the <code>-name</code> option to search for files with a particular name. Wildcards can be used in the search. Note: the first argument to <code>find</code> should be the path to search, e.g. <code>find /etc</code> to search for files in the <code>/etc</code> directory or <code>find .</code> to search for files in the current directory.</p> <ul> <li><code>find . -name \"*.cpp\"</code> will find all files ending in <code>.cpp</code> in the current   directory (<code>.</code>) and its subdirectories.</li> </ul> <p>See <code>man find</code> for more information.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#diff","title":"diff","text":"<p><code>diff</code> is used to compare two files. This is useful if for example, you want to see what changes have been made in a new version of a file.</p> <ul> <li><code>diff file1 file2</code> will output the lines which differ between the two files.   The lines from <code>file1</code> will be prepended with <code>&lt;</code> and the lines from <code>file2</code>   with <code>&gt;</code>.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_8","title":"Useful Options","text":"<ul> <li><code>-q</code> will report only whether the two files differ and will not output the   differences.</li> <li><code>-r</code> will recursively compare files in subdirectories.</li> <li><code>-y</code> will output the two files side by side in two columns.</li> <li><code>-W</code> will allow you to set how wide the output is (130 columns by default).   This is particularly useful with the <code>-y</code> option.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#sort","title":"sort","text":"<p><code>sort</code> is used to sort lines of text files. For example, if we had a file called <code>users.txt</code> which contained a list of names, then <code>sort users.txt</code> would output (to stdout) the list sorted alphabetically. This is often useful combined with other commands. For example to generate a sorted list of all words in a file you can do <code>sed 's/ /\\n/g' filename | sort</code>. Here the <code>sed</code> command replaces all spaces with new lines, so we have one word per line, and then we use this as input to the sort command.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_9","title":"Useful Options","text":"<ul> <li><code>-n</code> will sort numerically rather than alphabetically. For example,   <code>du -s * | sort -n</code> will generate a listing of files and directories sorted   by size.</li> <li><code>-h</code> will use a human numeric sort, allowing numbers such as 2K and 1G to be   sorted. For example, <code>du -sh * | sort -h</code> will generate a listing of files   and directories sorted by size, but in human readable format.</li> <li><code>-u</code> will output only the first of an equal run. For example   <code>sed 's/ /\\n/g' filename | sort -u</code> will generate a sorted list of all words   in <code>filename</code> with each listed only once.</li> <li><code>-f</code> will till <code>sort</code> to fold lower case to upper case characters.</li> <li><code>-r</code> will output in reverse order. This is useful for numeric sorts where you   often want to have the largest numbers at the top.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#uniq","title":"uniq","text":"<p><code>uniq</code> is used to report or omit repeated lines in a file. By default it will take any file or input from stdin, and output it with duplicated lines omitted. For example if we had a text file <code>test.txt</code> with</p> <pre><code>a\na\nb\nb\nb\nc\nd\nd\n</code></pre> <p>Running <code>uniq test.txt</code> would output</p> <pre><code>a\nb\nc\nd\n</code></pre>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_10","title":"Useful Options","text":"<ul> <li><code>-c</code> prefixes each line of output with a count of its number of occurrences.   We could for example, take the <code>sort</code> example to sort all words in a file,   and expand it to generate a word count of all words in a file:   <code>sed 's/ /\\n/g' filename | sort | uniq -c</code>. We could add <code>| sort -n</code> to the   end of this to sort words in order of frequency, and we could use <code>tr</code> before   this to remove all punctuation.</li> <li><code>-i</code> tells <code>uniq</code> to ignore differences in case when comparing.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#tar","title":"tar","text":"<p><code>tar</code> is an archiving utility used to create an archive of files, i.e. generate a file containing many other files. This is usually used to create compressed bundles of files on Linux, in a similar way to zip file archives (note zip and unzip are usually available on Linux also, but compressed tar archives are more commonly used).</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#creating-archives","title":"Creating Archives","text":"<p>The <code>-c</code> flag indicates to <code>tar</code> that you want to create an new archive.</p> <ul> <li><code>tar -cvf archive.tar file1 file2 dir1</code> will create an (uncompressed) archive   called <code>archive.tar</code> of the named set of files or directories. Here:<ul> <li><code>-v</code> is for verbose mode - it will list the files which are added. This   is not really necessary, but is useful so you can be sure you are adding   the files you intended to.</li> <li><code>-f</code> is used to specify the archive name. Here we have called it   <code>archive.tar</code>.</li> </ul> </li> <li><code>tar -czvf archive.tar.gz file1 file2 dir1</code> uses the additional <code>-z</code> flag to   compress the archive using <code>gzip</code> compression. The extension <code>.tar.gz</code> or   <code>.tgz</code> is typically used to indicate this type of file. Several other   possible compression algorithms could be used instead:<ul> <li><code>-j</code> will use <code>bzip2</code> compression. This typically results in slightly   smaller file size than <code>gzip</code>, but can take slightly longer. Files   created like this usually use the extension <code>.tar.bz</code> or <code>.tbz</code> or some   other similar variation.</li> <li><code>-J</code> will use <code>xz</code> compression. This is a very effective compression   algorithm, resulting in very small files, particularly for archives   containing a lot of text. This option can take quite a lot longer than   gzip for large archives however. Files created with this option usually   use the extension <code>.tar.xz</code> or <code>.txz</code>.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#extracting-archives","title":"Extracting Archives","text":"<p>The <code>-x</code> flag indicates to <code>tar</code> you want to unpack an archive.</p> <ul> <li><code>tar -xvf archivename</code> will uncompress and unpack a tar archive called   <code>archivename</code>, automatically detecting what kind of compression was used (if   any). Again the <code>-v</code> isn't necessary, but is useful.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#listing-archive-content","title":"Listing Archive Content","text":"<p>The <code>-t</code> flag will tell <code>tar</code> to list the contents of an archive.</p> <ul> <li><code>tar -tvf archivename</code> will list the contents of the tar archive   <code>archivename</code>, again automatically detecting what kind of compression was   used.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#bc","title":"bc","text":"<p><code>bc</code> is an arbitrary precision calculator language. This can be used from the command line by piping expressions to it. For example:</p> <ul> <li><code>echo \"2+2\" | bc</code></li> <li>For floating point operations, you should set the scale which defines how   many digits following the decimal points are output:</li> <li><code>echo \"scale=10; 1.412*27.211\" | bc</code></li> <li><code>echo \"scale=10; sqrt(2)\" | bc</code></li> <li>You can tell bc to load the standard math library with the <code>-l</code> flag. This   will also set the scale to 20 by default. This makes several additional   functions available such as <code>s(x)</code>, <code>c(x)</code> and <code>a(x)</code> for the sine, cosine   and arctan in radians. So <code>echo \"4*a(1)\" | bc -l</code> will output the first 20   decimal places of pi.</li> </ul>"},{"location":"labs/extras/misc/running_in_parallel/readme/","title":"Running in Parallel","text":"<p>All modern DFT codes are capable of running in parallel, provided they have been compiled to do so. While you may be familiar with a single application using several threads when you start it so that it runs faster, the parallelisation scheme used by many DFT codes allows them to run on a large number of different machines simultaneously to complete a single DFT calculation.</p> <p>In the quantum espresso package, this is achieved through the use of MPI in which a number of copies of a program are started at the same time which can then pass information among themselves, communicating over the network or faster interfaces such as infiniband, or running several on the same machine where they each use a single core (or possible more than one, as each process could in principle use several threads also). So a calculation that takes say 10 minutes without using any parallelization, would take (slightly more than) around 5 minutes using two parallel processes.</p> <p>Throughout the course material, we make no mention of running in parallel. This is just for simplicity, since it's one less thing for you (and me) to worry about in the labs. The calculations we have you do in the labs and homework assignments are small enough that this isn't necessary, but if you're interested in doing more serious DFT calculations such as for a MSc project then you should certainly start running your calculations in parallel.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#getting-a-version-of-espresso-that-can-run-in-parallel","title":"Getting a version of espresso that can run in parallel","text":"<p>If you're on one of the mt-student servers, there is a separate module for quantum-espresso compiled with parallel features enabled called <code>espresso-mpi</code>. To load this, you'll also need to have the <code>openmpi</code> module loaded first. It is set to conflict with the <code>espresso</code> module, so it will generate an error if you try to load it while you have that loaded; if so you can first unload that with <code>module unload espresso</code>.</p> <p>To load the parallel module on an mt-student server type <code>module load gcc   mkl openmpi espresso-mpi</code></p> <p>If you have installed a VM on your laptop for this course, and have installed quantum-espresso from Ubuntu repositories (e.g. via <code>apt</code>), this version already has parallel features enabled.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#running-your-calculation-in-parallel","title":"Running your calculation in parallel","text":"<p>There are several ways to start a parallel calculation, and if you're using some HPC service, you such check their documentation for their recommended approach.</p> <p>To start a parallel calculation on mt-student or your own VM you can do the following:</p> <ul> <li>Use the <code>mpirun</code> command, which is used to start a program that has been   compiled with MPI enabled communication (if you run it on a normal program   it will simply start several copies of that program at the same time).</li> <li>To tell it how many processes you want to start, you give it the <code>-np</code> flag   followed by a number, such as <code>-np 2</code> to start two parallel processes.</li> <li>Then give it your program and input and output as usual.</li> </ul> <p>Say for example, we have an input for a silicon calculation for <code>pw.x</code> called <code>Si.in</code> and we want to save the output in <code>Si.out</code>:</p> <ul> <li>For the serial (non-parallel) calculation we would write   <code>pw.x &lt; Si.in &amp;&gt; Si.out</code></li> <li>For a parallel calculation, if we wanted to use two parallel processes,   we would write <code>mpirun -np 2 pw.x &lt; Si.in &amp;&gt; Si.out</code>.</li> </ul> <p>The majority of the codes that come with the quantum espresso package can run in parallel in this manner.</p> <p>You should be aware however, that planewave DFT calculations don't scale linearly. Your calculation will get faster to a certain point, after which if you add more parallel processes you'll slow your calculation down. This can vary depending on the system and type of calculation you're doing, but usually you'll see a reduction up to around 50 processes depending on the parallelisation scheme (see below) and system involved.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#types-of-parallelisation","title":"Types of parallelisation","text":"<p>If we do the above and write <code>mpirun -np 2 pw.x &lt; Si.in &amp;&gt; Si.out</code>, we accept the default strategy for parallelising the calculation. Different DFT codes use different defaults, which all have their own advantages and disadvantages. Using the default for quantum espresso is generally pretty good. The differences between the different schemes are discussed in detail in the quantum espresso documentation for <code>pw.x</code> but in general a planewave DFT code can be parallelised in the following ways (which can be used in combination provided this has been implemented):</p> <ul> <li>Over sets of calculations - if the calculation you have asked for involves   running several similar calculations automatically, you can break up these   calculations between your parallel processes. Quantum espresso offers this   functionality for some types of calculations (such as for phonons) and   refers to these sets as images.<ul> <li>You can set how many of these are used for a parallel calculation with   <code>-nimage</code> or <code>-ni</code>. If you run with 20 processors and specify <code>-ni 2</code>,   each image will use 10 processors. The default is 1.</li> </ul> </li> <li>Over k-points - this scheme needs very little communication between   processes and so offers very good scaling, as each k-point can be treated as   effectively a separate calculation where results are added together at the   end. It doesn't do as much as other schemes to reduce the memory   requirements of the calculation, and if your calculation doesn't use many   k-points, or you're calculating a molecule this may be a limited approach.<ul> <li>You can set how many parallel groups of k-points your calculation uses   with the <code>-npools</code> or <code>-nk</code> flags in quantum espresso. The default is   1.</li> </ul> </li> <li>Over bands - This can cut down the amount of memory used by each process but   requires a bit more communication between processes.<ul> <li>You can set how groups of bands are used for parallelising your   calculation with the <code>-nband</code> or <code>-nb</code> flags. The default is 1.</li> </ul> </li> <li>Over planewaves (FFT planes) - the plane wave basis set can be distributed   across parallel processes. Quantum espresso does this very efficiently and   this is its default parallelisation scheme. It will distribute planes of 3D   FFT points to the parallel processes.<ul> <li>This is always turned on. Whatever the number of parallel processes that   are left over after you specify other options will be used in this   manner.</li> </ul> </li> <li>Over task groups - if you have more parallel processes than FFT grid planes,   you can redistribute the FFTs into task groups that allows for more   efficient processing.<ul> <li>You can set the number of task groups with the <code>-ntg</code> or <code>-nt</code> flags.   The default is 1.</li> </ul> </li> </ul> <p>There is also an overview of the options for the various quantum espresso packages at https://www.quantum-espresso.org/Doc/user_guide/node18.html if you'd like more detail.</p>"},{"location":"labs/extras/misc/shellscripting/readme/","title":"Bash and Shell Scripting","text":""},{"location":"labs/extras/misc/shellscripting/readme/#bash-shell","title":"Bash Shell","text":"<p>There are often several different shells installed on a Linux system. <code>bash</code> is probably the most common, and is typically the default for new users on any system. <code>bash</code> is running in the terminal, and it interprets and executes the commands we type in.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#environment","title":"Environment","text":""},{"location":"labs/extras/misc/shellscripting/readme/#user-configuration","title":"User Configuration","text":"<p>On startup, such as when a new terminal is opened, or you connect to a remote system over the network, <code>bash</code> will read several configuration files depending on how it detects it is running.</p> <ul> <li>For login shells (shells where you are prompted to login when you start it),   <code>bash</code> will read configuration options in <code>~/.bash_profile</code> or <code>~/.profile</code>   if these exist. Note <code>~</code> is interpreted by the shell as the users home   directory.</li> <li>For non-login shells (such as when you open the terminal emulator) <code>bash</code>   will read configuration options in <code>~/.bashrc</code>.</li> <li>A lot of the time, for simplicity, many people will put all their   configuration options in <code>~/.bashrc</code> and leave their <code>~/.profile</code> empty   except for a command to read the <code>~/.bashrc</code> file.</li> </ul> <p>These files can be used to configure many aspects of the shell, such as how the prompt looks in the terminal.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#environment-variables","title":"Environment Variables","text":"<p>Many important aspects of how <code>bash</code> behaves are governed by environment variables. These can be modified to your preference in your configuration files. To see the current value of one of these variables you can do, e.g. <code>echo $PATH</code>. A <code>$</code> symbol is used when referring to the data stored in a variable, and <code>echo</code> is a built-in bash command that outputs something to the terminal.</p> <ul> <li><code>PATH</code>: this tells bash which directories to look in for executables so they   can be run without typing in their full path. For example, we can just type   in <code>gedit</code> in the terminal to launch the program, as the <code>PATH</code> variable   contains the directory holding an executable of this name. Different   directories are separated by \":\".<ul> <li>To add the directory <code>~/.bin</code> to your path, you can add the line   <code>export PATH=\"~/bin:$PATH\"</code> to the <code>.bashrc</code> file. Here the <code>export</code>   statement is used to allow the variable to be usable by any child   processes rather than local to the script. Note when we are naming the   variable we want to assign a value to we don't use a <code>$</code>. Also we just   want to add a directory to the existing <code>PATH</code> so we add <code>:$PATH</code> to keep   all the existing directories.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/shellscripting/readme/#scripting","title":"Scripting","text":"<p>Shell scripts allow you easily string together sets of commands in a useful way. For example, you could write a script that runs a calculation, parses the important results to another file, and then generates a plot.</p> <p>This course will only be able to briefly cover scripting. If you're interested in developing more advanced scripts, I strongly suggest referring to the Advanced Bash-Scripting Guide.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#the-basics","title":"The basics","text":"<p>A simple example script to output \"Hello World!\" is as follows:</p> <pre><code>#!/bin/bash\n# Simple example script that outputs \"Hello World!\"\n\necho \"Hello World!\"\n</code></pre> <ul> <li>The first line tells the system what command is used to interpret the   contents of the script. This line should always begin with <code>#!</code> and then the   path to the executable. For <code>bash</code> the executable will almost always be   <code>/bin/bash</code>.</li> <li>Comments being with <code>#</code>.</li> <li>Commands can be entered otherwise as you would enter them to the terminal.</li> <li>Try creating a file called <code>hello.sh</code> with the contents listed above.</li> <li>You will need to make the script executable with <code>chmod u+x hello.sh</code>.</li> <li>Then you can run it by typing <code>./hello.sh</code>.</li> </ul>"},{"location":"labs/extras/misc/shellscripting/readme/#variables","title":"Variables","text":"<p>Variables don't need to be declared in any way, you can assign a value and start using them. For example:</p> <pre><code>#!/bin/bash\n# Example using variables.\n\nvar1=\"Hello\"\nvar2=\"World!\"\n\necho $var1 $var2\n# Note the use of the $ symbol when we want to use the value stored in the\n# variable.\n\n# Any command can use these variables\ndirname=\"tmpdir\"\nmkdir $dirname\n</code></pre> <p>You can also read a value from stdin using the <code>read</code> command as follows:</p> <pre><code>#!/bin/bash\n# Example showing how the read command is used.\n\necho \"Please enter some text:\"\nread user_text\n\necho \"The text you entered was:\" $user_text\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#capitalization","title":"Capitalization","text":"<p>Note: variable names are case sensitive in bash. The usual convention used is that environment variables (such as <code>PATH</code>), and internal shell variables (such as <code>BASH_VERSION</code>) are capitalized, while other variables are in lowercase. Adopting this convention will ensure that you don't accidentally overwrite any important variables in your scripts.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#command-substitution","title":"Command Substitution","text":"<p>Command substitution allows the result of a command to replace the command itself, acting much like a variable in practice. For example:</p> <pre><code>#!/bin/bash\n# Example of command substitution.\n\n# This can be done by enclosing the command in $( )\necho \"It is now $(date).\"\n# Note: the \"date\" command outputs the current date and time.\n\n# This can also be done by enclosing the command in backtics ` `\necho \"The files in this directory are:\" `ls`\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#conditional-statements","title":"Conditional Statements","text":"<p><code>if</code> statements can be used in bash, and many types of tests are possible. You can test if the value stored in a variable equals something as follows:</p> <pre><code>#!/bin/bash\n# Example using if statatements\n\necho \"Please enter a yes or no: \"\nread user_response\n\n# Note the spaces following `[` and before `]` are important.\nif [ $user_response = yes ]\nthen\n    echo \"You entered yes.\"\nelif [ $user_response = no ]\n# \"elif\" is the same as \"else if\"\nthen\n    echo \"You entered no.\"\nelse\n    echo \"You didn't enter yes or no.\"\nfi\n# \"if\" statements are always ended with \"fi\".\n</code></pre> <p>We can also check, e.g., if a file or directory exists:</p> <p><pre><code>#!/bin/bash\n# Check if the directory \"tmpdir\" exists, and if not, create it, then check\n# if the file \"tmpdir/testfile\" exists, and if not, create it.\n\ndirname=\"tmpdir\"\nfilename=\"testfile\"\n\nif [ ! -d \"$dirname\" ]\n# The \"!\" is logical negation\n# -d tests that a file exists and is a directory.\nthen\n    mkdir $dirname\nfi\n\nif [ ! -f \"$dirname/$filename\" ]\n# -d tests that a file exists and is a regular file (i.e. not a directory).\nthen\n    touch \"$dirname/$filename\"\nfi\n</code></pre> Many other tests of this form are possible.</p> <p>Note, bash can also use the <code>[[ ... ]]</code> test construction rather than <code>[ ... ]</code>, with the former offering some more options and functioning more like other programming languages, though it won't work in many other (non-bash, or older bash version) shells.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#arithmetic-and-testing","title":"Arithmetic and Testing","text":"<p>To test numeric values, the <code>(( ... ))</code> construction can be used. For example:</p> <pre><code>#!/bin/bash\n# Example showing the use of the (( )) construction\n\nvar1=4\nvar2=5\nvar3=8\n\nif (( var1 + var2 &gt; var3 ))\n# Note within the (( )) don't use $ symbols before variables.\nthen\n    echo \"$var1 + $var2 &gt; $var3\"\nelse\n    echo \"$var1 + $var2 &lt;= $var3\"\nfi\n\n# We can also use the construction to perform basic arithmetic\nvar4=$(( var1 * var3 ))\necho \"$var1 * $var3 = $var4\"\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#for-loops","title":"For Loops","text":"<p>For loops iterate a variable over a range of values. For example: <pre><code>#!/bin/bash\n# Simple for loop example.\n\n# This construction loops over a space separated list of values. A variable\n# whose contents contains spaces would work in the same way.\nfor i in 1 2 3\ndo\n    echo \"Iteration number $i\"\ndone\n</code></pre></p> <p>A for loops can be used to apply a command repeatedly to a set of files. For example:</p> <pre><code>#!/bin/bash\n# Example showing a simple for loop over a list of arguments used to convert\n# a set of data files with comma separted columns to tab separated columns.\n\nfor csvfile in \"$(ls *.csv)\"\ndo\n    datfile=\"$(basename $csvfile .csv).dat\"\n    # basename is a tool to strip the suffix from a file. Here we use it\n    # to construct a new filename with the .dat extenstion.\n    sed 's/,/\\t/g' $csvfile &gt; $datfile\ndone\n</code></pre> <p>Bash also supports numeric loop ranges using the syntax <code>{start..finish..increment)</code>. For example</p> <pre><code>#!/bin/bash\n# Example of for loop with numeric increments\n\nfor i in {0..6..2}\ndo\n    echo \"The value of i is $i\"\ndone\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#while-loops","title":"While Loops","text":"<p>Bash also supports while loops, where a set of commands are repeated continuously while a given condition is true. For example:</p> <pre><code>#!/bin/bash\n# Example of while loop in bash\n\ncounter=0\n\n# Here -lt means less than\nwhile [ $counter -lt 10 ]\ndo\n  echo $counter\n  counter=$((counter + 1))\ndone\n</code></pre> <p>It is often convenient to use <code>while</code> loops to operate on every line of a file. For example:</p> <pre><code>#!/bin/bash\n# Example of while loop reading lines from a file\n\nlinenumber=0\n\nwhile read line\ndo\n  linenumber=$((linenumber + 1))\n  echo \"$linenumber: $line\"\n  # This will prepend each line of a file with its line number.\ndone &lt; test.txt\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#arguments","title":"Arguments","text":"<p>We can also pass arguments to bash scripts from the command line. For example:</p> <pre><code>#!/bin/bash\n# Example using command line arguments. Call this script with several\n# arguments.\n\necho \"The first argument is $1\"\necho \"The second argument is $2\"\necho \"The number of arguments is $#\"\necho \"The full list of arguments is $@\"\n</code></pre> <p>We can loop over arguments using a for loop as follows:</p> <pre><code>#!/bin/bash\n# Example using a for loop to iterate over command line arguments.\n\nfor arg in $@\ndo\n  echo $arg\ndone\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#functions","title":"Functions","text":"<p>We can also define functions in bash as we would in other languages. These allow sections of code to be reused as needed and can help make a script easier to follow.</p> <p>A simple example is as follows: <pre><code>#!/bin/bash\n# Simple example of a function in a bash script\n\n# First we define a function called \"hello\", that will output \"Hello World!\"\n# when called.\nhello() {\n  echo \"Hello World!\"\n}\n\n# To call the function, we just use its name.\n# Note function names in the script will take precedence over executable names\n# from the path in the script.\nhello\n</code></pre></p>"},{"location":"labs/extras/misc/vmsetup/readme/","title":"Setting up the necessary software in a virtual machine","text":"<p>Note</p> <p>If you are an MSE404 student you do not need to follow the instructions given here. </p> <p>These instructions are only for people who wish to run their own copy of the software on their own machine. Doing is only recommended for more advanced users or people without access to the compute server. It will mean many files will not be at the location given in the lab documents so you will need to be able to modify the instructions correctly yourself.</p> <p>A virtual machine allows you to run a complete operating system contained within an application regardless of what operating system you have. One package that allows you to do this is VMWare. VMWare is available free to Imperial College students via http://www.imperial.ac.uk/admin-services/ict/store/software/software-for-students/.</p> <p>Once you have it installed this, I suggest getting an Xubuntu iso from https://xubuntu.org/getxubuntu, and using this to create a new virtual machine. You can go with all the default settings, and pick whatever username and password you like.</p> <p>Once this is complete, it should reboot and prompt you for the password you set during install to log you in to your desktop. Then first ensure the system is fully up-to-date with</p> <p><pre><code>sudo apt-get update\nsudo apt-get upgrade\n</code></pre> You may also prefer to change the keyboard settings, since it defaults to a US layout. If you go to the settings menu and pick \"Language Support\" you can drag e.g. \"English (United Kingdom)\" to the top of the list and click the \"Apply System-Wide\" button. You may also want to go to the \"Regional Formats\" tab and select the UK option and apply system wide again. Then go to the Keyboard settings menu and the \"Layout\" tab. At the bottom, click the \"Add\" button and scroll down to UK English (there are several sub-options here that may be better if you have e.g. a Mac). You can delete the US layout once you have added the UK one.</p> <p>Then you can simply install quantum espresso from the repositories, with</p> <pre><code>sudo apt-get install quantum-espresso\n</code></pre> <p>This will install a slightly older version of quantum espresso (which still has all the features needed for these labs but may output additional files, such as the wavefunction in a slightly different place than mentioned in the lab description), and will not however create some of the directories, and help files that we use in the examples. So some of the commands given in the lab documents will not work without modification by you by default. In particular, you should skip the various <code>module</code> commands as they will not be necessary for you.</p>"},{"location":"labs/extras/misc/vmsetup/readme/#if-you-have-access-to-the-server","title":"If you have access to the server","text":"<p>One way around this, if you have access to the server, would be be to copy these directories to the same place on your virtual machine. You can do this by connecting to the college VPN and using the following commands, substituting your college username for USER in the second command (which will also prompt you for your college password):</p> <pre><code>sudo mkdir -p /opt/share\nsudo rsync -auz USER@mt-studenty.mt.ic.ac.uk:/opt/share/quantum-espresso /opt/share\nsudo mkdir /opt/Courses\nsudo rsync -auvz USER@mt-studenty.mt.ic.ac.uk:/opt/Courses/MSE404 /opt/Courses\n</code></pre> <p>Then you should have everything necessary in place. I would suggest re-running the last command at the beginning of each lab session to ensure you have the latest version of the lab documents.</p>"},{"location":"labs/extras/misc/vmsetup/readme/#if-you-do-not-have-access-to-the-server","title":"If you do not have access to the server","text":"<p>There are two directories present on the server that are referred to at various points in the lab documentation:</p> <ol> <li><code>/opt/share/quantum-espresso</code> - We have placed the various documentation    files (txt, html and pdf) that are provided with the quantum-espresso    source package in a directory here. It can be quite useful to refer to the    text files from the command line. However the same information can all be    found in the documentation    section of the    quantum espresso website. In particular the page with links to the input    data    description.</li> <li><code>/opt/Courses/MSE404</code> - this lets students copy a directory for the lab    containing the instructions and example files at the beginning of each lab    session. You could clone the git repository    https://gitlab.com/eamonnmurray/MaterialsModelling.git    whereever you like and use this instead. If you are a student taking the    course, I suggest pulling the repo at the beginning of each session as we    make changes as the course proceeds each year.</li> </ol> <p>For example, you could clone the repository to the same directory as on   the server:</p> <pre><code>sudo mkdir -p /opt/Courses\nsudo git clone https://gitlab.com/eamonnmurray/MaterialsModelling.git /opt/Courses/MSE404\n</code></pre> <p>This will create the folder <code>/opt/Courses/MSE404</code> with all the material   for all the labs. To update this ahead of a lab session you can do</p> <pre><code>cd /opt/Courses/MSE404\nsudo git pull\n</code></pre>"},{"location":"labs/lab01/readme/","title":"Getting Started in Linux","text":""},{"location":"labs/lab01/readme/#1-introduction","title":"1. Introduction","text":"<p>In this course, you will use a dedicated Linux server to run your calculations, which can be accessed remotely. In this first Lab, you will learn how to:</p> <ol> <li>access this server remotely with your college credentials</li> <li>interact with the server using the Linux command line</li> <li>set up your work environment in the terminal</li> <li>run your first DFT calculation!</li> </ol> <p>These steps closely resemble what you would need to do in a real-world scenario. When you\u2019re researching more advanced topics, you will require powerful computers to run your simulations. At Imperial, you could get access to CX1, the local High Performance Computing (HPC) facility containing hundreds of machines. On a national level, you could get access to ARCHER2, the UK national supercomputing service. All these facilities use the Linux operating system, so it is important to get comfortable with the Linux command line because in many situations this will be your only option to interact with those machines. The server you will use in this course is called <code>matmod</code> and it will be your first step into the world of material simulation.</p>"},{"location":"labs/lab01/readme/#2-accessing-the-server-remotely","title":"2. Accessing the server remotely","text":"<p>The server can be accessed by using PuTTY and XMing, which can be run from the Imperial Software Hub. XMing runs in the background in your Windows machine and enables the remote server to display graphics when needed. For the most part, however, you will have to interact with the command line. PuTTY is the program used to establish the connection to the remote server.</p> <p>Task 1 - Connecting to the remote server</p> <ol> <li>Access the Imperial Software Hub and first launch Xming, then PuTTY. </li> <li>In the PuTTY interface, inside the Connection tab, enable X11 forwarding. This will allow the server to communicate with Xming to show you graphical data when required. </li> <li>In the Session tab, under Host Name, input the name of the server that you want to access, and save this session by giving it a name under Saved Sessions and clicking Save. Whenever you want to reconnect with PuTTY, you can simply load this session again. Finally, click Open: </li> <li>If this is your first time connecting to this server, you might get a security alert asking whether you want to accept the host key. Press Accept. </li> <li>A terminal will be presented to you. In order to login, you will have to enter your College username, press Enter, enter your password and press Enter again. </li> </ol> <p>Note: while we try to ensure students registered for the course have access before the first class, we may not have the most up-to-date information. If it doesn't accept your login details please let me know and we can give you access.</p> <p>Congratulations! You are now connected to matmod and have complete access to its powerful Linux command line.</p>"},{"location":"labs/lab01/readme/#3-basic-command-line-usage","title":"3. Basic command line usage","text":"<p>While using a computer for day-to-day activities, you most likely have become familiar with a Graphical User Interface (GUI), which is a graphical way to interact with the computer. Most Operating Systems (OS) also provide a non-graphical way to interact with the computer through the command line (also usually denoted as the terminal). In this course we will deal exclusively with the Linux command line. The command line offers a completely equivalent way to the GUI to perform tasks, but has several advantages:</p> <ul> <li>It uses very few system resources. This is especially useful if there are dozens of users using the same machines simultaneously, as in this Lab</li> <li>It is extremely flexible. With knowledge of just a few basic operations, it is possible to chain them together to perform complex tasks, or to automate tasks altogether</li> </ul> <p>In this section, you will learn how to use the command line to perform simple tasks like listing the files inside a directory, creating and copying directories and run simple programs. Most of the programs that you will use in this course will run exclusively in the command line, but you can also use it to run programs with a GUI.</p> <p>If you successfully connected to the remote server using PuTTY, you should have a Linux command line in front of you right now.</p> <p>The terminal will give you access to a prompt that can be used to interact with the computer. The prompt contains three sections: <code>username @ machine : current working directory $</code>. The commands you write will always be in front of the <code>$</code> symbol.</p> <p></p> <p>Task 1: launching your first program</p> <p>Write the command <code>gedit</code> then press Enter. This might take a few seconds, but then it will open a graphical text editor. The prompt will be unresponsive until this program finishes. This will be the case for most Linux commands. In this case, the program will finish once you close the <code>gedit</code> window. Until the command completes its assigned task, you cannot use the prompt, but once the task is finished, the prompt can be used again.</p> <p></p> <p>Important Remember to close the <code>gedit</code> window</p> <p>Task 2: command line programs</p> <p>Not all commands open up graphical interactive windows. Let's now take a look at commands which provide output exclusively in the command line. </p> <ol> <li>Run the program <code>date</code>, which will print out to the terminal the current date and time. </li> <li>You can also provide additional parameters to certain commands to make them do specific tasks. For example, the command <code>echo</code> prints out to the terminal the text that\u2019s written after it. Run the program echo with <code>DFT</code> as a parameter - <code>echo DFT</code>, and check that it prints out the word <code>DFT</code> to the terminal. </li> </ol> <p></p> <p>In sum, commands in the Linux command line have the following structure</p> <pre><code>command argument1 argument2 ...\n</code></pre> <p>where the number of arguments can be virtually arbitrary.</p>"},{"location":"labs/lab01/readme/#31-writing-to-and-reading-from-file","title":"3.1 Writing to and reading from file","text":"<p>In many circumstances, you might want to save the output of a command to a file so that you can process it later. This can be done with the output redirect symbol <code>&gt;</code>. For example, running  <pre><code>date &gt; file.txt \n</code></pre></p> <p>in the command line will save the output that you got previously into the file called <code>file.txt</code>. You can check that this file has been created by using gedit.</p> <p>Task 3: saving to file</p> <ol> <li>Run the previous command</li> <li>Open it using gedit and check that its contents match your expectation <pre><code>gedit file.txt\n</code></pre></li> </ol> <p></p> <p>While gedit provides all the means necessary to read and write files, it can be very slow when the connection to the server is not stable, or when many people are connected to the server simultaneously. A quicker way to read the contents of a file is by using the <code>cat</code> command. When you provide an argument to the <code>cat</code> command, it will assume that the argument is a file name and will output its contents.</p> <p>Task 4: Reading from a file</p> <p>Run the following command and check that the output matches what you saw with gedit</p> <pre><code>cat file.txt\n</code></pre> <p></p> <p>If the file is very long, you can also use <code>head file.txt</code> if you just want to print out the first lines of the file, or <code>tail file.txt</code> if you just want to print out the last lines. Alternatively, you can use a more interactive command like <code>less file.txt</code> which will replace the terminal with a file reader that you can scroll through with your mouse wheel or the keyboard arrows. You can exit this file reader by pressing <code>q</code>. Reading the file directly from the command line is often the quickest and most convenient way to get information from a file.</p>"},{"location":"labs/lab01/readme/#32-using-a-file-as-argument-to-a-command","title":"3.2 Using a file as argument to a command","text":"<p>Some Linux commands can use instructions saved in files to perform their job. For the purposes of this Lab, we will be doing this by using the input redirect feature with the symbol <code>&lt;</code>. </p> <p>Task 5 - Files as input</p> <p>The command <code>sort</code> sorts the input that is given to it. </p> <ol> <li>Using gedit, create a file called <code>numbers.txt</code> containing three separate lines with the numbers 3,9 and 1</li> <li>Run <code>sort &lt; numbers.txt</code>. This command will print out the sorted list of numbers.</li> <li>Save the output of this command into another file <code>numbers_sorted.txt</code> using what you learned previously: <code>sort &lt; numbers.txt &gt; numbers_sorted.txt</code></li> <li>Read the contents of this new file using <code>cat</code> and check that the numbers have been sorted</li> </ol> <p> </p>"},{"location":"labs/lab01/readme/#4-navigating-the-system","title":"4. Navigating the system","text":"<p>So far, all the commands you have been running were executed inside of your home directory. In a GUI, you navigate the system by clicking on folders with the cursor and looking at their contents. In a terminal, everything is done via commands. Instead of clicking on a folder, you issue a command to change your current location to that folder. Instead of visualizing the files as icons inside a folder, you issue a command to show the file names in the current directory.</p>"},{"location":"labs/lab01/readme/#41-understanding-the-directory-structure","title":"4.1 Understanding the directory structure","text":"<p>The directory (or folder) structure in Linux is defined through the use of the forward slash <code>/</code>. For example, <code>/file1.txt</code> means that <code>file1.txt</code> is inside the root directory, which is represented by a single forward slash <code>/</code>. <code>/directory1/file1.txt</code> means that <code>file1.txt</code> is inside <code>directory1</code> which is inside the root directory <code>/</code>. As a user of the matmod server, your files are located in the directory <code>/home/username</code>, which has a shorthand expression <code>~</code>. This is called the home directory.</p> <p></p>"},{"location":"labs/lab01/readme/#42-figuring-out-where-you-are","title":"4.2 Figuring out where you are","text":"<p>If you want to check what is your current directory, run the command <code>pwd</code>, which stands for print working directory. This will print out something like <code>/home/sjoao</code>, which means that the directory <code>sjoao</code> is located inside the directory <code>home</code>. It also means that you are currently located inside the <code>/home/username</code> folder. This directory <code>/home/sjoao</code> is known as the home directory, and is equivalently represented by a tilde <code>~</code> as a shorthand.</p> <p>Task 4.1</p> <p>Run the command <code>pwd</code> in the command line. Check that this output corresponds to a directory structure as discussed above</p> <p></p>"},{"location":"labs/lab01/readme/#43-list-the-contents-of-the-directory","title":"4.3 List the contents of the directory","text":"<p>If you want to list the contents of your current directory, run the list command <code>ls</code>. This will print out to the terminal the list of folders and files that exist in the current directory. Note: in the terminal, the digit 1 and the letter l may look identical, so be sure you write the letter, not the digit.</p> <p>Task 4.3</p> <p>Run the command <code>ls</code> and check that the files that you created in the previous tasks are here. </p>"},{"location":"labs/lab01/readme/#44-creating-new-directories-and-changing-directories","title":"4.4 Creating new directories and changing directories","text":"<p>The command <code>mkdir</code> (which stands for make directory) is used to create new directories inside of the current directory. If you run <code>mkdir newDirectory</code>, you will see that a directory <code>newDirectory</code> has been created. To navigate to that directory, run <code>cd newDirectory</code>. To navigate to its parent directory, run <code>cd ..</code> in the command line. The two dots <code>..</code> stand for parent directory. </p> <p>These commands are all relative to the current directory, but you can also use the absolute path. For example, run <code>mkdir ~/newDirectory/dir2</code>. You will see that a directory will be created inside of newDirectory, which is inside of your home <code>~</code> directory. To navigate to it directly, you can run <code>cd ~/newDirectory/dir2</code> in just the same way. Running <code>cd ~</code> will place you back into your home directory.</p> <p>Task 4.4</p> <p>Run the commands above and in each step run <code>ls</code> and <code>pwd</code> to better understand the directory structure. </p>"},{"location":"labs/lab01/readme/#5-file-manipulation","title":"5. File manipulation","text":""},{"location":"labs/lab01/readme/#51-copying-files","title":"5.1 Copying files","text":"<p>In the terminal, you copy files by using the <code>cp</code> command, which requires the origin (file to be copied) to be specified as the first argument and destination to be specified as second argument. For example, if you want to copy file <code>~/text.txt</code> (which is located in your home folder) to the directory <code>~/newDirectory/dir2</code>, you can do it in two ways:</p> <ol> <li>Specify the full paths: <pre><code>cp ~/file.txt  ~/newDirectory/dir2\n</code></pre></li> <li>Navigate to one of the directories and use a relative path: <pre><code>cd ~/newDirectory/dir2\ncp ~/file.txt .\n</code></pre> The dot <code>.</code> in this last command represents this directory, so the command means: \u201ccopy the file <code>~/file.txt</code>, which is located in the home directory into the current directory\u201d.  Note: if the file already exists in the destination, it will be overwritten. </li> </ol>"},{"location":"labs/lab01/readme/#52-copying-folders","title":"5.2 Copying folders","text":"<p>To copy folders, the only extra thing you need to do is to specify the additional <code>-r</code> argument to <code>cp</code>. For example, you can copy the directory <code>dir2</code>, which has the location <code>~/newDirectory/dir2</code> to the home directory as such: <pre><code>cp -r ~/newDirectory/dir2  ~\n</code></pre></p> <p>Note: Unlike files, folders are not overwritten. If you copy a folder into the location of another, instead of overwritting, the command will place the source folder inside of the destination folder.</p> <p>Task </p> <p>Run the commands from the previous two sections and check with <code>ls</code> that the contents of each folder correspond to the expectation.</p>"},{"location":"labs/lab01/readme/#53-moving-and-renaming-files","title":"5.3 Moving and renaming files","text":"<p>The syntax to move files is exactly the same as the one for the <code>cp</code> command. To move a file <code>file.txt</code> from <code>~/newDirectory/dir2</code> to <code>~/newDirectory</code>, run the command <pre><code>mv ~/newDirectory/dir2/file.txt ~/newDirectory\n</code></pre> You can also move directories in a similar way to <code>cp</code>, but without the additional <code>-r</code> argument. </p> <p>Task</p> <p>Create a new directory <code>dir3</code> inside the home directory and move <code>~/dir2</code> into <code>dir3</code> <pre><code>cd ~\nmkdir dir3\nmv dir2 dir3\n</code></pre></p> <p>To rename a file, you also use the <code>mv</code> command. You can think of renaming a file as moving a file into another with a different name. For example, to rename <code>file.txt</code> to <code>data.txt</code>, use <code>mv file.txt data.txt</code></p> <p>Task</p> <p>Run the previous command and check that the file has the expected name.</p>"},{"location":"labs/lab01/readme/#54-deleting-files","title":"5.4 Deleting files","text":"<p>To delete a file, you use the <code>rm</code> command. For example, if you want to remove file <code>file.txt</code>, use <code>rm file.txt</code>. To delete directories, the argument <code>-r</code> has to be provided: <code>rm -r ~/newDirectory/dir2</code> Note: If you run the <code>rm</code> command, the deleted file or directory will be deleted permanently, there is no way to undo it, so make sure you are running the correct command.</p> <p>Task</p> <p>Run the previous command and check that <code>file.txt</code> and <code>dir2</code> no longer exist.</p>"},{"location":"labs/lab01/readme/#6-wildcards","title":"6. Wildcards","text":"<p>In Linux many commands will accept wild cards as a way to perform their action on a set of files. <code>*</code> is used to represent zero or more characters. The <code>*</code> wildcard is very commonly used and worth remembering.</p> <ul> <li><code>ls *.txt</code> would list all the files ending in <code>.txt</code> in the current directory.</li> <li><code>rm *.o</code> would remove all files ending in <code>.o</code> in the current directory.</li> </ul>"},{"location":"labs/lab01/readme/#7-job-control-terminating-commands","title":"7. Job Control - terminating commands","text":"<p>Sometimes, you will execute a command which does not seem to finish, so you may want to force it to terminate. You can do this by pressing the keys <code>Ctrl+C</code></p> <p>Task</p> <p>Run <code>gedit</code> and terminate it with <code>Ctrl+C</code>. Make sure that you are pressing the keys <code>Ctrl+C</code> while the terminal window is selected, not the gedit window.</p>"},{"location":"labs/lab01/readme/#8-tab-completion","title":"8. Tab completion","text":"<p>Typing commands in their entirety can be a time-consuming process while interacting with a terminal. Tab completion is a very useful feature of the Linux command line which tries to fill in the commands for you.</p> <p>Task</p> <p>Try typing <code>ged</code> in a terminal and hitting <code>tab</code>. The full name of the program <code>gedit</code> should automatically fill in. If more than one match is possible, pressing <code>tab</code> twice will bring up a list of possible matches. Try typing <code>ge</code> and pressing tab twice to see this.</p>"},{"location":"labs/lab01/readme/#9-loading-modules","title":"9. Loading modules","text":"<p>Environment modules provide extra functionality to your session by giving you access to additional software packages. The reason why these additional softwares are often not available by default is because they may cause conflict with other softwares. Environment modules ensure that these softwares can be loaded safely without causing conflicts. They are almost always used on HPC systems to make various versions of common version of computational software packages available. The main command to know is <code>module</code>. This command allows you to load and unload different software packages. To load a package, use <code>module load</code> followed by the name of the packages. In this lab, you will need to load the Quantum Espresso package:</p> <p><pre><code>module load quantum-espresso\n</code></pre> </p> <p>Throughout the course, when running on the server you'll need to remember to load the modules above before you'll be able to use the codes in the Quantum Espresso package. </p>"},{"location":"labs/lab01/readme/#10-running-your-first-dft-calculation","title":"10. Running your first DFT calculation!","text":"<p>Now that you know the basics of the Linux operating system, it's time to run your first DFT calculation. First, we need to setup a few files and directories. The various files associated with the labs for this course are all available in <code>/opt/MSE404-MM/docs/labs</code>.</p> <p>Task 4.5</p> <p>Try changing directories to <code>/opt/MSE404-MM/docs/labs</code> and exploring the folders and taking a look at files that are contained in there. Change back to the home directory once you're done.</p> <p>Task</p> <ul> <li>In your home directory create the directory <code>MSE404-MM</code>.</li> <li>Copy the directory with the input files for this course <code>/opt/MSE404-MM/docs/labs/lab01</code> to the directory you just created <code>~/MSE404-MM</code>. Remember you need to pass an additional flag to <code>cp</code> to copy a directory.</li> <li>List the contents of directory <code>~/MSE404-MM/lab01/helium</code> with <code>ls</code><ul> <li>You'll see there are three files in the directory you copied.</li> <li><code>He.in</code> - an input file for the DFT code you'll be using.</li> <li><code>He.pbe-mt_fhi.UPF</code> - a pseudopotential file for helium, which contains information about the interaction between the helium nucleus and the electrons.</li> <li>You'll learn more about these types of files in later classes.</li> </ul> </li> </ul> <p></p> <p>Now you are finally ready to run the DFT calculation</p> <p>Task</p> <ul> <li>First we need to load the Quantum Espresso module. If you haven't done this already, run <code>module load quantum-espresso</code>.</li> <li>Now you'll be able to use the various Quantum Espresso package executables directly. Use <code>cd</code> to go to the helium folder you copied earlier (<code>~/MSE404-MM/lab01/helium</code>)</li> <li>The input file there is for the <code>pw.x</code> code. You can pass this file to <code>pw.x</code> with input redirection and save the output to a file with output redirection (otherwise the output will just be in the terminal). To do this type <code>pw.x &lt; He.in &gt; He.out</code>.</li> <li>See what files are present in the directory now. As well as the output file we saved, some others were generated. </li> <li>Take a look through the output file <code>He.out</code> using <code>less</code>. You can use the arrow keys to scroll, <code>g</code> to go to the beginning of the file, <code>G</code> to go to the end of the file and <code>q</code> to exit the reader. We'll discuss the contents of this in next week's lab, but for now skip to the section immediately following the line that reads <code>End of self-consistent calculation</code>:<ul> <li>This lists the calculated energy eigenvalues: in helium only the 1s orbital is occupied by two electrons</li> <li>Compare the value of the 1s orbital energy to the result you get from the Schroedinger equation when electron-electron interactions are neglected.</li> <li>Following this, you can see in the output, the value of the highest occupied energy level in eV, and the total energy in Rydberg. How does the total energy compare to the experimental value of -79.02 eV? How does it compare to the total energy obtained when electron-electron interactions are neglected?</li> <li>Congratulate yourself on running your first DFT calculation.</li> </ul> </li> </ul> <p></p>"},{"location":"labs/lab01/readme/#11-pipe-operator-and-filtering-output-with-grep","title":"11. Pipe operator and filtering output with grep","text":"<p>Running commands may produce a lot of output, making it difficult to find the information you want. The Linux command line provides the option to filter output by using the <code>grep</code> command together with the <code>|</code> operator (pipe operator). The pipe operator passes the output of a command as input to the next command. For example, <code>cat He.out | grep highest</code> will read out the contents of the output file <code>He.out</code> and, instead of printing them to the terminal, will pass them to <code>grep</code>, which will filter it according to the keyword <code>highest</code>. Any line which contains this keyword will then be printed out to the terminal. If no line exists with the keyword, nothing will be printed out.</p> <p></p> <p>Task</p> <p>Modify the example above to print out all the lines containing the keyword <code>total</code>. Why do you get several outputs now?</p>"},{"location":"labs/lab01/readme/#12-uploading-files-to-matmod","title":"12. Uploading files to matmod","text":"<p>In order to complete your homework assignments, you might want to upload your DFT input files to matmod and use matmod to perform the DFT calculations. In this section, you will learn how to do that. In the Imperial Software Hub, search and run WinSCP</p> <p></p> <p>You will be presented with an interface to input the connection details. This is similar to what you have done with PuTTY.</p> <p></p> <p>After the connection is successful, you will be prompted to add the host key to a cache. Press Accept</p> <p></p> <p>Finally, you will be presented with a window with your Windows folders on the left and your matmod folders on the right. Now you can simply drag and drop the files you want into matmod. In this example, we are uploading some file containing instructions, but in your case you might be uploading the DFT input files.</p> <p></p> <p>Task</p> <ol> <li> <p>Using WinSCP, upload a file of your choice to matmod.</p> </li> <li> <p>Using the Linux command line you were using previously, check with <code>ls</code> that the file you just uploaded shows up in the correct directory.</p> </li> </ol>"},{"location":"labs/lab01/readme/#13-logging-out","title":"13. Logging out","text":"<p>Once you're done, exit the session by closing the terminal and then pressing OK. This will close Putty. Finally, go back to the Cloudpaging Player, select Xming, Stop the application and press Yes.</p> <p></p>"},{"location":"labs/lab01/readme/#14-important-disk-quota-limitations","title":"14. IMPORTANT - Disk quota limitations","text":"<p>The <code>matmod</code> server is shared among all the students. To prevent any one student from using up too much storage, each student is limited to <code>1GB</code> of storage in their home directory. This is not a lot, considering that many DFT calculations will store files consisting of several hundreds of <code>MB</code>. To get around this, <code>matmod</code> provides another directory called <code>data</code> inside your home directory which has a much higher storage capacity. As you progress throught the DFT course, please use the <code>data</code> directory instead of the <code>home</code> directory to perform your calculations. </p> <p>If you come across any of the following problems, it's probably because you ran out of space in your <code>home</code> directory: - You get a disk storage error when creating new files or running DFT calculations. - You cannot run <code>gedit</code> because you get an error instead of the window showing up. - When you login, you get a message concerning XAuthority.</p>"},{"location":"labs/lab01/readme/#15-summary","title":"15. Summary","text":"<p>There are a lot of commands to remember from this week's lab. You can always refer back to this week, but to make things easier in future weeks you might find a cheatsheet useful. If you don't want to make your own, a quick Google search of <code>Linux cheat sheet</code> brings up a number of options.</p> <p>To run the DFT example in this lab you will need to do the following:</p> <ul> <li>Make a directory that will hold the material for the MSE404 labs:   <code>mkdir ~/MSE404-MM</code>.</li> <li>Copy the directory with the inputs for this lab to this directory:   <code>cp -r /opt/MSE404-MM/docs/labs/lab01 ~/MSE404-MM</code>.</li> <li>Load the modules needed to run Quantum Espresso:   <code>module load quantum-espresso</code>.</li> <li>Go to the directory with the input files you copied    <code>cd ~/MSE404-MM/lab01/helium</code>.</li> <li>Use <code>pw.x</code> to process the input file, saving the output to a file:   <code>pw.x &lt; He.in &gt; He.out</code>.</li> <li>Take a look through the output file:   <code>less He.out</code>.</li> <li>Logout of the remote server once you're done.</li> </ul>"},{"location":"labs/lab02/readme/","title":"Quantum Espresso Input and Output for Molecules","text":"<p>This week you will run some DFT calculations for molecules and small atomic clusters using the Quantum Espresso software. We will focus on understanding the format of input files and output files that you will need for the rest of the course.</p> <p>Quantum Espresso is used via the command line. There is no graphical user interface by default, which is typical of most electronic structure codes. If you can't remember how to do something using the command line, you can always refer back to Lab 1.</p> <p>Task 1 - Copy Input Files</p> <p>In lab 1 you should have created a directory named <code>MSE404-MM</code> in your home directory.</p> <ul> <li>Check this by issuing the command <code>cd ~</code> followed by <code>ls</code>.</li> <li>Copy the input files from <code>/opt/MSE404-MM/docs/labs/lab02</code> to your <code>MSE404-MM</code> folder. Remember you need to pass an additional flag to <code>cp</code> to copy a directory. If you are struggling with this, revisit Lab 1.</li> <li>Copy the directory containing the pseudopotentials that you will be using during this course to your <code>MSE404-MM</code> directory. These are stored in <code>/opt/MSE404-MM/docs/labs/pseudo</code></li> </ul> <p>You should now have the directories <code>lab02</code> and <code>pseudo</code> within your <code>MSE404-MM</code> directory. These contain a set of basic input files for a variety of systems and the pseudopotentials for the input files.</p>"},{"location":"labs/lab02/readme/#input-files","title":"Input Files","text":"<p>Before running a DFT calculation we need to create the input files. These input files give instructions to Quantum Espresso to tell it what we want to calculate, and what parameters to use for the calculation. The first example we will be looking at is in the <code>01_methane</code> directory. In this directory there is an input file for the <code>pw.x</code> module of Quantum Espresso which calculates the total energy of your system.</p> <p>Let's take a look at our first input file CH4.in.</p> <p>Tip: In-code annotations</p> <p>Click (1) to see notes on the input tags.</p> <ol> <li>This is an annotation</li> </ol> <pre><code>&amp;CONTROL #(1)!\n    pseudo_dir = '.' #(2)!\n/\n\n&amp;SYSTEM\n    ibrav = 1 #(3)!\n    A = 15.0 #(4)!\n    nat = 5 #(5)!\n    ntyp = 2 #(6)!\n    ecutwfc = 18.0 #(7)!\n/\n\n&amp;ELECTRONS\n/\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF #(8)!\n H   1.008  H.pz-vbc.UPF\n\nATOMIC_POSITIONS angstrom #(9)!\nC 7.2433205 7.5 7.137\nH 7.2433205 7.5 8.225999999999999\nH 8.2700395 7.5 6.773999999999999\nH 6.729960500000001 6.610835 6.773999999999999\nH 6.729960500000001 8.389165 6.773999999999999\n\nK_POINTS gamma #(10)!\n</code></pre> <ol> <li>Quantum Espresso input files are ordered with 'tags'. These 'tags' start with a <code>&amp;</code> and end with a <code>/</code>. They are blocks of input parameters.</li> <li>Directory containing your pseudopotentials defined later in the input file. The directory <code>.</code> means the current directory. </li> <li>Bravais lattice type e.g. simple cubic, face centered cubic etc. These are documented on the Quantum Espresso input description page. You will get familiar with this throughout the course. ibrav = 1 is a simple cubic lattice.</li> <li>Crystallographic constant i.e. cell vector length. Simple cubic with A=15 means a 15x15x15 \u00c5 box. </li> <li>Number of atoms.</li> <li>Number of species.</li> <li>Energy cutoff for wavefunction expansion. You will learn more about this in your lectures and Lab 3</li> <li>Atomic species, atomic mass and the name of the pseudopotential file.</li> <li>Below this tag are the atomic positions of your atoms. The <code>angstrom</code> after <code>ATOMIC_POSITIONS</code> specifies these are in cartesian coordinates in units of \u00c5.</li> <li>K-points are wave vectors of electrons. As we are interested in bound electronic states of molecules in this lab, we are using k=(0,0,0). This k-point is also known as the Gamma point.</li> </ol> <p>Later we will learn how to visualise the structure, but for now, here is how our methane molecule looks:</p> <p>Task 2 - Alternative Input File Style</p> <p>Take a look at the input file in the <code>01a_methane</code> directory.</p> <ul> <li>How is this different from the input file discussed above?</li> </ul> Answer <p>ibrav is now set to 0. This means 'free cell' meaning the user needs to specify the cell parameters manually. The parameter defining the cell vector length is not present. There is also a section called <code>CELL_PARAMETERS</code>.</p> <ul> <li>Will this input file do the exact same thing as the one in <code>01_methane</code>?</li> </ul> Answer <p>Yes! Instead of specifying the cell vector length we have just specified the length of each cell vector in the <code>CELL_PARAMETERS</code> section. </p> <p>Warning - Periodic Boundary Conditions and Molecules</p> <p>Quantum Espresso uses periodic boundary conditions. In other words: we are not modelling a single molecule, but instead an infinite cubic crystal of molecules. In order to avoid interactions between molecules in the different unit cells of this crystal, we have to make the lattice constant of the crystal sufficiently large. Otherwise we might not get the correct description of an isolated molecule. </p>"},{"location":"labs/lab02/readme/#running-and-examining-the-calculation","title":"Running and examining the calculation","text":"<p>The Quantum Espresso package has been compiled as a module on the server as discussed in Lab 1. Modules are often used on High Performance Computing (HPC) systems to make different versions of packages available to users. In order to be able to run a Quantum Espresso calculation, it must first be loaded to your environment. This can be done by issuing the command</p> <pre><code>module load quantum-espresso\n</code></pre> <p>This will load Quantum Espresso and any other modules that Quantum Espresso needs to run.</p> <p>Task 3 - Running a calculation</p> <p>To run the first calculation of the day, make sure you have loaded Quantum Espresso to your environment as discussed above.</p> <ul> <li> <p>Navigate back to the <code>01_methane</code> directory.</p> </li> <li> <p>Issue the command  <pre><code>pw.x &lt; CH4.in &gt; CH4.out\n</code></pre></p> </li> </ul> <p>After the calculation has finished take a look at the files created in your directory. You should have a file named <code>pwscf.xml</code> and a new directory named <code>pwscf.save</code>.</p> <ul> <li><code>pwscf.xml</code> contains the results of the pw.x calculation in xml format. This format is both human-readable and machine-readable and facilitates the storing, transmitting and reconstructing of data.</li> <li><code>pwscf.save</code> is a directory which contains: <ul> <li>A copy of <code>pwscf.xml</code>.</li> <li>A copy of the pseudopotential files used in the calculation.</li> <li>A file in which the charge density stored. </li> <li>Wavefunction files which are stored in binary format (and thus are not human readable). These can be used as inputs to other calculations.</li> </ul> </li> </ul> <p>Now that we have run the calculation for methane, we should examine the output file <code>CH4.out</code>, which is where we instructed Quantum Espresso to pipe the output of the pw.x calculation. Using the command <pre><code>less CH4.out\n</code></pre> we can look at the output file. Output files are generally structured as follows:</p> <ul> <li>Beginning: important information about the system including parameters used in the calculation.</li> <li>Middle: actual DFT calculation.</li> <li>End: final results like total energy, orbital energies, etc.</li> </ul> <p>Task 4 - Examining an output file</p> <p>Using the <code>less</code> command specified above</p> <ul> <li>How many valence electrons were in your calculation?</li> </ul> Answer <p>8.00. This is found at the top of your output file. <pre><code>number of electrons       =         8.00\n</code></pre></p> <ul> <li>How many iterations did your calculation go through to find the solution?</li> </ul> Answer <p>9 scf cycles. This is found on the line: <pre><code>convergence has been achieved in   9 iterations\n</code></pre></p> <ul> <li>What is the total energy of the methane molecule?</li> </ul> Answer <p>\\(E_{\\text{Tot}} = -15.49833140 \\, \\text{Ry}\\). This is found on the line: <pre><code>!    total energy              =     -15.49833140 Ry\n</code></pre> Notice the converged total energy will always have a <code>!</code> at the beginning of the line.</p> <ul> <li>What accuracy is your calculation converged to?</li> </ul> Answer <p>0.00000064 Ry. This is found on the line: <pre><code>estimated scf accuracy    &lt;       0.00000064 Ry\n</code></pre> We did not specify this in the input file. The default value of below 1E-6 was therefore used.</p> <ul> <li>How many Kohn-Sham energy eigenvalues were calculated?</li> </ul> Answer <p>4 Kohn-Sham energy eigenvalues were calculated. This is found in the lines: <pre><code>End of self-consistent calculation\n\nk = 0.0000 0.0000 0.0000 ( 14712 PWs)   bands (ev):\n\n-17.3307  -9.3182  -9.3176  -9.3173\n</code></pre></p> <p>Electrons and Energy Eigenvalues</p> <p>Note that in this calculation we had 8 valence electrons but only 4 energy eigenvalues were calculated. This is because - according to the Pauli principle - each Kohn-Sham state can accommodate 2 electrons. </p> <p>Task 5 - Alternative Input File</p> <p>Navigate to the directory <code>01a_methane</code>. </p> <ul> <li>Run the same calculation as in Task 4 and confirm that you get the same results.</li> </ul>"},{"location":"labs/lab02/readme/#visualisation-vesta","title":"Visualisation - VESTA","text":"<p>Interactive visualisation software is crucial in computational physics. Not only can it be used to check the atomic structure, but it is also very useful for looking at the charge density and wavefunctions generated by DFT calculation. You will learn more about this in Lab 5. The visualisation software we are going to use in this course is called VESTA.</p> <p>VESTA, like Quantum Espresso, can be loaded as a module. To use it you will need to issue the command:</p> <pre><code>module load vesta\n</code></pre> <p>You have now loaded VESTA to your environment. By default, VESTA cannot read Quantum Espresso input files. Therefore, we will need to convert the input files to a format that VESTA can read. To do this we are going to use another module <code>c2x</code>. To use it you will need to issue the command:</p> <pre><code>module load c2x\n</code></pre> <p>This allows us to convert the Quantum Espresso .in file into a .cif file that VESTA can read. To do this, issue the command:</p> <pre><code>c2x --cif CH4.in CH4.cif\n</code></pre> <p>You will now see a .cif file in your directory. VESTA can visualise this file. You can do this with the command:</p> <pre><code>vesta CH4.cif\n</code></pre> <p>.cif Files</p> <p>A .cif file is a Crystallographic Information File and is a standard text file format used to describe the structure of crystalline materials. The .cif file usually contains atomic positions, symmetry operations, lattice vectors etc. They are very useful for materials modellers since it is a standardised format. Additionally, .cif files are commonly used to store experimental crystallographic data, so they can be used to generate input files using experimentally measured atomic structures.</p> <p>During this lab we will be working with different molecules. It will be a good exercise to visualise them as we go along.</p>"},{"location":"labs/lab02/readme/#methane-ethane-and-ethene","title":"Methane, ethane and ethene","text":"<p>Now we have understood the basics of the Quantum Espresso input file, technically the scf input file, let's try some other molecules. We have been looking at Methane (CH4), so we can go up one step and look at ethane (C2H6)</p> <p>and then ethene (C2H4).</p> <p>The only thing that is going to change in our input files are the number of atoms and the atomic positions. The input files C2H6.in and C2H4.in have been made for you in the directories <code>02_ethane</code> and <code>03_ethene</code> respectively.</p> <p>We can use the <code>diff</code> command to check for differences between two file. To see the changes made in the ethane input file relative to the one for methane that we have been working on, use the diff command. If you are in the <code>lab02</code> directory then this can be done using the command:</p> <pre><code>diff 01_methane/CH4.in 02_ethane/C2H6.in\n</code></pre> <p>Task 6 - Running and Visualising Structures</p> <p>We want to visualise all three molecules; methane, ethane and ethene to see the structural differences. We then want to run a total energy calculation and finally do some post processing to look at the charge density and the wavefunction.</p> <ul> <li> <p>Using <code>c2x</code> and <code>vesta</code>, visualise the structures for methane, ethane and ethene yourself.</p> </li> <li> <p>Run a DFT calculation for ethane and ethene using <code>pw.x</code> as you did for methane. How do the energy eigenvalues compare between the molecules?</p> </li> </ul> Answer <p>The eigenvalues are printed in eV. Methane, ethane and ethene have a different number of eigenvalues as shown below.</p> <p>Methane:    -17.3307  -9.3182  -9.3176  -9.3173</p> <p>Ethane:    -18.9981 -15.1568 -10.4905 -10.4893  -9.0301  -7.7951  -7.7936</p> <p>Ethene:    -19.2564 -14.3120 -11.4232  -9.9431  -8.1807  -6.8756</p> <ul> <li>Methane has 8 electrons in the calculation, therefore 4 doubly occupied states and 4 eigenvalues.</li> <li>Ethane has 14 electrons in the calculation, therefore 7 doubly occupied states and 7 eigenvalues.</li> <li>Ethene has 12 electrons in the calculation, therefore 6 doubly occupied states and 6 eigenvalues.</li> </ul> <ul> <li>A common mistake in DFT calculations is the use of incorrect units. In the example <code>03_ethene</code>, the atomic positions are defined in Bohr. Try changing the units in ATOMIC_POSITIONS from bohr to angstrom. Rerun pw.x. What happens?</li> </ul> Answer <p>Convergence was not achieved in 100 iterations.</p> <p>As mentioned above, we can do some post-processing of our DFT calculation to write desired quantities, like the electron charge density, or the probability density \\(|\\psi|^2\\) (wavefunctions) etc. to files in a suitable format for visualisation / plotting. A comprehensive list of quantities Quantum Espresso can generate via the built-in post-processing tool <code>pp.x</code> can be found here. This is used in a very similar way to <code>pw.x</code>:</p> <pre><code>pp.x &lt; pp.in &gt; pp.out\n</code></pre> <p>Task 7 - Post Processing and Visualisation</p> <p>We now want to perform some post-processing on our ethane molecule. Specifically we wish to visualise the charge density and one of the Kohn-Sham states our electrons are occupying. Since we are calculating ethane at the gamma point, the wavefunction can be made purely real, and this allows us to plot the sign of the wavefunction as well.</p> <ul> <li> <p>Return to the <code>02-ethane/</code> directory and run the post-processing for the charge density using <code>pp.x</code> on the <code>pp_chg.in</code> file. The <code>.cube</code> file produced can directly be visualised using VESTA.</p> </li> <li> <p>Now try to visualise one of the Kohn-Sham states using <code>pp_wfc.in</code>. The <code>.cube</code> file produced can be visualised directly using VESTA. Try to plot the next band and visualise it. Why is this state higher in energy?</p> </li> </ul> Answer <p>The plot for kband=1 showed the same sign of the wavefunction with 0 nodes. This corresponds to a bonding orbital. The plot for kband=2 showed different signs of the wavefunction with a node in the center which represents the antibonding orbital. Antibonding orbital is higher in energy than a bonding orbital.</p>"},{"location":"labs/lab02/readme/#c_20-isomers","title":"C\\(_{20}\\) isomers","text":"<p>The total energy of a molecule often isn't that useful by itself. In fact, our calculations use pseudopotentials and therefore cannot produce accurate values for the total energy. However, differences of total energies between, say, different isomers of a given molecule are much more useful.</p> <p>In general (ignoring effects of e.g. temperature), if we compare total energies of isomers, a lower total energy indicates that an isomer is more stable. As an example, we will investigate three different isomers of  C\\(_{20}\\):</p> <ul> <li>C\\(_{20}\\) in a bowl structure</li> </ul> <ul> <li>C\\(_{20}\\) in a ring structure</li> </ul> <ul> <li>C\\(_{20}\\) in a cage structure.</li> </ul> <p>If you are wondering if this is a calculation people really do, here is an article doing this exact calculation</p> <p>Task 8 - Total Energy of Isomers</p> <ul> <li> <p>Run the inputs for the three different isomers in <code>04_c20_bowl</code>, <code>05_c20_ring</code> and <code>06_c20_cage</code></p> </li> <li> <p>Which isomer has the lowest total energy?</p> </li> </ul> Answer <p>\\(E_{\\text{Tot}}^{\\text{Bowl}} = -218.12237988 \\,\\text{Ry}\\)</p> <p>\\(E_{\\text{Tot}}^{\\text{Ring}} = -217.76506479 \\,\\text{Ry}\\)</p> <p>\\(E_{\\text{Tot}}^{\\text{Cage}} = -218.37740806 \\,\\text{Ry}\\)</p> <p>Using \\(E_{\\text{Tot}}^{\\text{Cage}}\\) as a reference, we can calculate the energy differences between the structures. Doing so we can see that the the cage structure has the lowest energy.</p> <ul> <li>What does it mean to have the lowest total energy of the three isomers? What conclusions about stability can we draw from these calculations?</li> </ul> Answer <p>The lowest energy typically means that the structure is the most stable. However, these energies are very close, so it is hard to draw conclusions based on these calculations. Additionally, one can compare the energy differences between the structures to \\(k_BT\\) at room temperature, \\(25\\) meV. If the energy difference between the structures is within \\(25\\) meV of one another, then the structures are degenerate and no conclusions about stability can be drawn.</p> <p>You will notice that the three isomers are very close in total energy. Maybe we can find some other isomers with even lower energies. For example, we can try an amorphous structure.</p> <p>Or a \"smiley\" face :-).</p> <p>Task 9 - Amorphous and Unrealistic Calculation</p> <ul> <li>Run the inputs for the amorphous structure found in <code>07_c20_amorphous</code>. How does the energy compare to the three isomers above? Is this what you expect?</li> </ul> Answer <p>\\(E_{\\text{Tot}}^{\\text{Amorphous}} = -217.09834389 \\,\\text{Ry}\\)</p> <p>Again, comparing this to \\(E_{\\text{Tot}}^{\\text{Cage}}\\) we can see that this has the highest energy of the three isomers. This is expected as amorphous structures are typically higher in energy due to their disorder.</p> <p>Finally we can run a calculation for the smiley face.</p> <ul> <li> <p>Navigate to <code>08_c20_smile</code> and visualise the structure. </p> </li> <li> <p>Run a DFT calculation and compare the total energies to your previous results for the other isomers. Is this what we expect?</p> </li> </ul> Answer <p>\\(E_{\\text{Tot}}^{\\text{Smile}} = -216.92843483 \\,\\text{Ry}\\)</p> <p>This is even higher than that of the amorphous structure. This is expected as this is a totally unrealistic structure and we do not expect it to be stable.</p> <p>In the paper linked above it was shown that the relative energies of the ring, cage and bowl structure are very sensitive to the details of the approach used. For these systems using just DFT it is hard to say with certainty which is the most stable isomer. However, comparing to less realistic structures we can see the difference in energy between structures which should be stable and which should not be stable, which is very valuable information.</p> <p>Convergence Issues</p> <p>If you were to use a structure which more closely resembled a smiley face, Quantum Espresso would be unable to reach convergence within 100 iterations, just as when we used the wrong units for ethene.  If you encounter a problem with convergence, the first thing you should check is whether or not the input structure is sensible which underlines the importance of visualising your structures before you run calculations!</p>"},{"location":"labs/lab02/readme/#summary","title":"Summary","text":"<p>In this lab we have looked at how to create input files and examine the output files for some different molecules:</p> <ul> <li>Methane</li> <li>Ethane</li> <li>Ethene</li> <li>Different isomers of C\\(_{20}\\)</li> </ul> <p>We have also learned how to use VESTA to visualise our structures with the help of the <code>c2x</code>.</p>"},{"location":"labs/lab03/readme/","title":"Convergence Tests","text":"<p>This week we are going to continue on the topic of DFT calculations for isolated molecules. Specifically, we will be focusing on ensuring that our calculations are converged, i.e. that the numerical parameters, such as the plane-wave cutoff, the energy threshold or the box size, are chosen in such a way that physically meaningful results are obtained. Ensuring that convergence is reached is a key step in every DFT study of materials. </p> <p>If needed, you can refresh your memory of the Linux command line by referring back to Lab 1.</p>"},{"location":"labs/lab03/readme/#plane-waves-and-pseudopotentials","title":"Plane Waves and Pseudopotentials","text":"<p>As discussed in lecture, the Kohn-Sham wavefunctions are expressed as linear combination of plane waves in Quantum Espresso and the total number of plane waves used in the calculation is a convergence parameter. In the region between the atomic nuclei where chemical bonding takes place, the Kohn-Sham wavefunctions are relatively smooth and therefore not too many plane wave are needed to accurately describe them. However, very close to the atomic nucleus the Kohn-Sham wavefunctions vary rapidly (this is a consequence of the requirement that the valence orbital are orthogonal to the tightly bound core orbitals) and lots of plane waves are needed corresponding to a high plane-wave cutoff. Unfortunately, this would make the calculations very slow...</p> <p>To get around this problem, Quantum Espresso uses pseudopotentials. The idea is to combine the atomic nucleus with the tightly bound core electrons (which do not participate in chemical bonding) into an atomic core whose interaction with the valence electrons is described by the pseudopotential. Since there are no more core electrons in the calculations, the valence electrons do not exhibit rapid variations near the nucleus any more and a low plane-wave cutoff can be used. </p> <p>In the figure below, you can see the true \"all-electron\" potential and the resulting \"all-electron\" wavefunctions (blue-dashed lines) and also the pseudopotential and the corresponding pseudo-wavefunctions (red lines): </p> <p>Note that the pseudopotentials are generated from DFT calculations of isolated atoms. These calculations require a choice for the exchange-correlation functional. Therefore, a pseudopotential is always generated for a specific exchange-correlation functional. If you want to try out a different exchange-correlation functional, you have to use a different pseudopotential. </p> <p>The beginning (or \"header\") of pseudopotential files contains important information about how the pseudopotential was generated, such as which state are considered to be core states and which approximation is used for the exchange-correlation energy. </p> <p>To start this lab, copy the <code>/opt/MSE404-MM/docs/labs/lab03</code> to your <code>MSE404</code> directory.</p> <p>Task 1 - Pseudopotential File</p> <p>Navigate to the <code>01_carbon_monoxide/01_convergence_threshold</code> directory. Here you will see an input file <code>CO.in</code> and two pseudopotential files. Open the pseudopotential file for carbon using the <code>less</code> command.</p> <ul> <li> <p>Which approximation is used for the exchange-correlation functional?</p> Answer <p>The local density approximation (LDA). This is found at the top of the pseudopotential file:</p> <pre><code>Info: C LDA 2s2 2p2 VonBarth-Car, l=1 local\n</code></pre> </li> <li> <p>Which atomic orbitals are included as valence states and which ones are included in the core?</p> Answer <p>The states listed in the pseudopotential file are the valence states. These are: <pre><code>nl pn  l   occ               Rcut            Rcut US             E pseuo\n2S  0  0  2.00      0.00000000000      0.00000000000      0.00000000000\n2P  0  1  2.00      0.00000000000      0.00000000000      0.00000000000\n</code></pre> The core state are therefore the 1S state.</p> </li> <li> <p>What is the valence charge of the carbon atom core consisting of the nucleus and the core electrons?</p> Answer <p>The valence charge is 4. This is state in the line <code>4.00000000000 Z valence</code>:</p> </li> </ul>"},{"location":"labs/lab03/readme/#total-energy-convergence-threshold","title":"Total Energy Convergence Threshold","text":"<p>In a DFT calculation, the Kohn-Sham wavefunctions which minimize the total energy are found using a self-consistent procedure: one starts with an initial guess for the density, constructs the Kohn-Sham potential and then solves the Kohn-Sham equations to obtain the Kohn-Sham wavefunctions. These can then be used to find a new density and this procedure is repeated until self-consistency is achieved. Usually, we monitor the total energy and stop the self-consistent cycle when its change (relative to the previous iteration) is below a certain threshold. This threshold is a convergence parameter and must be chosen sufficiently small such that physically meaningful results are obtained. </p> <p>Let's take at a look at the input file for a carbon monoxide (CO) molecule in <code>01_carbon_monoxide/01_convergence_threshold</code>.</p> <p>Tip: In-code annotations</p> <p>Click (1) to see notes on the input tags.</p> <ol> <li>This is an annotation</li> </ol> <pre><code>&amp;CONTROL\n   calculation      = 'scf'\n   disk_io          = 'none' #(1)!\n   pseudo_dir       = '.' #(2)!\n/\n\n&amp;SYSTEM\n   ibrav            = 1 #(3)!\n   A                = 30 #(4)!\n   nat              = 2\n   ntyp             = 2\n   ecutwfc          = 20\n/\n\n&amp;ELECTRONS\n   mixing_beta      = 0.7\n   diagonalization  = 'david'\n   conv_thr = 1e-4 #(5)!\n/\n\n&amp;IONS\n/\n\n&amp;CELL\n/\n\nATOMIC_SPECIES\nO 15.999 O.pz-rrkjus.UPF #(6)!\nC 12.011 C.pz-vbc.UPF \n\nK_POINTS gamma\n\nATOMIC_POSITIONS angstrom\nO 15.0000000000 15.0000000000 16.1503400000\nC 15.0000000000 15.0000000000 15.0000000000\n</code></pre> <ol> <li>This specifies that we don't want any of the charge density or wavefunction information saved in a file. We specify this just to save disk space :-).</li> <li>Specifies that the pseudopotentials to use are in the current directory.</li> <li>ibrav=1 is the bravais lattice type 'simple cubic'.</li> <li>The lattice parameter for the bravais lattice.</li> <li>This is the total energy convergence threshold. Successive iterations will have their total energy compared to one another. When this difference is less than the convergence threshold, we deem the total energy to be converged.</li> <li>The structure of this line is [element name] [element atomic mass] [name of pseudopotential].</li> </ol> <p>Tip: Running Quantum Espressso</p> <p>Make sure to have loaded the quantum espresso module and its dependencies using the command:</p> <p><code>module load quantum-espresso</code></p> <p>Task 2 - Convergence Threshold</p> <p>Make four copies of the <code>CO.in</code> input file named <code>CO_i.in</code>, where i should range from 5 to 8. In each of these files, reduce the order of magnitude of the conv_thr by a factor of 10, i.e. replace <code>conv_thr = 1e-4</code> with <code>conv_thr = 1e-5</code> in <code>CO_5.in</code>, etc. </p> <ul> <li> <p>Run the four input files using <code>pw.x</code> e.g. <code>pw.x &lt; CO_5.in &gt; CO_5.out</code>.</p> </li> <li> <p>What do you expect will happen when you reduce the convergence threshold?</p> Answer <p>More iteration in the self-consistent cycle are needed and the calculations take longer. A more accurate value of the total energy is obtained. </p> </li> </ul> <p>Quantum Espresso outputs the number of scf cycles it took for convergence to be achieved. Look for this line in the output file:  <pre><code>convergence has been achieved in ...\n</code></pre></p> <ul> <li> <p>How many iterations did it take each calculation to converge? Is this what you expected? </p> Answer <pre><code>CO_5.out:     convergence has been achieved in   6 iterations\nCO_6.out:     convergence has been achieved in   8 iterations\nCO_7.out:     convergence has been achieved in   9 iterations\nCO_8.out:     convergence has been achieved in  11 iterations\n</code></pre> </li> </ul> <p>We could have taken advantage of the <code>grep</code> command here. If you don't remember how to use this command, refer back to Lab 1 for documentation on <code>grep</code>. </p> <ul> <li> <p>Try this again using the <code>grep</code> command.</p> Hint For Using Grep <p><code>grep 'convergence has been achieved in' CO_5.out</code>. </p> </li> </ul>"},{"location":"labs/lab03/readme/#plane-wave-cutoff","title":"Plane-wave cutoff","text":"<p>In the expansion of the Kohn-Sham wavefunctions, only plane waves with wave vectors whose lengths are smaller than that of the maximum wavevector, \\(\\bf{G_{\\text{max}}}\\), are included. This maximum wave vector is specified through the variable <code>ecutwfc</code> which is the kinetic energy associated with \\(\\bf{G_{\\text{max}}}\\), i.e. \\(\\hbar^2 |\\bf{G}_{\\text{max}|}^2/{2m}\\). We must ensure that this cutoff is large enough such that physically meaningful results are obtained. </p> <p>An example demonstrating the total energy convergence with respect to energy cutoff is shown in the <code>01_carbon_monoxide/02_kinetic_energy_cutoff</code> directory. To converge the kinetic energy cutoff we are going to set up a series of input files which are all identical except we systematically increase only the value of <code>ecutwfc</code> and record the total energy.</p> <p>Task 3 - Kinetic Energy Cutoff</p> <p>Navigate to the directory <code>01_carbon_monoxide/02_kinetic_energy_cutoff</code>. Here, you will again see an input file for CO and two pseudopotential files. Make 10 copies of this file named <code>CO_i.in</code> where i ranges from 20 to 65 in steps of 5. Change the <code>ecutwfc</code> variable in these files to systematically increase from 20 to 65 i.e. set <code>ecutwfc</code> to be equal to the number i.</p> <ul> <li> <p>Use <code>pw.x</code> to perform a DFT calculation for each input files.</p> </li> <li> <p>Check the output file <code>CO_20.out</code>. What is the converged total energy?</p> Answer <p><code>!    total energy              =     -42.74125239 Ry</code></p> </li> <li> <p>Check the output file <code>CO_30.out</code>. What is the converged total energy? Is this lower than <code>CO_20.out</code>?</p> Answer <p><code>!    total energy              =     -43.00067775 Ry</code>.</p> <p>This is lower than the total energy in <code>CO_20.out</code>.</p> </li> <li> <p>Use <code>grep</code> to extract the total energy from all output files.</p> </li> </ul> <p>These energies are in Ry. Often it is more insightful to convert these values to eV.</p> <ul> <li>Create a text file named <code>data.txt</code>. Copy your results into this file: the first column should be the kinetic energy cutoff in Ry and the second column should be the total energy in eV.</li> </ul> <p>Examine the file <code>data.txt</code>.</p> <p>You should observe that the total energy decreases as we increase the plane-wave energy cutoff <code>ecutwfc</code>.</p> <ul> <li> <p>At what plane-wave cutoff is the total energy converged to within 0.1 eV of your most accurate result (, i.e. the one obtained for <code>ecutwfc = 65</code>)?</p> Result <p>ecutwfc = 55 Ry.</p> <p>\\(E_{tot}^{65} = -586.30894733 \\,\\text{eV}\\)</p> <p>\\(E_{tot}^{55} = -586.21615168 \\,\\text{eV}\\)</p> <p>\\(\\Delta E_{tot} = 0.09279565 \\,\\text{eV}\\)</p> </li> <li> <p>Plot the total energy against the plane-wave cutoff using the python script <code>plot.py</code> by issuing the command: <code>python3 plot.py</code></p> Result <p> </p> </li> </ul> <p>We also discussed above that increasing <code>ecutwfc</code> increases the number of plane waves in the expansion of the Kohn-Sham states. This infomation is stored near the beginning of the output file, in a section that looks like:</p> <pre><code> G-vector sticks info\n sticks:   dense  smooth     PW     G-vecs:    dense   smooth      PW\n Sum       20461   20461   5129              2201421  2201421  274961\n</code></pre> <p>The number of plane-waves in our calculation is in the final column PW. </p> <ul> <li>Look for this line in the <code>CO_20.in</code> and the <code>CO_65.in</code> and verify that the number of plane-waves is significantly higher.</li> </ul> <p>Note that:</p> <ul> <li> <p>Different systems converge differently: You shouldn't expect diamond and silicon to be converged to the same accuracy with the same plane-wave cutoff despite having the same atomic structure and the same number of valence electrons.</p> </li> <li> <p>Different pseudopotentials for the same atomic species will also converge differently. Often (but not always) pseudopotential files will suggest a plane-wave cutoff.</p> </li> <li> <p>Different calculated physical quantities will converge differently. </p> <ul> <li>If we want to calculate the lattice parameter of a material, don't expect it to be converged to the same accuracy as another parameter, e.g. the bulk modulus.</li> </ul> </li> </ul> <p>Warning</p> <p>You should be particularly careful when calculating parameters that depend on volume, as the number of plane-waves for a given plane-wave cut-off changes when the volume is changed.</p> <p>Actually, we typically converge the total energy per atom (meV/atom) or per electron (meV/electron). This is due to the scaling of the total energy with system size (number of atoms/electrons). If we have more atoms in our system, the magnitude of the total energy will naturally be larger i.e. the total energy scales with system size. However, the total energy per atom/electron is a normalised quantity, providing a measure of the total energy that is independent of system size, and thus can be compared between systems to make sure you are converged to the same accuracy.</p> Harder To Converge Orbitals <p>We can make educated guesses on how easily structures can converge based on the orbitals they contain. For example, molecules containing elements that have d orbitals require much higher kinetic energy cutoffs. This is due to the localised nature of the d orbitals resulting in steper gradients of the wavefucntion and therefore needing much higher energy Fourier components in the plane-wave expansion of the Kohn-Sham states.</p>"},{"location":"labs/lab03/readme/#box-size","title":"Box Size","text":"<p>Quantum Espresso uses periodic boundary conditions (recall that plane wave can only be used as a basis for periodic functions). Therefore, it is not possible to model a truly isolated molecule with Quantum Espresso. The best we can do is model a periodic crystal of molecules whose unit cell is so large that each molecule is not affected by the presence of all other molecules. The size of the unit cell (aka the box size) is therefore a convergence parameter and we must ensure it is sufficiently large so that physically meaningful results are obtained. Unfortunately, increasing the box size also increases the time of the calculations.</p> <p>Task 4 - Unit Cell Size</p> <p>Navigate to the directory <code>01_carbon_monoxide/03_box_size</code>. Here, you will again see an input file for CO and two pseudopotential files. Make 10 copies of this file named <code>CO_i.in</code> with i ranging from 10 to 30 in steps of 2. Edit the <code>A</code> variable in these files to systematically increase from 10 to 30, i.e. set <code>A</code> to be equal to the number i. This increases the size of the unit cell, and thus the distance between periodic images of the molecule.</p> <ul> <li> <p>Use <code>pw.x</code> to perform DFT calculations for these input files.</p> </li> <li> <p>Take a look at the output file <code>CO_10.out</code>. What is the energy of the highest occupied molecular orbital (HOMO)?</p> Answer <p>The HOMO energy can be extracted from the list of Kohn-Sham energies, or alternatively is printed under <code>highest occupied level</code> in the output file.</p> <p><code>highest occupied level (ev):    -9.0118</code></p> </li> <li> <p>Now inspect the output file <code>CO_26.out</code>. What is the energy of the highest occupied molecular orbital (HOMO)? How does this compare to the CO_10.out calculation where the distance between periodic images is much smaller?</p> Answer <p><code>highest occupied level (ev):    -9.2100</code>.</p> </li> <li> <p>Create a text file named <code>data.txt</code>. Place your results here in the format [Unit Cell Size (\u00c5)] [Energy of HOMO (eV)]</p> </li> <li> <p>At what unit cell size is the HOMO converged to within 0.1 eV of your most accurate run (<code>A = 30</code>)?</p> Result <p>A = 14. This means that CO molecules need to be ~ 14 \u00c5 away from one another to have less than 0.1 eV effect on each others HOMO. Note that each CO molecule has a dipole moment which produces a long-ranged potential that affects the other molecules.</p> </li> <li> <p>Plot the energy of the HOMO against the unit cell size using the python script <code>plot.py</code> by issuing the command: <code>python3 plot.py</code></p> Result <p> </p> </li> </ul>"},{"location":"labs/lab03/readme/#bash-scripting","title":"Bash Scripting","text":"<p>You have run a lot of DFT calculations in this lab. Running all of these <code>pw.x</code> commands manually is time consuming. To speed things up we can use a small bash script that will automate running these jobs for us. Bash is a programming language (the one we use to interact with the command line), like python. In the same directory <code>01_carbon_monoxide/03_box_size</code> you will find a run.sh bash script. Let's quickly examine it.</p> <pre><code>#!/bin/bash #(1)!\n\n# Run pw.x for each input file sequentially\nfor i in {10..30..2}; #(2)!\ndo\n    pw.x &lt; CO_$i.in &amp;&gt; CO_$i.out #(3)!\ndone\n</code></pre> <ol> <li>This tells the compiler that the commands below are bash commands.</li> <li>Entering a simple for loop going from i=10 to i=30 in steps of 2.</li> <li>Issue the command <code>pw.x &lt; CO_$i.in &gt; CO_$i.out.</code></li> </ol> <p>To use this script, just issue the command;</p> <pre><code>./run.sh\n</code></pre> <p>Redo Task 4 and verify that you get the same result.</p>"},{"location":"labs/lab03/readme/#python-plotting","title":"Python Plotting","text":"<p>In Task 3 and 4, we used the code <code>plot.py</code>. This code uses the matplotlib library to plot the results stored in data.txt to visualise the convergence of the total energy as the plane-wave cutoff is increased. Later in this course you will use python scripts to plot band structures and density of states. You are encouraged to examine and play around with these python codes to develop your coding skills!</p> <p>Let's take a quick look at plot.py from the <code>01_carbon_monoxide/02_kinetic_energy_cutoff</code> directory.</p> <pre><code>#############################################################################################################################################\n#############################################################################################################################################\n#############################################################################################################################################\n#        This is a plotting code. Put your data into data.txt in column format. &lt;column 1 = cutoff&gt; &lt;column 2 = total energy&gt;               #\n#                           To use this code, issue the command:                                #\n#                               python3 plot.py                                     #\n#############################################################################################################################################\n#############################################################################################################################################\n#############################################################################################################################################\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef main():\n    data = np.loadtxt(\"data.txt\") #(1)!\n\n    ecut, etot = data[:,0], data[:,1] #(2)!\n\n    plt.figure(figsize=(8, 6)) #(3)!\n    plt.scatter(ecut, etot) #(4)!\n    plt.xlabel(\"Kinetic Energy Cutoff (Ry)\")\n    plt.ylabel(\"Total Energy (eV)\")\n    plt.title(\"Total Energy Convergence\")\n    plt.show() #(5)!\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>Loading in the data that is in column format in <code>data.txt</code>.</li> <li>The first column is the plane-wave cutoff in Ry and the second column is the corresponding total energy in eV.</li> <li>Initialising the size of our figure. This allows you to control the aspect ratio of the plot.</li> <li>Scatter plot of ecut vs etot.</li> <li>After giving python all of the plotting information, we tell it to plot.</li> </ol>"},{"location":"labs/lab03/readme/#exchange-correlation-energy-functionals","title":"Exchange &amp; Correlation Energy Functionals","text":"<p>Recall that in the Kohn-Sham equations we have a term known as the exange-correlation potential. What approximation we choose for this is a key part of DFT. The functional that we use determines how we approximate the many-body interactions between the electrons.</p> <p>As we discussed earlier, the pseudopotentials that we use are built from DFT calculations of single atoms. In these DFT calculations, an exchange-correlation functional was chosen. Thus, pseudopotentials inherently contain an exchange-correlation approximation. </p> <p>Choosing an appropriate exchange-correlation functional for the system we want to study is an important consideration in every DFT calculation. This choice can have a big impact the results we obtain from our DFT calculation. </p> Levels of approximation <ul> <li>There is a hierarchy of exchange-correlation functionals. This is sometimes represented as a ladder called 'Jacob's ladder' whose lowest rung is the LDA with higher rungs being GGAs, meta-GGAs, hybrid functionals and so on.  </li> </ul> <p>By default, Quantum Espresso determines which exchange-correlation functional it should use from the pseudopotential files as discussed above. It is possible, however, to override this default by using the <code>input_dft</code> variable in the &amp;system section.</p> <p>Mixing Approximations</p> <p>It is generally not a good idea to override the default exchange-correlation functional read from the pseudopotential file. However, sometimes it may be difficult to find pseudopotentials for exotic exchange-correlation functionals. </p> <p>In <code>02_argon</code> we will calculate the total energy as function of bond length for a pair of argon atoms using two different approximations for the exchange-correlation functional: first we will use a standard GGA functional and then we will study the effect of using a correction that accounts for van der Waals interactions.</p> <p>Task 5 - Argon Dimer</p> <p>Navigate to the directory <code>02_argon/01_pbe</code>. Here you will see an input file <code>Ar2.in</code>, an argon pseudopotential file, and a python plotting code plot.py.</p> <ul> <li>Find out which approximation for the exchange-correlation functional is used by taking a look at the pseudopotential file.</li> </ul> Answer <p>This is at the GGA (pbe) level.</p> <p>Make 10 copies of the input file named Ar2_i.in where i should run from 1 to 10 in steps of 1. In each of these files we want to systematically increase the distance between Ar atoms from 3.2 to 5 in steps of 0.2. Replace <code>xxxx</code> in the ATOMIC_POSITIONS of each file to do this. You should now have files named <code>Ar2_1.in</code>, <code>Ar2_2.in</code> etc with increasing dimer distances. You have been provided with a script <code>run.sh</code> that will automate the running of <code>pw.x</code>.</p> <ul> <li> <p>Run the script <code>run.sh</code>. One finished, store the data in a text file named <code>data.txt</code> in the format: [dimer distance] [total energy].</p> </li> <li> <p>Examine the script <code>plot.py</code>. Read through the python script and try to understand what each line of code is doing.</p> </li> <li> <p>At which distance does the argon dimer have the lowest energy?</p> </li> </ul> Result <p>a = 4.0 \u00c5 gives the minimum energy of -86.2547336 Ry</p> <p>However, the minimum is very shallow.  </p> <p>Argon atoms have full electronic shells. Therefore, they cannot form chemical bonds. They only interact with weak van der Waals interactions. The PBE exchange-correlation functional does not describe these interactions well. To capture them, we will have to introduce a special van der Waals correction.</p> <p>Navigate to <code>02_vdw</code>.</p> <ul> <li>Examine the input file Ar2.in. You will see a tag <code>vdw_corr = 'grimme-d3'</code>. This means that we are going to include van der Waals corrections (via a correction term to the total energy).</li> </ul> <p>Go through the same steps as in <code>01_pbe</code>, making 10 copies of the Ar2.in named Ar2_i.in where i ranges from 1 to 10. Systematically increase the dimer distance over the same range and run the DFT calculations.</p> <ul> <li>At what distance does the argon dimer have the lowest energy?</li> </ul> Result <p>a = 3.8 \u00c5 gives the minimum energy of -86.25537711 Ry. This is in good agreement with the experimental result of 3.76 \u00c5 (see Molecular Physics, 103 (15\u201316), 2031\u20132045 (2005)).</p> <p> </p>"},{"location":"labs/lab03/readme/#more-convergence-parameters","title":"More Convergence Parameters","text":"<p>So far we have only been dealing with isolated molecules, and thus we have been running our calculations with no \\(\\bf{k}\\) dependence. However, if we are dealing with crystals, which are periodic, then we need to sample the Briouillin zone with 'k points'. This will be covered in Lab 4. The number of k points used to sample the Briouillin zone should also be converged when dealing with periodic crystals.</p>"},{"location":"labs/lab03/readme/#summary","title":"Summary","text":"<p>In this lab we gained a deeper understanding of the interrelated concepts of plane waves, pseudopotentials and periodic boundary conditions. We also learned about the importance of converging the results of our calculations with respect to the total energy threshold, the plane-wave cutoff and the box size:</p> <ul> <li>Convergence of any physical quantity of interest is achieved by systematically varying the relevant convergence parameters and making sure their values are chosen such that physically meaning results are obtained.</li> </ul> <p>We also learned about the importance of choosing an appropriate exchange-correlation functional for the system we want to study.</p>"},{"location":"labs/lab04/readme/","title":"Crystals and the Electronic Band Structure","text":"<p>This week we are going to start doing some calculations on solids, i.e., periodic crystals. Many of the principles will be the same, but as you will see there are a few things that need to be done differently. </p> <p>As before, all the inputs and scripts you need can be found in <code>/opt/MSE404-MM/docs/labs/lab04</code> and you should copy the folder to your home directory.</p>"},{"location":"labs/lab04/readme/#basic-input-for-diamond","title":"Basic input for Diamond","text":"<p>As our first example of a crystalline solid we're going to look at diamond. You can find the input file at C_diamond.in, here I'll give a brief overview of it:</p> <pre><code>&amp;CONTROL\n   pseudo_dir = '.' \n   disk_io = 'none' \n/\n\n&amp;SYSTEM\n   ibrav = 2 #(1)!\n   A = 3.567\n   nat = 2\n   ntyp = 1\n   ecutwfc = 20.0\n/\n\n&amp;ELECTRONS\n   conv_thr = 1.0E-6\n/\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal #(2)!\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\nK_POINTS automatic #(3)!\n  4 4 4 1 1 1\n</code></pre> <ol> <li><code>ibrav=2</code> specifies a FCC unit cell (for a complete list of <code>ibrav</code>, see     input     descriptions).</li> <li><code>crystal</code> specifies that the atomic positions are given in fractional     coordinates of the unit cell vectors (defined by <code>ibrav</code> and     <code>A</code>).</li> <li> <p>We are using automically generated k-point grid with a 4\\(\\times\\)4\\(\\times\\)4     grid size, <code>1 1 1</code> means to shift the grid by one half of a grid spacing in     each direction. By default, the k-point grid is generated such that the grid     is centered around the origin of the reciprocal lattice vectors (\\(\\Gamma\\)     point).</p> K-point Shift <p>The k-point shift is a trick that can speed up the calculation by including less k-points in the calculation. This is because only k-points in the irreducible Brillouin zone are calculated, and shifting the grid can help to sample the entire Brillouin zone with fewer points.</p> <p> </p> </li> </ol>"},{"location":"labs/lab04/readme/#k-points","title":"k-points","text":"<p>One important difference between periodic crystals and molecules is that the electronic states are not localised and their wavefunction is given by Bloch's theorem: </p> \\[ \\psi_{n\\mathbf{k}}(\\mathbf{r}) = e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{n\\mathbf{k}}(\\mathbf{r}), \\] <p>where the electronic states are labelled by both the band index \\(n\\) and the k-point \\(\\mathbf{k}\\). As discussed in the lecture, \\(\\mathbf{k}\\) lies in the first Brillouin zone. </p> <p>The additional card <code>K_POINTS</code> in the input file specifies the k-point grid. The first three numbers <code>4 4 4</code> represent how many k-points are generated along each direction of the reciprocal lattice vectors. </p> <p>The fineness of the k-point grid is a convergence parameters and we must make sure that it is sufficiently fine such that physically meaningful results are obtained.</p>"},{"location":"labs/lab04/readme/#structure-parameters-for-crystals","title":"Structure Parameters for Crystals","text":"<p>Now let's take a look at how the atomic positions in the unit cell are specified in the input file.</p> <p>Quantum Espresso allows us to express the atomic positions either in absolute Cartesian coordinates \\((x,y,z)\\) or alternatively in crystal coordinates \\((x_c,y_c,z_c)\\). The position vector of the atom can then be obtained from the lattice vectors \\(\\mathbf{a},\\mathbf{b},\\mathbf{c}\\) as follows:</p> \\[ \\begin{align}  \\mathbf{r} = x_c \\mathbf{a} + y_c \\mathbf{b} + z_c \\mathbf{c}  \\end{align} \\] <p>For diamond, which has the same atomic structure as Zinc Blende, the atomic structure looks like this:</p> <p>To specify the shape of the primitive unit cell, we first set <code>ibrav=2</code>, i.e. face-centred cubic (fcc) Bravais lattice. Internally, with <code>ibrav=2</code>, Quantum ESPRESSO sets the the fcc lattice vectors as:</p> \\[ \\begin{align*} \\mathbf{a} &amp;= \\frac{A}{2}(-1,0,1)\\\\ \\mathbf{b} &amp;= \\frac{A}{2}(0,1,1)\\\\ \\mathbf{c} &amp;= \\frac{A}{2}(-1,1,0) \\end{align*} \\] <p>Warning</p> <p>Note that here we are using the experimentally measured lattice constant <code>A</code> of 3.567 \u00c5 which might not be the same as the DFT optimized value. In later labs we'll see how to find the lattice constant predicted by DFT.</p> <p>In terms of these lattice vectors, the crystal coordinates of the two carbon atoms are (as we see in the input file, indicated by <code>ATOMIC_POSITIONS crystal</code>):</p> \\[ \\begin{align*} \\mathbf{r}_c^{C1} &amp;= (0,0,0) \\\\ \\mathbf{r}_c^{C2} &amp;= (\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}) \\end{align*} \\] <p>Hence, the absolute Cartesian coordinates for the two carbon atoms are given by:</p> \\[ \\begin{align*} \\mathbf{r}^{C1} &amp;= \\frac{A}{2}(-1,0,1) \\times 0 + \\frac{A}{2}(0,1,1) \\times 0 + \\frac{A}{2}(-1,1,0) \\times 0\\\\  &amp;= (0,0,0)\\\\ \\mathbf{r}^{C2} &amp;= \\frac{A}{2}(-1,0,1) \\times \\frac{1}{4} + \\frac{A}{2}(0,1,1)  \\times \\frac{1}{4}+ \\frac{A}{2}(-1,1,0) \\times \\frac{1}{4} \\\\ &amp;= (\\frac{A}{4},\\frac{A}{4},\\frac{A}{4}) \\end{align*} \\] <p>Task 1 - Examining input &amp; output files</p> <p>Run <code>pw.x</code> for the carbon diamond inside the <code>01_carbon_diamond</code> directory. There are a couple of extra things to notice in the output file:</p> <ul> <li> <p>The output lists the automatically generated k-points. How many k-points    are there and why?</p> Answer <p>We requested a 4\\(\\times\\)4\\(\\times\\)4 grid but instead in the ouput file indicates 10 k-points are being used. This is because Quantum Espresso uses crystal symmetries to relate certain k-points and to reduce the computational load.</p> </li> <li> <p>What are the eigenvalues?</p> Answer <p>For periodic systems, we have a set of band energies for each  k-point. And these are given in the output file: <pre><code>      k =-0.1250 0.1250 0.1250 (   116 PWs)   bands (ev):\n\n-7.3461  11.5621  13.5410  13.5410\n\n      k =-0.3750 0.3750-0.1250 (   116 PWs)   bands (ev):\n\n-5.1246   6.0725   9.6342  12.3836\n\n      k = 0.3750-0.3750 0.6250 (   117 PWs)   bands (ev):\n\n-2.0454   1.1023   9.9094  10.6497\n\n      k = 0.1250-0.1250 0.3750 (   120 PWs)   bands (ev):\n\n-6.2574   8.8031  11.2205  12.0763\n\n      k =-0.1250 0.6250 0.1250 (   118 PWs)   bands (ev):\n\n-4.0419   6.4510   8.7237   9.1414\n\n      k = 0.6250-0.1250 0.8750 (   111 PWs)   bands (ev):\n\n 0.0174   2.6697   5.4037   7.5509\n\n      k = 0.3750 0.1250 0.6250 (   115 PWs)   bands (ev):\n\n-2.9709   4.0228   7.6281   9.9651\n\n      k =-0.1250-0.8750 0.1250 (   114 PWs)   bands (ev):\n\n-0.7739   3.2191   6.5088   8.0627\n\n      k =-0.3750 0.3750 0.3750 (   114 PWs)   bands (ev):\n\n-4.0297   3.1416  11.7036  11.7036\n\n      k = 0.3750-0.3750 1.1250 (   114 PWs)   bands (ev):\n\n-1.0562   2.2032   6.0516   9.9570\n</code></pre></p> </li> </ul>"},{"location":"labs/lab04/readme/#convergence-test-for-k-point-grid-above-we-used-a-uniform","title":"Convergence Test for K-Point Grid Above, we used a uniform","text":"<p>4\\(\\times\\)4\\(\\times\\)4 k-point grid to sample the first Brillouin zone. However, to really converge a periodic system, an additional convergence test with respect to the k-point sampling is necessary.</p> <p>To test the convergence of our results with respect to the size of the k-point grid, we need to calculate the total energy for different grid sizes. </p> <p>Task 2 - Convergence with respect to k-point sampling and cut-off energy</p> <ul> <li> <p>The directory <code>02_convergence</code> contains input files to calculate the total   energy. Change the k-point grid size in the input file, run the DFT   calculation and see how the total energy changes. For example, perform a   series of calculations with k-point grids set to <code>2 2 2</code>, <code>4 4 4</code>, <code>6 6   6</code>, ..., all the way to <code>30 30 30</code> and see how the total energy changes.   If you have any trouble doing so, you can always go back to   lab03 for help.</p> Result <p>To obtain a total energy per atom which is converged to within 10 meV/Atom, we need at least a 10\\(\\times\\)10\\(\\times\\)10 k-point grid. </p> </li> <li> <p>For every periodic system you simulate, you should converge both the   plane-wave cut-off energy and k-point grid size. To do this, one usually   starts with one parameter set to a very high value and then varies the   other one. Then one repeats this with switched roles. Try do this yourself   and find the best set of parameters for diamond.</p> Tips <p>Try starting with <code>ecutwfc</code> of ~60.0 Ry and converge the k-points.  Or start with k-points of 30\\(\\times\\)30\\(\\times\\)30 and converge the plane-wave cutoff.</p> </li> </ul>"},{"location":"labs/lab04/readme/#the-electronic-band-structure","title":"The Electronic Band Structure","text":""},{"location":"labs/lab04/readme/#what-is-the-electronic-band-structure","title":"What is the Electronic Band Structure?","text":"<p>We know that, while the electronic density obtained from DFT is meaningful, the Kohn-Sham states are not strictly the electronic states of the system. Nonetheless, they are in practice often a good first approximation of the electronic states of a system, so can be useful in understanding the properties of a system.</p> <p>We have seen how to converge our calculations with respect to the k-point grid size (task 2), and have found in task 1 that the calculated energy eigenvalues are a bit different at each calculated k-point. Now we want to study how exactly these eigenvalues change as we move from one k-point to the next.</p> <p>Examining how the Kohn-Sham energies change from one k-point to the next can tell us useful things such as if a material is likely to have a direct or indirect optical gap. For this it is useful to visualize how the energies change along a k-point path in the first Brillouin zone. The usual way this is done is to plot the band energies along lines between the various high-symmetry k-points in the Brillouin zone. For example, a high symmetry path for a face-centred cubic (FCC) lattice (see figure below) could be <code>\u0393\u2014X\u2014U|K\u2014\u0393\u2014L\u2014W\u2014X</code>:</p> Finding High Symmetry Points and Paths <p>The details of how such path can be found is beyond the scope of this  course, but an outline is given  here.</p>"},{"location":"labs/lab04/readme/#calculating-the-electronic-band-structure","title":"Calculating the Electronic Band Structure","text":"<p>The directory <code>03_bandstructure</code> contains input files to calculate and plot the band structure of diamond. This a four-step process:</p>"},{"location":"labs/lab04/readme/#step-1-scf-calculation","title":"Step 1 - SCF Calculation","text":"<p>The first step is to calculate a converged electron density with a standard self-consistent field (SCF) calculation. In this step, the electron density is optimized in order to minimize the total energy of the system. The input file can be found at 01_C_diamond_scf.in. </p> <p>Task 3.1 - SCF Calculation</p> <p>Run the input file 01_C_diamond_scf.in to calculate the ground state electron density. <pre><code>pw.x &lt; 01_C_diamond_scf.in &gt; 01_C_diamond_scf.out\n</code></pre></p>"},{"location":"labs/lab04/readme/#step-2-nscfbands-calculation","title":"Step 2 - NSCF(bands) Calculation","text":"<p>The second step is to use the obtained electron density to construct the Kohn-Sham Hamiltonian at a set of k-points along the path we want to study and to calculate the Kohn-Sham eigenvalues at those k-points. This is called a non-self-consistent field (NSCF) calculation as the charge density is kept fixed. </p> <p>A brief overview of the  input file is  given below:</p> <pre><code>&amp;CONTROL\n pseudo_dir = '.'\n calculation = 'bands' #(1)!\n/\n\n&amp;SYSTEM\n   ibrav =  2\n   A = 3.567\n   nat =  2\n   ntyp = 1\n   ecutwfc = 30.0\n   # Also add 4 additional bands (unoccupied states)\n   nbnd = 8 #(2)!\n/\n\n&amp;ELECTRONS\n/\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\n# Path here goes: \u0393 X U|K \u0393 L W X\nK_POINTS crystal_b #(3)!\n  8\n  0.000 0.000 0.000 30 \u0393\n  0.500 0.000 0.500 30 X\n  0.625 0.250 0.625 00 U\n  0.375 0.375 0.750 30 K\n  0.000 0.000 0.000 30 \u0393\n  0.500 0.500 0.500 30 L\n  0.250 0.500 0.750 30 W\n  0.500 0.500 1.000 00 X\n</code></pre> <ol> <li><code>calculation = 'bands'</code> specifies that we are calculating the band     structure.</li> <li><code>nbnd = 8</code> specifies that we want to calculate 8 bands. 4 more bands than     the default value of 4. We add these bands so that we can calculate the band     gap later.</li> <li><code>K_POINTS crystal_b</code> specifies that we express the high-symmetry k-points     in crystal coordinates. The number of high-symmetry k-points     is 8, followed by the crystal coordinates of each k-point and the number of     points to generate along the section of the path that connects this k-point     to the next one in the list. </li> </ol> <p>Since diamond has a face-centred cubic (FCC) lattice, we have chosen the path <code>\u0393-X-U|K-\u0393-L-W-X</code> where <code>U|K</code> means no k-point is sampled between <code>U</code> and <code>K</code>.</p> <p>Task 3.2 - NSCF Calculation</p> <p>Run the input file 02_C_diamond_nscf.in to get the eigenvalues of each band at each k-point. <pre><code>pw.x &lt; 02_C_diamond_nscf.in &gt; 02_C_diamond_nscf.out\n</code></pre> Take a look at the output, can you find where it says the charge density is read?</p> Answer <pre><code>The potential is recalculated from file :\n./pwscf.save/charge-density\n</code></pre>"},{"location":"labs/lab04/readme/#step-3-extracting-band-energies","title":"Step 3 - Extracting Band Energies","text":"<p>Now we need to extract the Kohn-Sham energies from the output file and convert them into a dataset we can plot.</p> <p>To do this, we use the <code>bands.x</code> tool from the Quantum Espresso package. The input file for <code>bands.x</code> contains only a <code>BANDS</code> section. For more fine-grained control please refer to  bands.x input description.</p> <p>Task 3.3 - Extracting band energies</p> <p>Run the input file 03_C_diamond_bands.in with <code>bands.x</code> to extract and organize the eigenvalues calculated in the last step.  <pre><code>bands.x &lt; 03_C_diamond_bands.in &gt; 03_C_diamond_bands.out\n</code></pre></p>"},{"location":"labs/lab04/readme/#step-4-plotting-the-band-structure","title":"Step 4 - Plotting the Band Structure","text":"<p>Finally, we are ready  to plot the band structure. The band structure is typically plotted with the energy on the y-axis and the high-symmetry k-points on the x-axis. The energy is usually shifted so that the valence band maximum is at 0 eV. The directory <code>03_bandstructure</code> contains a python script (<code>plotband_shifted.py</code>) that can be used to plot the band structure.</p> <p>Task 3.4 - Plotting the band structure</p> <p>Run the python script to plot the band structure of carbon diamond.  <pre><code>python plotband_shifted.py\n</code></pre> Download the output file <code>C_diamond_bands.png</code> and take a look at it. Is carbon diamond a metal or an insulator? At which k-points is the valence band maximum and the conduction band minimum? How large is the band gap (and is it direct or indirect)?</p> Final result <p> </p> <p>From the graph we can see that the valence band maximum is at \u0393 (the first point on our path), the conduction band minimum is located between \u0393 and X and the size of the indirect band gap is around 4 eV (note that this is significantly smaller than the experimentally measured band gap of diamond). Note that here we have shifted the entire spectrum so that this point is at 0 eV.</p>"},{"location":"labs/lab04/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we learned how to:<ul> <li>achieve k-point convergence in solids.</li> <li>calculate the electronic band structure of a solid.</li> </ul> </li> <li>We have seen how several calculations may be chained together where the   output of one is used as an input for the next one.</li> <li>We should always keep in mind that the Kohn-Sham eigenvalues obtained from a   DFT calculation do not correspond to the energy levels of the real interacting   electrons, but are often useful as a first approximation.</li> </ul>"},{"location":"labs/lab05/readme/","title":"Metals and the Density of States","text":"<p>This week we will study the electronic structure of metals and the electronic density of states. Solving the Kohn-Sham equation for metals requires some additional considerations compared to the case of semiconductors and insulators which we studied in the last lab.</p> <p>As before, all the input files and scripts you need can be found in <code>/opt/MSE404-MM/docs/labs/lab05</code> and you should copy this folder to your home directory.</p>"},{"location":"labs/lab05/readme/#density-of-states","title":"Density of States","text":"<p>The electronic density of states (DOS) contains information about the number of electronic states with certain energies. Mathematically, it is defined as </p> \\[  \\mathrm{DOS}(E) = \\sum_{n} \\sum_{\\mathbf{k}} w_{\\mathbf{k}}                   \\delta(E - \\epsilon_{n\\mathbf{k}}), \\] <p>where \\(\\epsilon_{n\\mathbf{k}}\\) are the Kohn-Sham eigenvalues for band \\(n\\) and k-point \\(\\mathbf{k}\\), \\(w_{\\mathbf{k}}\\) is the k-point weight to keep the total integrated DOS to be the number of bands. I.e., </p> \\[ \\int_{-\\infty}^{\\infty} \\mathrm{DOS}(E) dE = \\#\\mathrm{bands} \\] <p>Note that the sum over k-points can be replaced by an integral if the grid is sufficiently fine.</p> <p>For a molecular system, the DOS consists of a series of discrete peaks at the energies of the molecular Kohn-Sham orbitals, since we only use one k-point (the \\(\\Gamma\\) point) for DFT calculations of isolated molecules. In contrast, for DFT calculations of crystals, we use many k-points to sample the first Brillouin zone and in this case the discrete peaks merge to form a continous curve. For example, here are graphs of the DOS of a water molecule (isolated molecule) and carbon diamond (periodic crystal):</p> <p>The shape of the DOS is intimately connected to the band structure of a crystal: bands with a strong dispersion (i.e. the Kohn-Sham energies change rapidly along a path in k-space) result in low DOS spread over a large interval, whereas less dispersive (i.e. flatter) bands result in high DOS in a smaller energy interval. </p> Van Hove Singularity <p>While the DOS is a continuous function, there can be sharp peaks in the DOS that breaks the smoothness of the curve. These are called Van Hove singularities and they occur when the band structure has a saddle point or an inflection point. They are important because they can lead to interesting properties in optical absorption spectra of materials.</p> <p> </p> <p>For insulators and semiconductors, the DOS is zero inside the band gap, as there are no Kohn-Sham states in that energy range. Hence, the DOS allows us to determine the band gap of a crystal (unlike a band structure plot which only shows the KS energies along a specific path in the Brillouin zone, the DOS contains information about the KS energies at all k-points in the first Brillouin zone).</p>"},{"location":"labs/lab05/readme/#smearing","title":"Smearing","text":"<p>To evaluate the equation for the DOS of a crystal numerically, we have to replace the delta-functions by functions with a finite width, such as a Gaussian (otherwise the DOS will always look like a set of sharp peaks). This is called \"smearing\". </p> <p>The width of the Gaussian is a parameter that needs to be tuned to ensure that a physically meaningful result is obtained: </p> <ul> <li>If the broadening is too large, you may smear out important   features of the DOS.</li> <li>If the broadening is too small, you will see some unphysical peaks in the DOS   and it will look very spikey.</li> <li>In principle you want the smearing to be comparable to the typical   difference of Kohn-Sham energies at neighboring k-points. In practice,   however, it is often easier to just try different values for the broadening   until the DOS looks physically meaningful.</li> </ul> Tetrahedron Method <p>Another way to obtained an accurate DOS is to linearly interpolate the calculated Kohn-Sham energies using the so-called tetrahedron method. Such a calculation is noticeably slower than using a broadening but there is no need to to worry about using the correct smearing. Your only convergence parameter is the fineness of the k-point grid you use which determines how accurate the interpolation is.</p> <p>It's important to note that in a real measurement of the density of states of material (for example, using photoemission spectroscopy), there is always some broadening coming from</p> <ol> <li> <p>Electron-phonon coupling: since the atoms in a real material vibrate      around their equilibrium positions, the energies of the electronic      states will be smeared out.</p> </li> <li> <p>Any measurement apparatus will have a finite energy resolution which      will further broaden the measured DOS. </p> </li> </ol>"},{"location":"labs/lab05/readme/#calculating-the-dos","title":"Calculating the DOS","text":"<p>In a similar way to the electronic band structure, we produce the density of  states plot in three steps.</p>"},{"location":"labs/lab05/readme/#step-1-scf-calculation","title":"Step 1 - SCF Calculation","text":"<p>Perform a self-consistent calculation as before to produce a converged charge density.</p> <p>Task 1.1 - SCF Calculation</p> <p>Run <code>pw.x</code> using the input file 01_C_diamond_scf.in for diamond. <pre><code>pw.x &lt; 01_C_diamond_scf.in &gt; 01_C_diamond_scf.out\n</code></pre></p>"},{"location":"labs/lab05/readme/#step-2-nscf-calculation","title":"Step 2 - NSCF Calculation","text":"<p>Take the density calculated in the previous step and use it to perform a non-self-consistent calculation on a denser k-point grid. We want an accurate description of how the KS energies vary as we move around the Brillouin zone so we use a much denser grid here than we need to obtain the converged density in the previous step.</p> <p>The difference between this and the band structure calculation is that here we use a uniform sampling of the Brillouin zone, rather than a path between k-points. The input file for this calculation can be found at 02_C_diamond_nscf.in:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    calculation = 'nscf' #(1)!\n /\n\n &amp;SYSTEM\n    ibrav =  2\n    A = 3.567\n    nat =  2\n    ntyp = 1\n    ecutwfc = 60.0\n    # Add 4 conduction bands\n    nbnd = 8 #(2)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\nK_POINTS automatic #(3)!\n  20 20 20  0 0 0\n</code></pre> <ol> <li><code>calculation = nscf</code> specifies that we are calculating the      non-self-consistent calculation.</li> <li><code>nbnd = 8</code> specifies that we want to calculate 8 bands.</li> <li><code>K_POINTS automatic</code> specifies that we are using an automatically generated     k-point grid. We've increased the k-point sampling to a 20x20x20 grid, and     we have removed the shift (without a shift, Quantum Espresso uses the     convention that the gide always includes the origin, for more information     see this). Many systems have     a valence band maximum or conduction band minimum at the gamma point, so it     is good to ensure it's explicitly included in the grid.</li> </ol> <p>Task 1.2 - NSCF Calculation</p> <p>Run <code>pw.x</code> using the input file 02_C_diamond_nscf.in for diamond. <pre><code>pw.x &lt; 02_C_diamond_nscf.in &gt; 02_C_diamond_nscf.out\n</code></pre></p>"},{"location":"labs/lab05/readme/#step-3-density-of-states-calculation","title":"Step 3 - Density of States Calculation","text":"<p>From the Kohn-Sham energies calculated on the dense k-point grid we then calculate the density of states using <code>dos.x</code>. 03_C_diamond_dos.in is the input file for <code>dos.x</code> and contains just a <code>DOS</code> section. What this input file instruct <code>dos.x</code> to do is to discritise an energy range <code>Emin</code> and <code>Emax</code> using an interval of <code>DeltaE</code> and at each energy calculate the DOS using the formula given above. Each delta function is replaced using a gaussian function (which can be replace by other functions using <code>ngauss</code> tag) with a width of <code>degauss</code>.</p> <pre><code> &amp;DOS\n  degauss = 0.03 #!(1)!\n  DeltaE = 0.1 #(2)!\n /\n</code></pre> <ol> <li><code>degauss</code> specifies the Gaussian broadening (in Rydberg) to use in the     density of states calculation.</li> <li><code>DeltaE</code> specifies the spacing between energies at which the DOS is     calculated, in eV.</li> </ol> <p>Note</p> <p>We have picked similar values for <code>degauss</code> and <code>DeltaE</code> (after converting them to the same units). In fact if <code>degauss</code> is not specified, and no broadening scheme is used in the DFT calculation, <code>degauss</code> will take the value of <code>DeltaE</code> by default. You can check the documentation  INPUT_DOS for more details.</p> <p>Task 1.3 - Plotting Density of States</p> <p>Run <code>dos.x</code> using the input file 03_C_diamond_dos.in for diamond. <pre><code>dos.x &lt; 03_C_diamond_dos.in &gt; 03_C_diamond_dos.out\n</code></pre></p> <p>The final step produces a file named <code>pwscf.dos</code> by default. This is a simple text file you can plot. It has three columns: Energy (eV), Density of States (states/eV), and Integrated Density of States (states) up until that energy. And in the first line, the estimated Fermi energy is also given.</p> <pre><code>#  E (eV)   dos(E)     Int dos(E) EFermi =   13.180 eV \n  -9.334  0.2778E-06  0.2778E-07\n  -9.234  0.1274E-05  0.1552E-06\n  -9.134  0.5226E-05  0.6778E-06\n  -9.034  0.1919E-04  0.2597E-05\n  ...\n</code></pre> <p>It is customary to shift the x-axis in the plot such that the Fermi energy or valence band maximum is at 0. A value for the Fermi level is given in the file header of <code>pwscf.dos</code>. This value is determined in a simple way from the integrated density of states. Sometimes, it may be worth calculating the Fermi level in a separate calculation using a relatively small broadening if you're studying a metallic system (as we shall see later). For semiconductors and insulators you can determine the valence band maximum energy from the output file. </p> Fermi Energy From The Integrated Density of States <p>The integrated density of states is the number of states up to a certain energy. I.e., \\(\\int_{-\\infty}^{E_1} DOS(E) d(E)\\). One can easily found the Fermi energy by looking at the energy where the integrated density of states is equal to the number of electrons in the system. However, it is worth noting that since we are using a smearing scheme and a denser k-point grid in the NSCF step (which is not the case for the SCF calculation), the Fermi energy calculated in this way may not be accurate. For accurate Fermi energy, one should always refer to the output of the SCF calculation.</p> <p>The directory <code>03_densityofstates</code> contains a python script that can be used to plot the shifted DOS together with the integrated DOS.</p> <p>Task 1.4 - Density of States Calculation</p> <p>Plot the density of states using the script provided. <pre><code>python plotdos_shifted.py\n</code></pre></p> DOS Plot <p> </p> <p>Now try re-running Tasks 1.3 and 1.4 with different <code>degauss</code> values and see how the DOS plots change. Does the change match your expectations?</p>"},{"location":"labs/lab05/readme/#metals","title":"Metals","text":"<p>Metals have a Fermi surface in k-space which separates the occupied from the unoccupied Kohn-Sham states. The shape of the Fermi surface can be quite complicated and is not known a priori. This means that in contrast to insulators or semiconductors where every k-point has the same number of occupied states, in a metal the number of occupied states can vary from k-point to k-point. This makes it more difficult to calculate the electron density which involves a summation of the squared magnitudes of the wavefunctions of all occupied states. </p>"},{"location":"labs/lab05/readme/#tackling-discontinuities","title":"Tackling Discontinuities","text":"<p>Generally, there are two things that we typically do for metals to help with the convergence of the SCF calculation:</p> <ol> <li> <p>Use a denser k-point grid than you would need for a semiconductor or     insulator. This allows us to have a better description of the complex Fermi     surface that metals have.</p> </li> <li> <p>Use a smearing scheme for the calculation of the occupation number of     Kohn-Sham states at each k-point. Instead of having a integer occupation     number of each band (0 or 1), we now allow a fractional occupation number so     that the occupation number varies smoothly across k-points. </p> Charge Sloshing Effect <p>Without occupation smearing, each band is either fully occupied or unoccupied. At each step of the SCF loop, bands may switch between being occupied and occupied, leading to a large change in the electron density which can slow down the convergence of the SCF calculation.</p> <p>One way to obtain smeared occupation numbers is to calculate them using the Fermi-Dirac distribution \\(f_T(\\epsilon_{n\\mathbf{k}})\\) at a finite temperature \\(T\\)</p> \\[ f_T(E) = \\frac{2}{e^\\frac{E-E_F}{k_B T} + 1}, \\] <p>where \\(E_F\\) denotes the Fermi energy which we set to the energy of the highest occupied Kohn-Sham state and the factor of 2 results from the Pauli principle. We can calculate the Fermi level using the condition that the sum over all occupation numbers must be equal to the total number of electrons \\(N_e\\) in the cell(\\(w_\\mathbf{k}\\) is the weight of the k-point):</p> \\[ N_e = \\sum_n \\sum_\\mathbf{k} w_\\mathbf{k} f_T(\\epsilon_{n\\mathbf{k}}). \\] <p>At low temperatures, the Fermi-Dirac distribution becomes a discontinous step function. So we must choose the temperature to be sufficiently high to ensure smooth occupation numbers near the Fermi surface (using the tag <code>degauss</code> in the input file). It is worth noting that other smearing methods, such as Gaussian smearing.</p> <p>Using a smearing scheme for the occupation numbers helps significantly in achieving a smooth SCF convergence for metals, as otherwise a small change in the energy of a KS state from one self-consistent iteration to the next one could lead to a very large change in its occupation number and to the electron density. We set the smearing scheme (for both DOS and occupation function) and width with the <code>occupations</code> and <code>degauss</code> variables in the input file.</p> <p>Additional read</p> <p>For a thorough review of the most typical smearing method used in DFT, have a read at this paper. </p> </li> </ol>"},{"location":"labs/lab05/readme/#example-aluminium","title":"Example: Aluminium","text":"<p>Aluminium has an FCC crystal structure with one atom per unit cell, which we know how to deal with at this point. The thing about Aluminium that makes it more complicated within DFT is that it is a metal.</p> <p>Here is an example input file for a SCF calculation of Aluminium:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    verbosity = 'high' #(1)!\n /\n\n &amp;SYSTEM\n    ibrav =  2\n    A = 2.863\n    nat =  1\n    ntyp = 1\n    ecutwfc = 18.0\n    occupations = 'smearing' #(2)!\n    smearing = 'fermi-dirac' #(3)!\n    degauss = 0.1d0 #(4)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n Al  26.982  Al.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n Al 0.00 0.00 0.00\n\nK_POINTS automatic\n  8 8 8 1 1 1\n</code></pre> <ol> <li>The <code>verbosity</code> variable is set to <code>high</code> to give more information about       the SCF calculation, including occupation of the bands at each k-point.</li> <li>The <code>occupations</code> variable is set to <code>smearing</code> to tell Quantum Espresso       to use a smearing scheme input        description.</li> <li>The <code>smearing</code> variable is set to <code>fermi-dirac</code> to tell Quantum Espresso       to use a Fermi-Dirac smearing scheme. input       description. </li> <li>The <code>degauss</code> variable is set to 0.1d0 to set the width of the smearing.       see input       description.</li> </ol> <p>Task 2.1 - Smearing for Metals</p> <p>First, run the <code>pw.x</code> calculation with the supplied input file in 02_aluminium/Al.in.</p> <p>Then, take a look at the output file. Can you find the Kohn-Sham eigenvalues at each k-point and the corrresponding occupations number.</p> Example <p>```   k =-0.0625 0.0625 0.0625 (    59 PWs)   bands (ev):</p> <p>3.5809  40.9721  43.7477  43.7477  49.9157  53.1364</p> <p>occupation numbers   1.0000   0.0000   0.0000   0.0000   0.0000   0.0000</p> <pre><code>  k =-0.1875 0.1875-0.0625 (    58 PWs)   bands (ev):\n</code></pre> <p>4.7127  35.0485  40.5915  44.7949  50.9368  50.9459</p> <p>occupation numbers   1.0000   0.0001   0.0000   0.0000   0.0000   0.0000      ...      ```</p> <p>For a metal the default number of bands that are used in the SCF calculation is at least four more than are needed to accommodate all electrons (even without us setting the <code>nband</code> tag). The pseudopotential we have used for aluminium has 3 valence electrons, which could be accommodated in two bands. Adding the four extra bands, this gives a total of 6 bands which are used in the calculation. </p> <p> </p> <p>Now, try to play around with the <code>degauss</code> value and see how the  occupations change. Does it match your expectations?</p> <p>Now you know how to use smearing to help with the convergence of a metal, you can obtain the density of states and band structure of a metal just as easy. </p> <p>Task 2.2 - DOS of Aluminium</p> <p>Try calculating the density of states of Aluminium by following Tasks 1.1 to 1.4. Remember to change the Fermi energy in the python script to the correct value. Can you find an energy gap? Where does the Fermi level lie?</p> DOS Plot <p> </p> <p>Task 2.3 - Band Structure of Aluminium</p> <p>Try calculate the band structure of Aluminium following the path of:  <pre><code># Path here goes: \u0393 X U|K \u0393 L W X\nK_POINTS crystal_b\n0.0000000000     0.0000000000     0.0000000000 30    \u0393\n0.5000000000     0.0000000000     0.5000000000 30    X \n0.6250000000     0.2500000000     0.6250000000 00    U \n0.3750000000     0.3750000000     0.7500000000 30    K \n0.0000000000     0.0000000000     0.0000000000 30    \u0393\n0.5000000000     0.5000000000     0.5000000000 30    L \n0.5000000000     0.2500000000     0.7500000000 30    W \n0.5000000000     0.0000000000     0.5000000000 00    X \n</code></pre>  You can always refer back to lab04 for  reference. Remember to change the number of bands to and the Fermi energy  in the plotting script.</p> Band Structure Plot <p> </p>"},{"location":"labs/lab05/readme/#summary","title":"Summary","text":"<p>In this tutorial, we have learned:</p> <ul> <li>How to use the <code>dos.x</code> code from the Quantum Espresso package.</li> <li>How to treat a metallic system.</li> </ul>"},{"location":"labs/lab05/01_densityofstates/","title":"Using python","text":"<ol> <li> <p>run pw.x for each input file: <pre><code>pw.x &lt; 01_C_diamond_scf.in &amp;&gt; 01_C_diamond_scf.out\npw.x &lt; 02_C_diamond_nscf.in &amp;&gt; 02_C_diamond_nscf.out\ndos.x &lt; 03_C_diamond_dos.in &amp;&gt; 03_C_diamond_dos.out\n</code></pre></p> </li> <li> <p>plot <pre><code>python plotdoss_shifted.py\n</code></pre></p> </li> </ol>"},{"location":"labs/lab06/readme/","title":"Spin Polarization and Magnetic Systems","text":"<p>This week we'll cover the topic of spin-polarized systems. For metals, there are a couple of complications which mean we have to treat them differently from systems with a non-zero band gap. </p> <p>As before, all inpus and scripts you need can be found in <code>/opt/MSE404-MM/docs/labs/lab06</code> and you should make a copy of the folder to your home directory.</p>"},{"location":"labs/lab06/readme/#spin-polarization","title":"Spin Polarization","text":"<p>Until now we have assumed that the electronic states are the same for up-spin and down-spin electrons: in other words, we assumed that each state can be occupied by two electrons. In a magnetic system, however, the electronic wavefunctions (and the corresponding Kohn-Sham energies) can be different for electrons with different spins. </p>"},{"location":"labs/lab06/readme/#the-oxygen-molecule","title":"The Oxygen Molecule","text":"<p>An oxygen molecule has an even number of electrons.So you might expect that a certain number of Kohn-Sham states are filled with two electrons and therefore the total number of up-spin electrons is equal to the total number of down-spin electrons. This is, however, not true. </p> <p></p> <p>When the two oxygen atoms are sufficiently close to each other so that their atomic orbitals start to overlap, new states - called molecular orbitals - are formed. These are called \\(\\sigma_s\\), \\(\\sigma_s^*\\), \\(\\sigma_z\\), \\(\\pi_x\\), \\(\\pi_y\\) and so on. As a consequence of the symmetry properties that the molecule possesses, some of the molecular orbitals have the same energies. In Quantum Mechanics, such wavefunctions are called degenerate. You can see from the molecular orbital diagram below that the \\(\\pi_x\\) and \\(\\pi_y\\) orbitals are degenerate and also the \\(\\pi_x^*\\) and the \\(\\pi_y^*\\) orbitals have the same energy.   </p> <p>When we fill these molecular orbitals with electrons, we end up with two electrons that we can distribute in the \\(\\pi_x^*\\) and \\(\\pi_y^*\\) orbitals. It turns out that the repulsive interaction between electrons favors a state in which the two electrons sit in different molecular orbitals, but have the same spin. This is known as Hund's Rule. Note that a similar situation occurs in an isolated oxygen atom.</p> <p>The directory <code>01_O2</code> contains an input file to calculate the total energy of the oxygen molecule at the experimentally measured bond length. Here the calculation has been set up exactly as you've seen in the past (i.e., assuming doubly degenerate band occupation without smearing or spin polarization):</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <p>Task 1.1 - Assming Spin Degenerate Insulator</p> <p>Try running the calculation in this directory. Does it converge?</p> Answer <p>While it's possible that the system may randomly meet the convergence criteria in the self-consistent cycle, this calculation will most likely not converge. If you look at the estimate accuracy at the end of each iteration in the output, it will likely vary from step to step, rather than steadily decreasing as in a well-behaved calculation.</p> <p>To help converge the system, we can smear the occupancies (as we do in a DFT calculation for a metal). This will allow the system to converge. The relevant input variables are the ones highlighed below:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    verbosity = 'high'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n   occupations = 'smearing' \n   smearing = 'fermi-dirac'\n   degauss = 0.1d0\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <p>Task 1.2 - Assuming Spin Degenerate Metal</p> <p>Create a copy of the <code>01_O2</code> directory called <code>01_O2_metal</code>. Modify the input file in it to use a metallic occupation scheme with a small smearing width and run the calculation (as above). </p> <ul> <li> <p>Does the calculation now converge?</p> </li> <li> <p>Take a look at the log file, are the occupations of each band at each    k-point matche your expectations?</p> </li> </ul> Answer <p>There are a few states which are completely filled with electrons and then there are two states which are half-filled (i.e. one electron per state). The last state is almost empty.</p> <pre><code>          k = 0.0000 0.0000 0.0000 ( 26462 PWs)   bands (ev):\n\n   -27.9544 -21.2930 -12.5056 -11.0340 -11.0340  -7.4591  -7.4591  -2.9357\n\n     occupation numbers\n     1.0000   1.0000   0.9800   0.9433   0.9433   0.5460   0.5460   0.0415\n</code></pre> <p>While treating this system as a metal may help converging the calculation, it may not necessarily reach the true ground state (i.e. the state with the lowest total energy). This is because we have imposed that there is an equal number of up-spin and down-spin electrons, and treating the system as an metal allows the electrons to occupy higher energy states. A better way to describe the system is to allow different numbers of spin-up and spin-down electrons (i.e., doing a spin-polarized calculation), we can perform a spin-polarized calculation by adding the <code>nspin</code> and <code>tot_magnetization</code> variables to the input file (highlighted below):</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    verbosity = 'high'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n   nspin = 2 #(1)!\n   tot_magnetization = 2.0 #(2)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <ol> <li><code>nspin</code>: this is 1 by default so no spin polarization is taken into        account. To perform a spin polarized calculation it should be set to 2.</li> <li><code>tot_magnetization</code>: this is difference between the number of spin-up and       spin-down electrons in the cell.</li> </ol> <p>Task 1.3 - Assuming Spin Polarized Metal</p> <p>Create another copy of <code>01_O2</code> called <code>01_O2_spin</code>. Then, try to:</p> <ol> <li> <p>Only turn on spin polarization (<code>nspin=2</code>). Does the calculation run?</p> Answer <p>The calculation will not run because it needs to know how to set the number of electrons with each spin. <pre><code>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n    Error in routine iosys (1):\n    fixed occupations and lsda need tot_magnetization\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</code></pre></p> </li> <li> <p>Set the total magnetization to 0.0, which would be the case if we     don't have any net magnetization in the molecule, i.e. the two spins in    the \\(\\pi_x^*\\) and \\(\\pi_y^*\\) orbitals point in opposite directions. What    is the final total energy?</p> Final energy <p>The calculation converges to a total energy of -63.25520699 Ry.</p> </li> <li> <p>Set the total magnetization to 2.0, which corresponds    to both spins pointing in the same direction. Is the total energy lower?    Are the Kohn-Sham energies the same for up-spin electrons and down-spin    electrons?</p> Answer <p>The calculation converges to a total energy of -63.29338911 Ry. This is lower than for the configuration in which the spins point in the same direction. The Kohn-Sham energies are different for up-spin and down-spin electrons: the Kohn-Sham eigenvalues and occupations are written in the log file with the spin-up values printed first, followed by the spin-down values.</p> <pre><code> ------ SPIN UP ------------\n\n\n          k = 0.0000 0.0000 0.0000 ( 26462 PWs)   bands (ev):\n\n   -28.5946 -22.0951 -12.9798 -11.8147 -11.8147  -8.3869  -8.3869  -3.4845\n\n ------ SPIN DOWN ----------\n\n\n          k = 0.0000 0.0000 0.0000 ( 26462 PWs)   bands (ev):\n\n   -27.1299 -20.3045 -11.9232 -10.0441 -10.0441  -6.3091  -6.3091  -2.2868\n\n     highest occupied, lowest unoccupied level (ev):    -8.3869   -6.3091\n</code></pre> </li> </ol> <p>You have now seen that allowing for different numbers of up-spin and down-spin electrons can sometimes lower the total energy of the material.</p> <p>Fun fact</p> <p>O2 can exist in its non-magnetic state, but it this state it is actually quite dangerous (see e.g. <code>this paper</code>), so treating the spin correctly is important for your health!</p>"},{"location":"labs/lab06/readme/#iron","title":"Iron","text":"<p>Now that you've seen how including spin polarization has allowed us to correctly describe the ground state of a molecular system, the next step is to use it to describe a magnetic crystal. In contrast to a molecule, where the Kohn-Sham wavefunctions of all states are fully contained in the unit cell of our DFT calculation, the Kohn-Sham wavefunctions of electrons in crystals are delocalized over many unit cells. In other words: each unit cell only contains a small fraction of the electron which occupies a certain Bloch Kohn-Sham state. As a consequence of this, the difference of the total number of up-spin and down-spin electrons in each unit cell does not have to be an integer number. Also, it is much harder to estimate the total magnetization of each unit cell of a crystal. </p> <p>One of the most common magnetic crystals is iron, so we'll study this material. The directory <code>02_Fe</code> contains an input file for iron. Note this is a BCC crystal structure (as set by <code>ibrav = 3</code> in the input file), whereas most of the crystal structures you have studied so far in the labs have been FCC. The calculation has been set up in the usual way for a metallic system.</p> <p>Task 2.1 - Fixed Magnetization</p> <ol> <li> <p>Run this calculation and check everything works as expected. What is the    final total energy?</p> Answer <p>The final total energy should be -55.52528610 Ry.</p> </li> <li> <p>Now make a copy of the calculation directory and in this new directory,    modify the input file to allow for spin polarization. Try running the    calculation with <code>tot_magnetization = 0.0</code> first, and compare your total    energy to the one obtained using doubly degenerate bands. </p> <p>Warning</p> <p>Note that iron remains a metal in its magnetic configuration. So you need keep the input variables associated with smearing the occupancies even if you are running a spin-polarized calculation for iron.</p> Answer <p>The total energy becomes -55.52528589 Ry. Almost identical to the one obtained with the doubly degenerate bands. This is because these two calculations are essentially identical.</p> </li> <li> <p>Now try setting the total magnetization to 1.0 and see how the total    energy changes: is it lower than the result of the non-magnetic    calculation?</p> Answer <p>The total energy becomes -55.53839616 Ry. It is lower than the result obtained without spin polarization.</p> </li> <li> <p>Try setting the total magnetization to 2.0. How does the final energy    compare to the previous value?</p> Answer <p>The total energy becomes -55.56226730 Ry. Lower than all previous cases.</p> </li> </ol> <p>We could keep going like this and try out many different values for the total magnetization to see which one has the lowest total energy (as discussed above, the total magnetization in the unit cell does not have to be an integer). Instead of doing this yourself, Quantum Espresso can do it for you: this is achieved by setting the <code>starting_magnetization</code> input variable.</p> <p>Task 2.2 - Relaxed magnetization</p> <ol> <li> <p>Make another copy of the <code>02_Fe</code> directory, and this time set <code>nspin =    2</code>, and <code>starting_magnetization = 1.0</code> (do not include the    <code>tot_magnetization</code> variable). Run the calculation    and see what the final total magnetization per cell is.</p> Answer <p>The total magnetization becomes larger than 2.0.</p> <pre><code>total magnetization       =     2.21 Bohr mag/cell\n</code></pre> <p>This value is in good agreement with the experimental value of 2.15 Bohr mag/cell.</p> </li> <li> <p>Use the input files and scripts in the directory <code>extra_bandstructure</code> to    generate a plot of the electronic band structure of BCC Fe.</p> Answer <p>You can find the relevant input file in the directory <code>02_Fe/extra_bandstructure</code>. The band structure should look like this: </p> <p> </p> <p>You can find <code>README.md</code> in the directory for more information on how to reproduce this plot.</p> </li> </ol>"},{"location":"labs/lab06/readme/#summary","title":"Summary","text":"<p>In this lab you have seen:</p> <ul> <li>how to do a DFT calculation including spin polarization.</li> <li>how some materials can lower their ground state energy by becoming magnetic.</li> <li>how to use spin-polarized calculations to find the correct magnetization of a   magnetic crystal.</li> </ul>"},{"location":"labs/lab06/02_Fe/extra_bandstructure/","title":"Using python","text":"<ol> <li> <p>run pw.x for each input file: <pre><code># run SCF calculation\npw.x &lt; Fe.spin.scf.in &gt; Fe.spin.scf.out\n\n# run NSCF calculation\npw.x &lt; Fe.spin.nscf.in &gt; Fe.spin.nscf.out\n\n# run bands calculation to extract band informtaion\n# Note that we have to do this for each spin channel\n\n# Spin Channel Up\nbands.x &lt; Fe.spin.bands.up.in &gt; Fe.spin.bands.up.out\n\n# Save data to bands.out.up.gnu\ncp bands.out.gnu bands.out.up.gnu\n\n# Spin Channel Down\nbands.x &lt; Fe.spin.bands.dn.in &gt; Fe.spin.bands.dn.out\n\n# Save data to bands.out.dn.gnu\ncp bands.out.gnu bands.out.dn.gnu\n</code></pre></p> </li> <li> <p>plot <pre><code>python plotbands_shifted.py\n</code></pre></p> </li> </ol>"},{"location":"labs/lab07/readme/","title":"Structural Optimisation","text":"<p>This week, we will focus on predicting the atomic structure of materials and molecules. In particular, we will study techniques that allow us to find the atomic structure with the lowest energy. We will begin by briefly reviewing the very important concept of a potential energy surface (PES). </p>"},{"location":"labs/lab07/readme/#the-potential-energy-surface","title":"The potential energy surface","text":"<p>The potential energy surface (PES) gives the total energy of a molecule or crystal (excluding the kinetic energy of the nuclei, hence the name potential energy surface) as function of the nuclear positions. It is commonly denoted as \\(U(\\{\\mathbf{R}\\})\\), where \\(\\mathbf{R}\\) represents the set of nuclear positions. Many useful quantities, such as the forces acting on the nuclei or the stress in a crystal, can be calculated by evaluating the relevant derivatives of the PES.  </p>"},{"location":"labs/lab07/readme/#ground-state-structure-of-molecules","title":"Ground state structure of molecules","text":"<p>The ground state structure of a molecule simply refers to the structure with the lowest total energy. This atomic structure is also called the optimal, equilibrium, or stablest structure of the molecule. Mathematically, this structure is associated with the global minimum of the PES. Therefore, the atomic forces in this structure will all vanish.  </p> <p>Most DFT codes, like Quantum Espresso, move the nuclei by moving them in the direction of the forces that act on them until the atomic forces \"vanish\", i.e. become lower than some cutoff value. This process is called relaxation or structural optimisation. The resulting structure obtained from this procedure is called the relaxed structure. </p> <p>In the first part of the lab, we will demonstrate how to calculate the forces and find the optimal structure of a molecule in Quantum Espresso. </p> <p>Danger: metastable structures</p> <p>When relaxing large molecules, there might be other local minima in the PES. These local minima are associated with atomic structures which are higher in the total energy, but the the forces also vanish. These structures are called metastable structures.</p> <p>When searching for the stablest structures using DFT, there is always a possibility that your calculation is \"trapped\" in one of these metastable structures. Whereas this is less likely to happen for small molecules, this can happen with large molecules. You will have to be careful! </p> <p>Question</p> <p>How can we reduce the risk of mistaking a metastable structure as the ground state structure? </p> Answer <p>After obtaining a relaxed structure, add some small (but not too small) random displacement to the nuclei and then redo the relaxation. If the displacement is sufficiently large, your structure can now relax to a different minimum of the PES. </p>"},{"location":"labs/lab07/readme/#forces-in-molecules","title":"Forces in molecules","text":"<p>The force acting on a nucleus, \\(\\mathbf{F}\\), is defined as the first derivative of the PES, \\(U\\), with respect to the position of that nucleus, \\(\\mathbf{R}\\). Mathematically, $$ \\mathbf{F} = -\\nabla_\\mathbf{R} U. $$</p> <p>In following tasks, we will go through how the atomic forces are calculated in Quantum Espresso. We have prepared a distorted methane molecule, \\(\\mathrm{CH_4}\\), where one of the hydrogen atoms (the one sitting on the z-axis above the \\(\\mathrm{C}\\) atom) is pushed closer to the carbon atom than others. </p> <p>This is how the distorted methane molecule looks like. The white atoms are the hydrogen atoms, and the black atom is the carbon atom. Notice how the top hydrogen atom is so close to the carbon atom that it gets merged into the carbon atom in the visualisation.  </p> <p>Task 1 - Examining atomic forces in the output file</p> <ul> <li>Go to the directory <code>01_ch4_scf</code>. </li> <li>Read input file <code>CH4.in</code>. The most important section of the file is shown below.  <pre><code> &amp;CONTROL\n    pseudo_dir = '.'  \n    disk_io = 'none'  \n    tprnfor = .true. #(1)!\n /\n...\n\nK_POINTS gamma #(2)!\n</code></pre><ol> <li><code>tprnfor</code> asks Quantum Espresso to print the forces.</li> <li>We only use the \\(\\Gamma\\)-point since we are modelling a molecule. </li> </ol> </li> <li>Run the command <code>pw.x &lt; CH4.in &gt; CH4.out</code>.</li> <li> <p>When the calculation is finished, search the output file for the line saying <code>Forces acting on atoms</code>. This should be written just before the timing information. </p> </li> <li> <p>You should find a section that looks like the following:  <pre><code> Forces acting on atoms (cartesian axes, Ry/au):\n\n atom    1 type  1   force =     0.00015533    0.00000000  -22.80532399\n atom    2 type  2   force =    -0.00015700    0.00000000   22.78015891\n atom    3 type  2   force =    -0.04291717    0.00000000    0.00839216\n atom    4 type  2   force =     0.02145942    0.03717243    0.00838646\n atom    5 type  2   force =     0.02145942   -0.03717243    0.00838646\n\n Total force =    32.233898     Total SCF correction =     0.000310\n</code></pre></p> </li> <li>Why are these atomic forces expected for this distorted methane molecule? </li> </ul> Answer <p>Since the \\(\\mathrm{H}\\) atom (atom 2) above the \\(\\mathrm{C}\\) atom (atom 1) is pushed closer to the \\(\\mathrm{C}\\) atom, the covalent \\(\\mathrm{C}-\\mathrm{H}\\) bond between these two atoms is compressed. The two atoms will repel each other to uncompress the bond. Atom 2 should experience an upward force and atom 1 should experience a downward force, and this pair should be approximately equal and opposite. This is indeed the case in the output file.  </p> <ul> <li>What are the units of atomic forces in Quantum Espresso? </li> </ul> Answer <p>Ry/Bohr. 1 Ry/Bohr is equivalent to 25.7 eV/\u00c5, check this yourself!</p> Understanding the units better <p>In this task, the \\(z\\)-component of the force acting on the \\(\\mathrm{H}\\) atom is 22.80 Ry/Bohr. This means that moving the \\(\\mathrm{H}\\) atom along the positive \\(z\\)-direction by 0.01 Bohr reduces the total energy by about 0.28 Ry, or 3.81 eV. This is a large gain in energy. This is because the covalent bond is strong, and the size of compression is large. So pushing the H atom away from the C atom by any small amount will lead to a large gain in energy.  </p> <p>Note</p> <p>The <code>Total force</code> listed here is the square root of the sum of all of the force components squared</p> \\[ F = \\sqrt{\\sum_{i\\in\\mathrm{atoms}}|\\mathbf{F}_{i}|^2}      \\] <p>If the <code>Total SCF correction</code> is comparable to the <code>Total force</code> it usually means you need to try to better converge the SCF cycle (via <code>conv_thr</code>).</p>"},{"location":"labs/lab07/readme/#convergence-test","title":"Convergence test","text":"<p>Just as we have to check the convergence of the total energy against the plane-wave cutoff, we have to check the convergence of the atomic forces against the plane-wave cutoff, too. Note that you might need a different cutoff to convergence the forces than for the total energy! To save a bit of time, we simply show you the result of such a convergence study for the methane molecule below. </p> <p>In the figure, \\(\\delta_E=(E^{\\mathrm{tot}}_{\\mathrm{best}}-E^{\\mathrm{tot}}_{\\mathrm{PW_cutoff}})/E^{\\mathrm{tot}}_{\\mathrm{best}}\\), the fractional difference in total energy you have calculated in lab 3, and \\(\\delta_F=(F^{\\mathrm{tot}}_{\\mathrm{best}}-F^{\\mathrm{tot}}_{\\mathrm{PW_cutoff}})/F^{\\mathrm{tot}}_{\\mathrm{best}}\\), the same fractional difference for the total force (we have scaled the energy curve by a factor of 10 for visual clarity). You will notice that the magnitude of \\(\\delta_E\\) is much smaller than that of  \\(\\delta_F\\). This shows that the total force converges slower with respect to the plane-wave cutoff than to the total energy. So if you want to find the stablest structure of a material or molecule, make sure the force is converged with respect to the plane-wave cutoff! </p>"},{"location":"labs/lab07/readme/#optimisation-of-molecular-geometry","title":"Optimisation of molecular geometry","text":"<p>Now that we have seen how to calculate the forces associated with a particular atomic structure, we can use Quantum Espresso to optimise the structure of molecules.</p> <p>Task 2 - Optimising the molecular structure</p> <ul> <li>Go to the directory <code>02_ch4_opt</code>. </li> <li> <p>Read the input file <code>CH4_opt.in</code>, the important parts are shown below.  <pre><code> &amp;CONTROL\n    calculation = 'relax' #(1)! \n    pseudo_dir = '.'\n    disk_io = 'none'\n    tprnfor = .true.\n    forc_conv_thr = 1.0D-4 #(2)!\n /\n\n &amp;SYSTEM\n    ibrav =  1\n    A = 20.0\n    nat = 5\n    ntyp = 2\n    ecutwfc = 80\n /\n\n &amp;ELECTRONS\n /\n\n &amp;IONS #(3)!\n / \n...\n</code></pre></p> <ol> <li>Tells Quantum Espresso to carry out a structure optimisation.   </li> <li>Set convergence criterion for forces in units of Ry/Bohr.   </li> <li>You'll need to add an <code>IONS</code> section to the input. This is needed when <code>calculation=relax</code>. There are many other variables you can add for the IONS section. These include the algorithm of relaxation. If you are interested, you can read about it in the input description of <code>pw.x</code>.</li> </ol> </li> <li> <p>Run <code>pw.x &lt; CH4_opt.in &gt; CH4_opt.out</code>.  </p> </li> <li>In the output file, navigate to the line that says <code>End of BFGS Geometry Optimization</code>. The important sections above the end of the output file are shown below.  <pre><code> ...\n\n number of scf cycles    =  17 #(1)!\n number of bfgs steps    =  15 #(2)!\n\n ... \n\n Forces acting on atoms (cartesian axes, Ry/au):\n\n atom    1 type  1   force =    -0.00000168    0.00000000    0.00000028 #(3)! \n atom    2 type  2   force =     0.00000060    0.00000000    0.00009975\n atom    3 type  2   force =    -0.00001049    0.00000000   -0.00003770\n atom    4 type  2   force =     0.00000578    0.00000471   -0.00003116\n atom    5 type  2   force =     0.00000578   -0.00000471   -0.00003116\n\n Total force =     0.000116     Total SCF correction =     0.000046 \n\n... \n\n bfgs converged in  18 scf cycles and  15 bfgs steps #(4)! \n\nBegin final coordinates\n\n... \n\nATOMIC_POSITIONS (angstrom)\nC                0.0000041368        0.0000000000       -0.1580814281\nH                0.0000879609        0.0000000000        0.9402289196\nH                1.0356035232        0.0000000000       -0.5241329179\nH               -0.5178483105       -0.8968828453       -0.5240072869\nH               -0.5178483105        0.8968828453       -0.5240072869\nEnd final coordinates #(5)!\n</code></pre><ol> <li>The latest number of scf cycles is shown after each scf cycle. </li> <li>The latest number of relaxation steps is shown after each relaxation step. Here, a relaxation step is called a \"bfgs step\" in our calculation. This is just the name of our relaxation algorithm.</li> <li>The components of the force on each atom are almost zero. </li> <li>The total number of scf cycles is 18, and the number of relaxation steps taken is 15. </li> <li>Atomic coordinates of the relaxed structure. </li> </ol> </li> </ul> What is the equilibrium bond length? <p>By taking the difference between the \\(z\\)-coordinates of atoms 2 and 1, the bond length is found to be 1.10 \u00c5. The experimental value is 1.09 \u00c5 so this is in good agreement. You can check that all the bond lengths are the same.  </p> <p>The animation below visualises the motion of the atoms during the relaxation. You can clearly see how in the first step, the top hydrogen atom is pushed away from the carbon atom.   </p>"},{"location":"labs/lab07/readme/#ground-state-structure-of-crystals","title":"Ground state structure of crystals","text":"<p>We have seen how the stablest structures of molecules can be determined by finding the atomic positions for which the forces vanish. In contrast to a molecule, the atomic structure of a crystal is specified by the atomic positions of the atoms inside the unit cell and also by the shape and size of the unit cell. To find the stablest atomic structure of a crystal, a few additional concepts are needed.</p>"},{"location":"labs/lab07/readme/#stress-and-pressure-in-crystals","title":"Stress and pressure in crystals","text":"<p>Mathematically, the stress is a rank-2 tensor, i.e. a matrix, \\(\\sigma_{ij}\\), defined through the relation  </p> \\[ F_{i} =  \\sigma_{ij}\\epsilon_{j} \\] Tip: what does stress measure and why is it a matrix? <p>Stress is the ratio between the \\(i\\)-th component of the induced force (e.g. this could be the \\(x\\)-component), \\(F_{i}\\), due to a deformation along the \\(j\\)-th direction (e.g. in the \\(x\\)- or \\(z\\)-direction), \\(\\epsilon_{j}\\). So it measures how favourable or unfavourable it is to distort the crystal along a certain direction in terms of the induced force along different directions. </p> <p>This is also why it is a matrix, you need to specify two pieces of information before reading the stress tensor. You need to decide which distortion direction, and which component of the induced force you would like to know from the stress tensor. </p> <p>Whereas stress describes the force induced on a crystal due to a distortion along a certain direction, the pressure, \\(P\\), of a crystal measures the change in total energy due to contraction or expansion. The pressure is defined as the negative of the derivative of the PES with respect to the volume, \\(V\\). It measures the tendency of the crystal to expand or contract. Mathematically,  </p> \\[ P = -\\frac{dU}{dV}. \\] Tip: what does it mean to have a structure with a negative or positive pressure? <p>If the pressure is negative, the crystal structure is unstable and will contract. If the pressure is positive, the crystal structure is also unstable but it will expand. The structure is only stable when the pressure is close to zero, as first derivatives of the PES vanish at the equilibrium structure.  </p> <p>Having introduced these useful quantities, we can try to calculate these quantities using Quantum Espresso. In the following tasks, we will look at carbon diamond. The unit cell of this crystal contains two carbon atoms. We will first run a single-point calculation for this crystal.  </p> <p>Task 3 - calculating stress and pressure of crystals</p> <ul> <li> <p>Go to the directory <code>03_cd_strpr</code>. Read the input file <code>CD_scf.in</code>. The important parts are shown below. <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    prefix = 'CD'\n    disk_io = 'low'\n    tprnfor = .true.\n    tstress = .true. #(1)!\n /\n\n... \n\nATOMIC_POSITIONS crystal #(2)!\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\nK_POINTS automatic #(3)!\n8 8 8 0 0 0\n</code></pre></p> <ol> <li>This tells Quantum Espresso to print the stress.  </li> <li>Fractional (or crystal) coordinates are used to specify the atomic positions.      </li> <li>A k-grid must be specified since we are modelling a crystal.    </li> </ol> </li> <li> <p>Run <code>pw.x &lt; CD_scf.in &gt; CD.out</code>. </p> </li> <li> <p>Once the job has finished, look for the line saying \"total   stress\" in the output file. You should see something like this:     <pre><code>     Computing stress (Cartesian axis) and pressure\n\n          total   stress  (Ry/bohr**3)                   (kbar)     P=     1325.29\n   0.00900912  -0.00000000   0.00000000         1325.29       -0.00        0.00\n   0.00000000   0.00900912   0.00000000            0.00     1325.29        0.00\n   0.00000000   0.00000000   0.00900912            0.00        0.00     1325.29\n</code></pre></p> </li> <li> <p>What are the units for the stress tensor?</p> </li> </ul> Answer <p>Ry/Bohr^3. The dimension of this unit is energy per volume, which is the same dimension as pressure. </p> <ul> <li>What is the total pressure? </li> </ul> Answer <p>1325.29 kbar. Note that kbar is one of the common units for pressure.  </p> <ul> <li>Is the lattice constant optimised? Why? If not, does it want to expand or contract? </li> </ul> Answer <p>No. The evidence is that \\(P\\) is 1325.29 kbar, which is very large (atmospheric pressure is only 1 bar). Since the sign is positive, the lattice wants to expand. </p> <p>Note</p> <p>When simulating molecules (or 2D crystals), we use a large supercell with lots of vacuum to avoid artificial interactions between periodic images. When you calculate the stress for such a supercell, you often find that it is large and negative along the direction which separates the periodic images. Of course, this stress is not physically meaningful and should be ignored.  </p>"},{"location":"labs/lab07/readme/#optimizing-lattice-parameters-of-unit-cells","title":"Optimizing lattice parameters of unit cells","text":"<p>We will now carry out the structural optimisation in carbon diamond to find the equilibrium lattice parameter.      </p> <p>Note on choice of plane-wave cutoff</p> <p>Keep in mind that you might need a higher plane-wave cutoff to converge the force or the stress (as we saw at the start of this lab). Also, the number of plane waves in your calculation depends on the unit cell volume. So if during the course of the calculation we change the unit cell volume, we also change the number of plane waves; or if we fix the number of plane waves, we are changing the plane-wave cut-off (Quantum Espresso does the latter, but different DFT codes handle this differently). So you need to be quite careful when optimizing lattice vectors.</p> <p>Task 4 - Optimising the unit cell</p> <ul> <li> <p>Go to the directory <code>04_cd_opt</code> and read the input file <code>CD_opt.in</code>. You'll notice in addition to the inputs mentioned, there's also a fairly high energy cut-off, and we've lowered the SCF convergence threshold from the default. Run this now with <code>pw.x</code>. <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    prefix = 'CD'\n    disk_io = 'low'\n    calculation = 'vc-relax' #(1)!\n    etot_conv_thr = 1.0D-9 #(2)!\n    forc_conv_thr = 1.0D-6 #(3)!\n /\n ...\n &amp;IONS #(4)!\n /\n\n &amp;CELL #(5)!\n /\n</code></pre></p> <ol> <li>Tells Quantum Espresso to do a variable-cell (vc) relaxation. </li> <li>The energy tolerance is stricter than usual. </li> <li>Specifies the force tolerance. </li> <li>The IONS section is needed for vc-relaxation too.  </li> <li>The CELL section is also needed for vc-relaxation.  </li> </ol> </li> <li> <p>Now inspect the output file. It is very similar to the one for relaxing molecules in task 3. The most important section of the output file is shown below.  <pre><code>Begin final coordinates\n     new unit-cell volume =     73.86018 a.u.^3 (    10.94495 Ang^3 )\n     density =      3.64456 g/cm^3\n\nCELL_PARAMETERS (alat=  6.23609621) #(1)!\n  -0.534007441  -0.000000000   0.534007441 \n  -0.000000000   0.534007441   0.534007441\n  -0.534007441   0.534007441   0.000000000\n\nATOMIC_POSITIONS (crystal)\nC               -0.0000000000        0.0000000000       -0.0000000000\nC                0.2500000000        0.2500000000        0.2500000000\nEnd final coordinates\n</code></pre></p> <ol> <li>Quantum Espresso expresses the Cartesian components of the new lattice vectors in units of the original lattice parameter \\(a_0\\) (called <code>alat</code> here). See the tip box below for how to calculate the new lattice constant.   </li> </ol> </li> </ul> Tip on calculating the new lattice constant <p>The most general way to do this is to calculate the magnitude of each lattice vector. For example, the lattice constant along \\(\\mathbf{a}_1\\) is \\(\\frac{a_0}{\\sqrt{2}}\\times\\sqrt{a_{1x}^2+a_{1y}^2+a_{1z}^2}\\). Here \\(a_{1x}=-0.534\\), \\(a_{1y}=0\\), \\(a_{1z}=0.534\\), and \\(a_0=6.236\\) Bohrs. Using this method for the remaining two lattice vectors, you should find that the lattice constants are the same along the three directions.  </p> <p>However, for <code>ibrav=2</code>, there is a simpler way. You can simply calculate the ratio of the new and old Cartesian components of the lattice vectors, and multiply that by the original lattice constant. For example, \\(a_{1x}^{\\mathrm{new}}/a_{1x}^{\\mathrm{old}}\\times a_0\\), here \\(a_{1x}^{\\mathrm{old}}=-0.5\\). </p> <ul> <li>What is the final lattice constant? </li> </ul> Answer <p>Using any of the methods from the tip box, the new lattice constant is 6.66 Bohrs, which is 3.53 \u00c5. This is in excellent agreement with the experimental value of 3.57 \u00c5 (from Wikipedia).  </p> <ul> <li>How can you check if the lattice parameter is fully relaxed? </li> </ul> Answer <p>The pressure is 0.32 kbar, which is very small.  </p> <p>A word on the final pressure in the output file</p> <p>The final pressure at the end of the optimisation might appear large occasionally. This is because Quantum Espresso uses the basis set for the original input unit cell to calculate the pressure of the relaxed unit cell. However, if your cell has changed drastically, the adequate basis set for the relaxed unit cell should be recalculated based on the new lattice constant. So you should run a new scf calculation in that case. The artificial pressure due to the inadequacy of the plane-wave basis size is called the Pulay stress. You can look it up if interested.</p>"},{"location":"labs/lab07/readme/#bulk-modulus-of-crystals","title":"Bulk modulus of crystals","text":"<p>From the PES, we can calculate the bulk modulus, B, which measures how difficult it is to compress the material. Mathematically, it is defined as the negative of the second derivative of the PES with respect to volume multiplied by the volume:  </p> \\[ B = -V\\frac{d^2U}{dV^2}. \\] <p>Whereas Quantum Espresso prints the stress and pressure for you, it does not automatically calculate the bulk modulus. You will need to distort the unit cell volume manually yourself and run multiple <code>pw.x</code> calculations to obtain the PES as function of the unit cell volume. In particular, you will need to change the cell parameter <code>A</code> to change the cell volume. Let's do this in the following task. </p> <p>Task 5 - calculating the bulk modulus using the PES</p> <ul> <li> <p>Go to the directory <code>05_cd_bm</code>. You should find an input file called <code>CD_0.000.in</code>. This is the reference input file representing a diamond structure with a relaxed lattice parameter.  </p> </li> <li> <p>Create 10 copies of this input file, named <code>CD_i.in</code>, where <code>i</code> runs from -0.01 to 0.01 in steps of 0.002. Here <code>i</code> is going to be the fractional change in the lattice constant. </p> </li> <li> <p>Edit the lattice constant in each input file so that the new lattice constant is \\(A'=(1+i)A\\).</p> </li> <li> <p>Run <code>pw.x</code> for each <code>CD_i.in</code>. Note that we carry out a relaxation for each unit cell volume because in principle the equilibrium positions of the atom can be different for different lattice constants.  </p> </li> <li> <p>After the jobs are finished, create a file named <code>data.txt</code>, with the first column containing all the unit cell volumes \\(V\\) in Bohr^3, and the second column containing the total energies in Ry. </p> Tip on the finding the unit cell volume <p>The unit cell volume is provided in the line <code>unit-cell volume</code>. The units are in Bohr^3. </p> </li> <li> <p>Run <code>python3 BULK_MOD.py</code>. If you are interested, you can read the code and check out the unit conversions involved in expressing the bulk modulus in units of GPa. This should produce a graph, with a parabola fitted to it and print out a line that says \"The bulk modulus is ... GPa.\"</p> </li> <li> <p>What does the PES look like? </p> Answer <p></p> </li> <li> <p>How is the bulk modulus calculated? What is its value for this structure? </p> Answer <p>A parabola with the equation \\(ax^2+bx+c\\) is first fitted to the data points. The second derivative of this parabola is then simply \\(2a\\). Therefore, the bulk modulus per volume at this structure is \\(-2aV_{0}\\). Here \\(V_0=\\frac{1}{2^{3/2}}A_0^3\\) with \\(A_0=3.53\u00c5\\). The bulk modulus obtained from the code is -459 GPa. Compared to a literature value of -443 GPa (from Wikipedia), this is in very good agreement. </p> </li> <li> <p>Read the output file for <code>i</code>=0.01. How many relaxation steps does it take for the calculation to finish? </p> Answer <p>None. In this particular setup, through the use of fractional coordinates, the carbon atoms are guaranteed to sit at the high-symmetry positions, so that the net force acting on them vanishes. So for any given volume, the atomic positions are already relaxed. In fact, if you read any other output file, the number of bfgs steps should also be 0.  </p> </li> </ul>"},{"location":"labs/lab07/readme/#summary","title":"Summary","text":"<p>In this lab we have seen:</p> <ul> <li> <p>How to calculate atomic forces, stress, and pressure in Quantum Espresso. </p> </li> <li> <p>How to check if the forces have converged.</p> </li> <li> <p>How to optimise the structure of molecules, atomic positions in a crystal, and the lattice parameter of a crystal. </p> </li> <li> <p>How the PES allows us to estimate the bulk modulus.</p> </li> </ul>"},{"location":"labs/lab08/readme/","title":"Vibrational Normal Modes and Phonons","text":"<p>This week we will calculate the vibrational properties of molecules and solids. </p> <p>As you have seen in the lecture, the different vibrations that can be observed in molecules and crystals as well as their frequencies can be obtained from the potential energy surface (PES). More specifically, we can expand the PES in a Taylor series around the equilibrium atomic positions and then solve Newton's equation of motion. This procedure involves two important concepts: the force constant matrix and the dynamical matrix. </p> <p>Similar to last week, we will give a brief review of these matrices and why they are useful. Then we will learn how to calculate these quantities using Quantum Espresso. Let's now begin our dive into vibrations in molecules. </p>"},{"location":"labs/lab08/readme/#vibrations-in-molecules-basic-theory","title":"Vibrations in molecules: basic theory","text":"<p>When molecules are excited (e.g. by absorbing infrared radiation or by heating), they gain energy and the atoms start to vibrate around their equilibrium position. </p>"},{"location":"labs/lab08/readme/#force-constant-matrix","title":"Force constant matrix","text":"<p>The change in total energy due to a small displacement of the atoms around their equilibrium positions, \\(\\Delta U\\), can be written as, $$ \\Delta U = \\frac{1}{2}\\sum_{I\\alpha J\\beta} K_{I\\alpha J\\beta}u_{I\\alpha}u_{J\\beta}, $$ where \\(u_{I\\alpha}\\) denotes the \\(\\alpha\\)-component of the displacement vector of the atom labelled by \\(I\\). The matrix \\(K_{I\\alpha J\\beta}\\) is called the force constant matrix. It is defined by the equation  $$ K_{I\\alpha J\\beta} = \\frac{\\partial^2 U}{\\partial u_{I\\alpha}\\partial{u_{J\\beta}}}. $$ Note that \\(I\\) and \\(J\\) both run from \\(1\\) to \\(N\\), where \\(N\\) is the number of atoms in the molecule, and \\(\\alpha\\) and \\(\\beta\\) run from \\(1\\) to \\(3\\), with the convention \\(x\\rightarrow1, y\\rightarrow2, z\\rightarrow3\\).</p> Tip on understanding the indices of \\(\\mathbf{K}\\) <p>We can understand the indices of the matrix \\(\\mathbf{K}\\) by thinking about its physical meaning. It is called the force constant matrix because its components describe the \\(\\alpha\\)-component of the force acting on nucleus \\(I\\) generated by the motion of nucleus \\(J\\) along direction \\(\\beta\\). </p> Tip on writing down \\(\\mathbf{K}\\) as a two-dimensional matrix <p>The matrix \\(\\mathbf{K}\\) can be written as a two-dimensional matrix although its entries are labelled by four indices. We can combine the indices into two pairs: \\(\\{I\\alpha\\}\\) and \\(\\{J\\beta\\}\\). In this way we can write \\(\\mathbf{K}\\) as a \\(3N\\times3N\\) matrix, where \\(N\\) is the number of atoms and the factor of 3 comes from the fact that there are three Cartesian directions, \\(\\{x,y,z\\}\\).</p> Optional quick quiz - for your own understanding <p>What does the entry \\(K_{1123}\\) physically mean?</p> Answer <p>It is the force acting on atom 1 along the \\(x\\)-direction when atom 2 (and only atom 2) moves along the \\(z\\)-direction </p> <p>What does the entry \\(K_{1111}\\) physically mean?</p> Answer <p>It is the \\(x\\)-component of the force experienced by atom 1 when it moves along the \\(x\\)-direction. In most cases this should be positive because atom 1 should experience a restoring force that drives it back to the equilibrium position.  </p> <p>The force constant matrix is useful for calculating the change in the total energy change due to a displacement of the atoms. However, it is not directly related to vibrational properties.</p>"},{"location":"labs/lab08/readme/#dynamical-matrix","title":"Dynamical matrix","text":"<p>To calculate the vibrational properties, we need another matrix, the dynamical matrix.  </p> <p>To obtain vibrational properties, we have to solve the following matrix eigenvalue problem: $$ \\omega^2\\mathbf{v}=\\mathbf{D}\\mathbf{v},  $$ where \\(v_{I\\alpha}=\\frac{1}{\\sqrt{M_I}}u_{I\\alpha}\\) are the mass-weighted displacements, \\(\\omega\\) denotes the vibration frequency, and the matrix \\(\\mathbf{D}\\) is the dynamical matrix given by </p> \\[ D_{I\\alpha J\\beta}=\\frac{1}{\\sqrt{M_I M_J}}K_{I\\alpha J\\beta}.  \\] Tip: what is the physical meaning of the entries of \\(\\mathbf{D}\\)? <p>The physical meaning of the entries of \\(\\mathbf{D}\\) becomes evident when we compare the eigenvalue equation for vibrations to that of a one-dimensional classical spring-mass oscillator, with spring constant \\(k\\) and mass \\(m\\), which is  $$ \\omega^2x=\\frac{k}{m}x, $$ where \\(x\\) is the displacement and \\(\\omega\\) is the oscillation frequency. By comparing this equation to \\(\\omega^2\\mathbf{v}=\\mathbf{D}\\mathbf{v}\\), we see that \\(\\mathbf{D}\\) plays the same role as \\(k/m\\) - it measures the ratio of the strength of the spring constant of the atomic forces to the mass of the vibrating object. </p>"},{"location":"labs/lab08/readme/#vibrations-of-molecules-with-quantum-espresso","title":"Vibrations of molecules with Quantum Espresso","text":"<p>Density-functional theory can be used to calculate the dynamical matrix \\(\\mathbf{D}\\) of molecules. Quantum Espresso uses density-functional perturbation theory (DFPT) to do this.  We first calculate the vibrational properties of a methane molecule. You will learn how to use the programme <code>ph.x</code> for calculating the normal modes of a molecule. This calculation requires two steps:</p>"},{"location":"labs/lab08/readme/#step-1-run-the-pwx-calculation","title":"Step 1: run the <code>pw.x</code> calculation","text":"<p>The first step is to carry out a standard DFT calculation for the equilibrium structure of methane. </p> <p>Task 1a - run <code>pw.x</code></p> <ul> <li>Go to the directory <code>01_CH4</code>. </li> <li> <p>Read the input file <code>01_CH4_scf.in</code>. You should be familiar with all the input variables. <pre><code>ATOMIC_POSITIONS angstrom\n C  0.0           0.0           0.0\n H  0.634532333   0.634532333   0.634532333  #(1)!\n H -0.634532333  -0.634532333   0.634532333\n H  0.634532333  -0.634532333  -0.634532333\n H -0.634532333   0.634532333  -0.634532333\n\nK_POINTS automatic\n1 1 1  0 0 0   #(2)!\n</code></pre></p> <ol> <li>The positions of the \\(\\mathrm{H}\\) atoms have been relaxed. We provide the atomic positions in a very symmetric way. This is useful for Quantum Espresso as it can exploit the symmetries of molecules to speed up the calculation. See extra notes below to learn more about this if you are interested.  </li> <li>As we are dealing with a molecule, we only use the \\(\\Gamma\\)-point.</li> </ol> </li> <li> <p>Now run <code>pw.x &lt; 01_CH4_scf.in &gt; pw.out</code>.</p> </li> </ul>"},{"location":"labs/lab08/readme/#step-2-run-the-phx-calculation","title":"Step 2: run the <code>ph.x</code> calculation","text":"<p>The second step is to carry out the DFPT calculation using <code>ph.x</code>. </p> <p>Task 1b - run <code>ph.x</code></p> <ul> <li>Take a look at the input file for the <code>ph.x</code> module. It is called <code>02_CH4_ph.in</code>: <pre><code>    phonons of CH4 (gamma only)  #(1)!\n     &amp;INPUTPH   #(2)!\n      tr2_ph = 1.0d-15  #(3)!\n      asr = .true.   #(4)!\n     /\n    0.0 0.0 0.0    #(5)!\n</code></pre><ol> <li>The first line can be any informative comment. </li> <li>This is a new card required for performing <code>ph.x</code> calculations</li> <li>This is the scf convergence criterion for this normal mode calculation. Notice that it is very strict compared to what we usually use in standard DFT calculations.  </li> <li>'asr' stands for the Acoustic Sum Rule. This rule is used to correct the dynamical matrix in order to avoid negative vibration frequencies. </li> <li>This tells the code the wavevector of the vibrations. As we are dealing with a molecule, we are only interested in the \\(\\Gamma\\)-point.</li> </ol> </li> </ul> <p>Help file of <code>ph.x</code></p> <p>If you are interested in the input variables of <code>ph.x</code>, you can read about them   here</p> <ul> <li> <p>Run <code>ph.x &lt; 02_CH4_ph.in &gt; ph.out</code>. This will take a few minutes. </p> </li> <li> <p>You have successfully performed your first vibrational calculation!  </p> </li> </ul>"},{"location":"labs/lab08/readme/#output-files-of-phx","title":"Output files of ph.x","text":"<p>There are two important output files created by the <code>ph.x</code> calculation. The first one is the <code>.out</code> file, which provides some information about the DFPT calculations. The second file is the <code>matdyn</code> file which contains the dynamical matrix. Let's take a look at it!  </p> <p>Task 2 - Reading the dynamical matrix from Quantum Espresso</p> <ul> <li> <p>The most important section of the file begins with <code>Dynamical  Matrix in cartesian axes</code>. </p> </li> <li> <p>Let's go through this file step by step: <pre><code>     q = (    0.000000000   0.000000000   0.000000000 ) #(1)!\n\n     ... \n\n    1    2  #(2)! \n -0.24917799   0.00000000    -0.17192431   0.00000000    -0.17192431   0.00000000  #(3)! \n -0.17192431   0.00000000    -0.24917799   0.00000000    -0.17192431   0.00000000  #(4)!\n -0.17192431   0.00000000    -0.17192431   0.00000000    -0.24917799   0.00000000  #(5)!\n\n     ... \n\n     Diagonalizing the dynamical matrix\n\n     q = (    0.000000000   0.000000000   0.000000000 ) \n\n ************************************************************************** #(6)! \n     freq (    4) =       2.365513 [THz] =      78.905014 [cm-1]  #(7)!\n (  0.000000  0.000000  0.000092  0.000000  0.000000  0.000000 )  #(8)!\n ( -0.353554  0.000000  0.000093  0.000000  0.353553  0.000000 )  #(9)!\n ( -0.353554  0.000000  0.000093  0.000000 -0.353553  0.000000 ) \n (  0.353554  0.000000  0.000093  0.000000  0.353553  0.000000 ) \n (  0.353554  0.000000  0.000093  0.000000 -0.353553  0.000000 ) \n</code></pre></p> <ol> <li>This tells us the wave vector of the vibration. Here, this is the \\(\\Gamma\\) point. </li> <li>The matrix shown below is \\(D_{1{\\alpha}2{\\beta}}=\\frac{1}{\\sqrt{M_{1}M_{2}}}K_{1{\\alpha}2{\\beta}}\\), i.e. the dynamical matrix associated with the displacements of atoms 1 and 2 along Cartesian directions \\(\\alpha\\) and \\(\\beta\\). </li> <li>These entries are \\(D_{1x2x}\\), \\(D_{1x2y}\\), and \\(D_{1x2z}\\), respectively. The entries in the second, fourth, and sixth columns are the imaginary parts of the dynamical matrix.  </li> <li>These entries are \\(D_{1y2x}\\), \\(D_{1y2y}\\), and \\(D_{1y2z}\\), respectively. </li> <li>These entries are \\(D_{1z2x}\\), \\(D_{1z2y}\\), and \\(D_{1z2z}\\), respectively. </li> <li>The results obtained from diagonalizing the dynamical matrix can be found below this line. </li> <li>The vibration frequency of the fourth normal mode. </li> <li>The polarization vector of each atom in the fourth normal mode. This line says that the polarization vector of the C atom (i.e. atom 1) is (0,-0.447,0). The numbers in the second, fourth, and sixth columns are the imaginary parts of the polarization vector. </li> <li>Similar to the previous line, this line says that the polarization vector of one of the H atoms (atom 2) is (0,-0.447,0). </li> </ol> </li> <li> <p>So everything you want to know about the normal modes of a molecule will be contained in the <code>matdyn</code> file. Answer the following questions by reading this file. </p> </li> </ul> How many normal modes are there? Is this what we should expect? <p>15, since there are 15 frequencies in the file. This is expected because there are 5 atoms so the number of normal modes is \\(5\\times3=15\\).  </p> What are the distinct frequencies (up to 2 decimal places)? <p>The distinct frequencies are -0.01 THz, 2.37 THz, 37.37 THz, 44.29 THz, 87.07 THz, and 90.89 THz. Note that there are always three normal modes with nearly zero frequencies. However, they are slightly negative in our calculations because of numerical accuracies. You can increase the PW cutoff to reduce them, but the <code>ph.x</code> calculation will take longer.  </p> What are the degeneracies of each distinct frequency? <p>In the order of increasing energy, the degeneracies (i.e. the number of normal modes with the same frequency) are 3, 3, 3, 2, 1, 3. One finds such degeneracies in molecules that have a symmetrical shape. </p> <p>Visualising the normal modes</p> <p>If you are interested in how the normal modes look like, you can visit this link. On this website, you can see all the different vibrations of the methane molecule. These vibrational frequencies should be close to what you have obtained in Task 1b. You will see symbols like \\(T_2\\) and \\(A_1\\) next to each mode. These symbols are intended for vibrational spectroscopists to identify the normal modes.  Notice how the degenerate normal modes have the same symbols and very similar vibration patterns.</p> Extra notes - why do the three lowest normal modes always have zero frequency? <p>These normal modes correspond to the rigid translations of the molecule, i.e. movements of the molecule without distorting any chemical bonds. If no bonds are distorted, the molecule will not vibrate and the vibrational frequency should be zero. You can inspect the polarization vectors of these normal modes: there are the same for all atoms. In fact, the three modes are simply rigid translations along the \\(y\\), \\(x\\), and \\(z\\)-directions, respectively.   </p> Extra notes - symmetry reduction in Quantum Espresso <p>Quantum Espresso can exploit the symmetries of the molecule to reduce the number of the (rather costly) DFPT calculations: by placing the center of the molecule at the origin and giving the H atoms the same \\(x,y\\) coordinates except for the sign, the code understands that the methane molecule has certain rotational symmetries. Quantum Espresso uses this knowledge and only calculates the derivatives of the total energy with respect to one of the hydrogen positions (instead of all four of them). Quantum Espresso prints out the symmetries it has found in <code>ph.out</code>. </p>"},{"location":"labs/lab08/readme/#vibrations-in-crystals-basic-theory","title":"Vibrations in crystals: basic theory","text":"<p>Similar to electrons in crystals (whose wavefunctions are described by Bloch's theorem), vibrations in crystals have a wave-like character. Each vibration in a crystal is described by two labels: its wavevector \\(\\mathbf{q}\\) and its band index \\(\\nu\\) (similar to electrons in crystals which are described by a wavevector \\(\\mathbf{k}\\) and a band index \\(n\\)). The wavevector describes the propagation direction of the vibration and its spatial periodicity. The magnitude of the wavevector is given by $$ q=\\frac{2\\pi}{\\lambda}, $$ where \\(\\lambda\\) is the wavelength of the vibrational wave. These vibrational wave are often called phonons. </p> <p>Similar to the band structure of electrons in a crystal, the frequencies \\(\\omega_\\nu(\\mathbf{q})\\) of phonons give rise to a band structure. </p>"},{"location":"labs/lab08/readme/#vibrations-in-crystals-quantum-espresso-overview","title":"Vibrations in crystals: Quantum Espresso (overview)","text":"<p>We will now learn how to calculate phonon band structures using Quantum Espresso. This requires the calculation of the dynamical matrix for a set of wavevectors \\(\\mathbf{q}\\) in the first Brillouin zone. As these calculations are quite time-consuming, Quantum Espresso uses a few numerical tricks (such as performing calculations for the force constants on a coarse grid of \\(\\mathbf{q}\\)-points and then interpolating to a finer grid). This requires a few additional steps compared to the calculation for a molecule.</p> <p>The calculation has five stages: </p> <ol> <li>Perform a self-consistent calculation of the electrons density and the Kohn-Sham wavefunctions. The module for this is <code>pw.x</code> as usual. </li> <li>Calculate the dynamical matrix on a coarse grid of wavevectors. The module for this is <code>ph.x</code>, which is the one we have used for molecules. </li> <li>Obtain a set of force constant matrices \\(\\mathbf{K}(\\mathbf{R})\\) in real space by Fourier transforming the dynamical matrices \\(\\mathbf{D}(\\mathbf{q})\\) obtained in the last step. The module for this is <code>q2r.x</code>.  </li> <li>Obtain the dynamical matrix over a denser grid of wavevectors by Fourier interpolation. The module for this is <code>matdyn.x</code>.</li> <li>Generate the phonon band structure plot. This will be done using Python. </li> </ol>"},{"location":"labs/lab08/readme/#vibrations-in-crystals-quantum-espresso-calculation","title":"Vibrations in crystals: Quantum Espresso (calculation)","text":"<p>We will now go through the calculations using carbon diamond as an example. </p>"},{"location":"labs/lab08/readme/#step-1-run-the-pwx-calculation_1","title":"Step 1: run the <code>pw.x</code> calculation","text":"<p>Task 4a - run <code>pw.x</code></p> <ul> <li>Go to the directory <code>02_CarbonDiamond</code>.</li> <li>Read the input file <code>01_CD_scf.in</code>. <ul> <li>Note that the variable <code>ecutrho</code> is set tighter for DFPT calculation of phonons. </li> <li>The prefix is defined explicitly as <code>'CD'</code>. This is useful when you run multiple calculations in different directories.</li> <li>All other variables should be familiar to you.  </li> </ul> </li> <li>Run <code>pw.x &lt; 01_CD_scf.in &gt; pw.out</code>. </li> <li>The other output files generated will be in the <code>CD.save</code> directory since we specified the prefix.</li> </ul>"},{"location":"labs/lab08/readme/#step-2-run-the-phx-calculation_1","title":"Step 2: run the <code>ph.x</code> calculation","text":"<p>Task 4b - run <code>ph.x</code></p> <ul> <li>Read the input file <code>02_CD_ph.in</code>. <pre><code>phonons of Carbon diamond on a grid \n &amp;INPUTPH\n  prefix = 'CD',         #(1)!\n  asr = .true.           #(2)! \n  ldisp = .true.         #(3)!\n  nq1=4, nq2=4, nq3=4    #(4)!\n  /\n</code></pre><ol> <li>We have specified the same prefix as in the scf input file.</li> <li>Use the acoustic sum rule.</li> <li><code>ldisp = .true.</code> tells Quantum Espresso to perform dynamical matrix calculation over a grid of q-points.</li> <li><code>nq1</code>, <code>nq2</code> and <code>nq3</code> define our q-point grid. This is the coarser grid. </li> </ol> </li> <li>Run <code>ph.x &lt; 02_CD_ph.in &gt; ph.out</code>. This will take a few minutes. </li> <li>The calculation produces a number of dynamical matrices. They have the same format as the <code>matdyn</code> file for the methane molecule. The file also contains information about the \\(\\mathbf{q}\\)-points at which the dynamical matrix is evaluated. </li> <li>Note that one file can contain dynamical matrices of several \\(\\mathbf{q}\\)-points if these \\(\\mathbf{q}\\)-points are related by a symmetry of the crystal. </li> </ul>"},{"location":"labs/lab08/readme/#step-3-run-the-q2rx-calculation","title":"Step 3: run the <code>q2r.x</code> calculation","text":"<p>Next we will generate the real-space force constants from the dynamical matrices calculated on a coarse grid in the first Brillouin zone using the <code>q2r.x</code> module.</p> <p>Task 4c - run <code>q2r.x</code></p> <p>Help file of <code>q2r.x</code></p> <p>If you are interested in the input variables of <code>q2r.x</code>, visit this link for the help file. </p> <ul> <li> <p>Read the <code>03_CD_q2r.in</code> input file.  <pre><code> &amp;input\n   fildyn = 'matdyn'     #(1)!\n   zasr = 'simple'       #(2)!\n   flfrc = 'CD444.fc'    #(3)! \n /\n</code></pre></p> <ol> <li><code>fildyn</code> is the name of the file for reading the dyamical matrices obtained from <code>ph.x</code>. </li> <li><code>zasr</code> decides how the acoustic sum rule is enforced. If the ASR is not enforced, the lowest frequency phonons at the \\(\\Gamma\\)-point will not have zero frequencies (as they should).   </li> <li><code>filefrc</code> specifies the output file name.</li> </ol> </li> <li> <p>Run <code>q2r.x &lt; 03_CD_q2r.in &gt; q2r.out</code>. This will run almost instantly.</p> </li> <li>This calculation produces the output file <code>CD444.fc</code> containing the force constant matrix for each pair of atoms in a 4x4x4 supercell. So this is \\(K(\\mathrm{R})\\). </li> </ul>"},{"location":"labs/lab08/readme/#step-4-run-the-matdynx-calculation","title":"Step 4: run the <code>matdyn.x</code> calculation","text":"<p>Now we want to use this to generate phonon band structure of diamond. For this, we will use the <code>matdyn.x</code> code.</p> <p>Task 4d - run <code>matdyn.x</code></p> <p>Help file of <code>matdyn.x</code></p> <p>If you are interested in the input variables of <code>matdyn.x</code>, visit this link.</p> <ul> <li> <p>Read the input file <code>04_CD_matdyn-bands.in</code>. <pre><code> &amp;input\n    asr = 'simple'            #(1)!\n    flfrc = 'CD444.fc'        #(2)!\n    flfrq = 'CD-bands.freq'   #(3)!\n    dos=.false.               #(4)!\n    q_in_band_form=.true.     #(5)!\n /\n8   #(6)!\n 0.000 0.000 0.000 30   #(7)! \n 0.375 0.375 0.750 10\n 0.500 0.500 1.000 30\n 1.000 1.000 1.000 30\n 0.500 0.500 0.500 30\n 0.000 0.500 0.500 30\n 0.250 0.500 0.750 30\n 0.500 0.500 0.500 0\n</code></pre></p> <ol> <li><code>asr</code> tells the code to enforce the acoustic sum rule.</li> <li><code>flfrc</code> to  give it the name of the file with the real-space force constants from the <code>q2r.x</code> calculation.</li> <li><code>flfrq</code> to give it the name of the output file to store the calculated frequencies.</li> <li><code>dos=.false.</code> tells the code we're not calculating the density of states </li> <li><code>q_in_band_form=.true.</code> tells the code we want to calculate bands between high-symmetry points.</li> <li>The number of high-symmetry points on the path. </li> <li>The list of high-symmetry points with the number of points to calculate along each line, in the same way as we did for the electronic band structure.</li> </ol> </li> <li> <p>Run <code>matdyn.x &lt; 04_CD_matdyn-bands.in &gt; matdyn.out</code>. Again, this is very fast.</p> </li> <li>The code generates the output files <code>CD-bands.freq</code> and <code>CD-bands.freq.gp</code>. Both of which contain the frequencies along the path we requested.</li> </ul>"},{"location":"labs/lab08/readme/#step-5-plotting-the-phonon-band-structure","title":"Step 5: plotting the phonon band structure","text":"<p>Finally, we want to generate a graph of these frequencies. For this, we will use the output file <code>CD-bands.freq.gp</code> which contains frequencies in units of cm-1.</p> <p>Task 5 - plotting the phonon band structure</p> <p>A python script <code>PHONON_BAND.py</code> has been provided for generating the phonon band structure. If you are interested in how the plotting is done, you can read the script. </p> What does the phonon band structure look like? <p> </p> How many normal modes are there at each q-point? <p>There are 2 atoms in the unit cell so there are \\(3\\times2=6\\) normal modes. </p> <p> </p> <p>Task 6 - visualising the phonons</p> <ul> <li> <p>Go to the website. This is a website for visualising phonons.</p> </li> <li> <p>Use <code>01_CD_scf.in</code> for the 'pw.x input file', <code>pw.out</code> for the 'pw.x output file', and <code>matdyn.modes</code> files for 'matdyn.modes file (generated by matdyn.x)'. </p> </li> <li> <p>Click 'Calculate phonon dispersion' and the visualisation should come up. </p> </li> <li> <p>You can select the phonon mode to visualise by clicking on the phonon band structure on the right. </p> </li> <li> <p>Now click on the lowest phonon band at the \\(\\Gamma\\) point. Firstly, you will notice that the frequencies of the three lowest phonon bands become zero. Secondly, all atoms move in-phase. These three lowest phonon modes are called acoustic modes. </p> </li> <li> <p>Now click on the highest phonon band at the \\(\\Gamma\\) point. You will notice how the atoms in each unit cell move in anti-phase. These phonon modes are called the optical modes. </p> </li> <li> <p>In both cases above, you will notice that periodicity of the atomic displacements is one unit cell. This is because we are at the \\(\\Gamma\\) point.</p> </li> <li> <p>Now click on any other phonon away from the \\(\\Gamma\\) point. Notice how there is now a modulation of the amplitude from one unit cell to another. You can increase the number of supercells to fully visualise the phonon. </p> </li> </ul>"},{"location":"labs/lab08/readme/#summary","title":"Summary","text":"<p>In this lab we have seen</p> <ul> <li>how to use the <code>ph.x</code> code to calculate the vibrational properties of a molecule.</li> <li>how to calculate the phonon band structure of a crystal.</li> </ul>"},{"location":"labs/lab09/readme/","title":"Finite Temperature Properties","text":"<p>At finite temperatures, the atoms in a material vibrate around their equilibrium positions (as long as the temperature is not so high that the material starts to melt) and this thermal motion of the atoms gives rise to changes in the properties of the material, such as its bulk modulus or its electric conductivity. In this lab, you will learn how to calculate finite temperature properties of materials using DFT. In fact, we will treat to motion of the atoms quantum-mechanically and include effects, such as the zero point motion.</p> <p>The vibrational properties of a material are a key input into the calculation of its finite-temperature properties. We will again use density-functional perturbation theory (DFPT) to calculate the frequencies of the vibrations and use the information to construct the phonon density of states from which we will calculate the total energy and the specific heat of the material. This will be done using python. In this lab, we will focus on the finite-temperature properties of diamond.</p>"},{"location":"labs/lab09/readme/#phonon-density-of-states","title":"Phonon density of states","text":"<p>The phonon density of states is obtained by counting how many phonon modes exist at each frequency. To do this, we first need to the frequencies of the the phonon modes. Recall that in a crystal the phonon modes are labeled by a wave vector \\(\\mathbf{q}\\) in the first Brillouin zone and a band index \\(\\nu\\).</p>"},{"location":"labs/lab09/readme/#phonon-calculations-on-a-fine-grid","title":"Phonon calculations on a fine grid","text":"<p>In Lab08 you already learned most of the steps you need to follow to perform phonon calculations on a grid of wave vectors. The only difference is the input file for <code>matdyn.x</code>.</p> <p>Task 1 - Calculate the dynamical matrix on a fine grid</p> <ul> <li>Copy the lab09 file into your <code>data</code> directory and go to the <code>01_CarbonDiamond</code> directory. </li> <li>Using what you learned in Lab08 and follow the necessary steps to compute the force constant matrix.</li> <li> <p>Take a look at the <code>05_CD_matdyn-fine.in</code> input file. You will notice a few differences compared to the input file from last week's lab. <pre><code>&amp;input\n    asr='simple'\n    flfrc='CD444.fc'\n    flfrq='CD-fine.freq' \n    fldos='CD.dos' \n    nk1=20,nk2=20,nk3=20 #(1)!\n    nosym=.true. #(2)!\n    dos=.true. #(3)!\n/\n</code></pre></p> <ol> <li>Request a 20x20x20 grid</li> <li>Do not use symmetry operations to speed up the calculation. This makes it easier to parse the output file</li> <li>Calculate the density of phonon states</li> </ol> </li> <li> <p>Run <code>matdyn.x</code> with this input file. It'll take a bit longer than the phonon band calculation as it is doing calculations for a lot of wave vectors.</p> </li> </ul> <p>After <code>matdyn.x</code> finishes, it will generate two important output files: <code>CD-fine.freq</code> and <code>CD.dos</code>. Take a look at the contents of each file. </p> <p>CD-fine.freq file</p> <ul> <li>The <code>CD-fine.freq</code> file contains the phonon frequencies for all the modes at each \\(\\mathbf{q}\\) point and is organized as follows <pre><code>&amp;plot nbnd=   6, nks=8000 /   #(1)!\n            0.000000  0.000000  0.000000 #(2)! \n  -0.0000    0.0000    0.0000 1390.4720 1390.4720 1390.4720 #(3)!\n          -0.050000  0.050000 -0.050000\n  96.9791   96.9791  162.3473 1387.9266 1387.9266 1391.4163\n          -0.100000  0.100000 -0.100000\n  190.7327  190.7327  321.7228 1380.5533 1380.5533 1393.6345\n          -0.150000  0.150000 -0.150000\n  278.1010  278.1010  475.2404 1369.1811 1369.1811 1395.4974\n    ... \n</code></pre><ol> <li>The first line tells you there are six bands per \\(\\mathbf{q}\\) point and 8000 (20x20x20) \\(\\mathbf{q}\\) points.</li> <li>Specifies the \\(\\mathbf{q}=(0,0,0)\\) point.</li> <li>There are six frequencies on this line, one for each band of the \\(\\mathbf{q}=(0,0,0)\\) point.</li> </ol> </li> </ul> <p>Now that you have obtained the phonon vibrational frequencies for a set of \\(\\mathbf{q}\\) points, the phonon density of states is calculated by counting how many phonon modes exist for a given frequency range. For example, if you want to know how many phonon modes exist between frequencies \\(\\omega\\) and \\(\\omega+d\\omega\\), the answer is \\(\\rho(\\omega)d\\omega\\):</p> \\[ \\text{number of phonon modes between } \\omega \\text{ and } \\omega+d\\omega=\\rho(\\omega)d\\omega \\] <p>The density of phonon states is calculated via the following expression:</p> \\[ \\rho(\\omega) = \\sum_{\\mathbf{q}\\nu}\\delta\\left(\\omega-\\omega(\\mathbf{q}\\nu)\\right)\\] <p>where \\(\\delta(...)\\) is the Dirac delta function, \\(\\mathbf{q} \\nu\\) denotes phonon mode \\(\\nu\\) at vector \\(\\mathbf{q}\\) and \\(\\omega(\\mathbf{q}\\nu)\\) is the frequency of that phonon mode. You can find the result of this calculation in the <code>CD.dos</code> file.</p> <p>CD.dos file</p> <ul> <li>The <code>CD.dos</code> file is organized as follows <pre><code> # Frequency[cm^-1] DOS PDOS\n -1.3637193144E-05  0.0000000000E+00  0.0000E+00  0.0000E+00 #(1)!\n  9.9998636281E-01  1.8451769729E-09  9.2259E-10  9.2259E-10\n  1.9999863628E+00  7.3808263018E-09  3.6904E-09  3.6904E-09\n  2.9999863628E+00  1.6606947988E-08  8.3035E-09  8.3035E-09\n  3.9999863628E+00  2.9523542031E-08  1.4762E-08  1.4762E-08\n    ... \n</code></pre><ol> <li>The first column provides the frequency of oscillation in cm^-1 and the second provides the density of states as states/cm^-1.</li> </ol> </li> </ul> <p>To know what the density of states actually looks like, let's now plot it.</p> <p>Task 2 - Plot the density of states</p> <ul> <li> <p>Look for a python file <code>DOS.py</code> and inspect it. You should see the following code: <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\ndos = np.loadtxt(\"CD.dos\", skiprows=1) #(1)!\nplt.plot(dos[:,0], dos[:,1]) #(2)!\nplt.xlabel(r'Frequency ($\\mathrm{cm}^{-1}$)',fontsize=12)\nplt.ylabel(r'DoS (states/$\\mathrm{cm}^{-1}$)',fontsize=12)\nplt.savefig(\"CD_dos.png\") #(3)!\nplt.show()\n</code></pre></p> <ol> <li>Read the DoS file, skipping the first row. The first row is a header and should not be read as data</li> <li>Plot column 0 against column 1</li> <li>Save the plot into an image file called <code>CD_dos.png</code></li> </ol> </li> <li> <p>Run this script with <code>python DOS.py</code> </p> </li> </ul> What does the density of states look like? <p> </p> How is the density of states related to the band structure? <p>If you compare this result against the phonon band structure you calculated in the last lab, you will see that the density of states is larger when the bands are flatter. If the bands are flatter, it means there are more phonon states per unit frequency, which directly translates to a larger density of states.</p> <p>We will utilize the density of states to compute several thermodynamic properties using python in the next step.</p>"},{"location":"labs/lab09/readme/#total-energy-at-temperature-t","title":"Total energy at temperature T","text":"<p>An important quantity that can be obtained from phonon density of states is the total energy of the vibrations at temperature \\(T\\). This is given by</p> \\[ E(T) = \\int_{0}^{+\\infty} \\hbar\\omega \\rho(\\omega)\\left(\\frac{1}{2} + n_{BE}(\\hbar\\omega,T)\\right)d\\omega \\] <p>where the factor \\(n_{BE}(E,T) = \\frac{1}{\\exp(E/k_\\mathrm{B} T)-1}\\) is the Bose-Einstein occupation factor. The physical meaning of this equation is the following: for each frequency \\(\\omega\\), we have to add up the energy of each phonon mode (given by \\(\\hbar \\omega (1/2 + n_{BE})\\)) and multiply this by the number of phonon modes with the same frequency (given by the phonon density of states).</p>"},{"location":"labs/lab09/readme/#performing-the-integral-using-python","title":"Performing the integral using python","text":"<p>The integral will be evaluated numerically using python. Let's begin by analysing the python script which performs this calculation.</p> <p>energy.py</p> <ul> <li>In the <code>01_CarbonDiamond</code> folder you will find the <code>energy.py</code> python script which performs the energy integration. The script reads in the the phonon density of states and the temperature and prints out the total energy at that temperature. Note that some constants are deliberately missing from this file, denoted by <code>???</code>. <pre><code>import sys\nimport numpy as np\n\nfilename = sys.argv[1] \nT = float(sys.argv[2]) #(6)!\n\ndata = np.loadtxt(filename, skiprows=1) #(5)!\nfreqs = data[:,0]\ndos = data[:,1]\nconstant1 = ???  #(1)!\nconstant2 = ???  #(2)!\ndw = freqs[1] - freqs[0] #(3)! \n\ntotal_energy = 0\nfor w, rho in zip(freqs, dos):\n\n  if abs(w) &lt; 1e-5:\n    continue #(4)!\n\n  bose = 1.0/(np.exp(constant1*w/T) - 1.0)\n  total_energy += constant2*w*rho*(0.5 + bose)*dw\n\nprint(total_energy)\n</code></pre><ol> <li>Replace ??? by the correct physical constant (in the correct units)</li> <li>Replace ??? by the correct physical constant (in the correct units)</li> <li>Numerical integration requires specifying the numerical discretization step</li> <li>If the frequency is too small, it will cause numerical problems because of a division by a very small number inside the Bose-Einstein occupation factor. We do not include the contribution from such frequencies in our calculations (convince yourself that this only produces a very small error).</li> <li>The first row of the <code>CD.dos</code> file is a header and should be ignored</li> <li>The temperature should be in Kelvin</li> </ol> </li> </ul> <p>Task 3 - Plot the energy as function of temperature</p> <ol> <li> <p>Take another look at the mathematical formula for \\(E(T)\\) above and determine which physical constants need to be specified in the program above. Modify <code>energy.py</code> so that it has the correct constants (Note: Carefully think about which units should be used!)</p> Answer <p><code>constant1=0.0366 K/cm^-1</code> <code>constant2=3.143e-05 eV s</code></p> </li> <li> <p>Run this program using the phonon density of states obtained in the previous section, for a temperature of 1 Kelvin (1K): <code>python energy.py CD.dos 1</code> </p> </li> <li>Repeat the previous step for the following list of temperatures in Kelvin: <code>(1, 2, 3, 4, 5, 6, 8, 10, 15, 20, 30, 50, 70, 100)</code> and plot the results using your favourite tools to generate a graph of energy as a function of temperature</li> </ol> What do the energy and heat capacity look as a function of temperature? <p> </p>"},{"location":"labs/lab09/readme/#analysing-the-energy","title":"Analysing the energy","text":"<p>Task 4 - Analyse the plot</p> As the temperature decreases, the energy of the vibrations decreases as well, but eventually it approaches a constant value. Why? <p>Answer: As the temperature drops, the phonons lose their thermal energy, but there's still a contribution to their energy coming from the zero-point motion (\\(\\hbar \\omega /2\\)) of each mode </p> As the temperature increases, the energy increases linearly with temperature. Why? <p>Answer: For sufficiently large temperatures, the system starts behaving classically, so the amount of energy it can store is proportional to the temperature and the constant of proportionality is the heat capacity.</p>"},{"location":"labs/lab09/readme/#heat-capacity-at-constant-volume","title":"Heat capacity at constant volume","text":"<p>There are many other properties of materials, such as the entropy, the pressure or the Helmholtz free energy (for reference, see Wikipedia and the reference therein) which we can calculate with this technique. </p> <p>The specific heat at constant volume tells us how much energy is required to increase the temperature of a material by a given amount. It can be obtained from the total energy by differentiating with respect to temperature:</p> \\[C_V(T) = \\left(\\frac{\\partial E}{\\partial T} \\right )_{const\\ V}  = k_B \\int_{0}^{+\\infty} \\left(\\frac{\\hbar\\omega}{k_B T}\\right)^2 \\rho(\\omega)\\frac{\\exp(\\hbar\\omega/k_B T)}{\\left[ \\exp(\\hbar\\omega/k_B T)-1\\right]^2} d\\omega\\] <p>Task 5 - Plot the specific heat as a function of temperature</p> <ul> <li>Create a new program <code>heat_capacity.py</code> that calculates the heat capacity of Carbon Diamond by modifying the <code>energy.py</code> program.</li> <li>Calculate the heat capacity for the same temperatures as you did for the energy in the previous task and create a graph of your results.</li> </ul>"},{"location":"labs/lab09/readme/#analysing-the-heat-capacity","title":"Analysing the heat capacity","text":"<p>At high temperatures, the heat capacity approaches a constant. This is the Dulong-Petit law, followed (approximately) by most materials. At low temperatures, the heat capacity is proportional to \\(T^3\\), as predicted by the Debye model.</p>"},{"location":"labs/lab09/readme/#summary","title":"Summary","text":"<p>In this lab you have learned</p> <ul> <li>How to compute the phonon density of states</li> <li>How to use the phonon density of states to obtain the total phonon energy and the specific heat.</li> </ul>"}]}